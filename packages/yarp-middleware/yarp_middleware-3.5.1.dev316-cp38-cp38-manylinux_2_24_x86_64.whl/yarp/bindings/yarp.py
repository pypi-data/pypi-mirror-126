# This file was automatically generated by SWIG (http://www.swig.org).
# Version 4.0.2
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
if _swig_python_version_info < (2, 7, 0):
    raise RuntimeError("Python 2.7 or later required")

# Import the low-level C/C++ module
if __package__ or "." in __name__:
    from . import _yarp
else:
    import _yarp

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_instance_variable(set):
    def set_instance_attr(self, name, value):
        if name == "thisown":
            self.this.own(value)
        elif name == "this":
            set(self, name, value)
        elif hasattr(self, name) and isinstance(getattr(type(self), name), property):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add instance attributes to %s" % self)
    return set_instance_attr


def _swig_setattr_nondynamic_class_variable(set):
    def set_class_attr(cls, name, value):
        if hasattr(cls, name) and not isinstance(getattr(cls, name), property):
            set(cls, name, value)
        else:
            raise AttributeError("You cannot add class attributes to %s" % cls)
    return set_class_attr


def _swig_add_metaclass(metaclass):
    """Class decorator for adding a metaclass to a SWIG wrapped class - a slimmed down version of six.add_metaclass"""
    def wrapper(cls):
        return metaclass(cls.__name__, cls.__bases__, cls.__dict__.copy())
    return wrapper


class _SwigNonDynamicMeta(type):
    """Meta class to enforce nondynamic attributes (no new attributes) for a class"""
    __setattr__ = _swig_setattr_nondynamic_class_variable(type.__setattr__)


import weakref

YARP_VERSION_MAJOR = _yarp.YARP_VERSION_MAJOR
YARP_VERSION_MINOR = _yarp.YARP_VERSION_MINOR
YARP_VERSION_PATCH = _yarp.YARP_VERSION_PATCH
YARP_VERSION = _yarp.YARP_VERSION
YARP_VERSION_SHORT = _yarp.YARP_VERSION_SHORT

def get_string(*args):
    return _yarp.get_string(*args)

def get_path(*args):
    return _yarp.get_path(*args)

def get_bool(key, defaultValue=False):
    return _yarp.get_bool(key, defaultValue)

def set_string(key, value):
    return _yarp.set_string(key, value)

def set_path(key, value):
    return _yarp.set_path(key, value)

def set_bool(key, value):
    return _yarp.set_bool(key, value)

def unset(key):
    return _yarp.unset(key)

def is_set(key):
    return _yarp.is_set(key)

def getEnvironment(key, found=None):
    return _yarp.getEnvironment(key, found)

def setEnvironment(key, value):
    return _yarp.setEnvironment(key, value)

def unsetEnvironment(key):
    return _yarp.unsetEnvironment(key)

def home():
    return _yarp.home()

def tempdir():
    return _yarp.tempdir()

def datahome():
    return _yarp.datahome()

def datadirs():
    return _yarp.datadirs()

def confighome():
    return _yarp.confighome()

def configdirs():
    return _yarp.configdirs()

def cachehome():
    return _yarp.cachehome()

def runtimedir():
    return _yarp.runtimedir()

def yarpdatahome():
    return _yarp.yarpdatahome()

def yarpdatadirs():
    return _yarp.yarpdatadirs()

def yarpconfighome():
    return _yarp.yarpconfighome()

def yarpconfigdirs():
    return _yarp.yarpconfigdirs()

def yarpcachehome():
    return _yarp.yarpcachehome()

def yarpruntimedir():
    return _yarp.yarpruntimedir()
class SwigPyIterator(object):
    r"""Proxy of C++ swig::SwigPyIterator class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _yarp.delete_SwigPyIterator

    def value(self):
        r"""value(SwigPyIterator self) -> PyObject *"""
        return _yarp.SwigPyIterator_value(self)

    def incr(self, n=1):
        r"""incr(SwigPyIterator self, size_t n=1) -> SwigPyIterator"""
        return _yarp.SwigPyIterator_incr(self, n)

    def decr(self, n=1):
        r"""decr(SwigPyIterator self, size_t n=1) -> SwigPyIterator"""
        return _yarp.SwigPyIterator_decr(self, n)

    def distance(self, x):
        r"""distance(SwigPyIterator self, SwigPyIterator x) -> ptrdiff_t"""
        return _yarp.SwigPyIterator_distance(self, x)

    def equal(self, x):
        r"""equal(SwigPyIterator self, SwigPyIterator x) -> bool"""
        return _yarp.SwigPyIterator_equal(self, x)

    def copy(self):
        r"""copy(SwigPyIterator self) -> SwigPyIterator"""
        return _yarp.SwigPyIterator_copy(self)

    def next(self):
        r"""next(SwigPyIterator self) -> PyObject *"""
        return _yarp.SwigPyIterator_next(self)

    def __next__(self):
        r"""__next__(SwigPyIterator self) -> PyObject *"""
        return _yarp.SwigPyIterator___next__(self)

    def previous(self):
        r"""previous(SwigPyIterator self) -> PyObject *"""
        return _yarp.SwigPyIterator_previous(self)

    def advance(self, n):
        r"""advance(SwigPyIterator self, ptrdiff_t n) -> SwigPyIterator"""
        return _yarp.SwigPyIterator_advance(self, n)

    def __eq__(self, x):
        r"""__eq__(SwigPyIterator self, SwigPyIterator x) -> bool"""
        return _yarp.SwigPyIterator___eq__(self, x)

    def __ne__(self, x):
        r"""__ne__(SwigPyIterator self, SwigPyIterator x) -> bool"""
        return _yarp.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n):
        r"""__iadd__(SwigPyIterator self, ptrdiff_t n) -> SwigPyIterator"""
        return _yarp.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n):
        r"""__isub__(SwigPyIterator self, ptrdiff_t n) -> SwigPyIterator"""
        return _yarp.SwigPyIterator___isub__(self, n)

    def __add__(self, n):
        r"""__add__(SwigPyIterator self, ptrdiff_t n) -> SwigPyIterator"""
        return _yarp.SwigPyIterator___add__(self, n)

    def __sub__(self, *args):
        r"""
        __sub__(SwigPyIterator self, ptrdiff_t n) -> SwigPyIterator
        __sub__(SwigPyIterator self, SwigPyIterator x) -> ptrdiff_t
        """
        return _yarp.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self

# Register SwigPyIterator in _yarp:
_yarp.SwigPyIterator_swigregister(SwigPyIterator)
cvar = _yarp.cvar
path_separator = cvar.path_separator

class PortReport(object):
    r"""Proxy of C++ yarp::os::PortReport class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _yarp.delete_PortReport

    def report(self, info):
        r"""report(PortReport self, yarp::os::PortInfo const & info)"""
        return _yarp.PortReport_report(self, info)

# Register PortReport in _yarp:
_yarp.PortReport_swigregister(PortReport)

class Contact(object):
    r"""Proxy of C++ yarp::os::Contact class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        __init__(Contact self, std::string const & name=std::string(), std::string const & carrier=std::string(), std::string const & hostname=std::string(), int port=-1) -> Contact
        __init__(Contact self, std::string const & hostname, int port) -> Contact
        __init__(Contact self, std::string const & carrier, std::string const & hostname, int port) -> Contact
        __init__(Contact self, Contact rhs) -> Contact
        __init__(Contact self, Contact rhs) -> Contact
        """
        _yarp.Contact_swiginit(self, _yarp.new_Contact(*args))
    __swig_destroy__ = _yarp.delete_Contact

    @staticmethod
    def fromConfig(config):
        r"""fromConfig(Searchable config) -> Contact"""
        return _yarp.Contact_fromConfig(config)

    @staticmethod
    def fromString(txt):
        r"""fromString(std::string const & txt) -> Contact"""
        return _yarp.Contact_fromString(txt)

    def getName(self):
        r"""getName(Contact self) -> std::string"""
        return _yarp.Contact_getName(self)

    def setName(self, name):
        r"""setName(Contact self, std::string const & name)"""
        return _yarp.Contact_setName(self, name)

    def getRegName(self):
        r"""getRegName(Contact self) -> std::string"""
        return _yarp.Contact_getRegName(self)

    def getHost(self):
        r"""getHost(Contact self) -> std::string"""
        return _yarp.Contact_getHost(self)

    def setHost(self, hostname):
        r"""setHost(Contact self, std::string const & hostname)"""
        return _yarp.Contact_setHost(self, hostname)

    def getPort(self):
        r"""getPort(Contact self) -> int"""
        return _yarp.Contact_getPort(self)

    def setPort(self, port):
        r"""setPort(Contact self, int port)"""
        return _yarp.Contact_setPort(self, port)

    def getCarrier(self):
        r"""getCarrier(Contact self) -> std::string"""
        return _yarp.Contact_getCarrier(self)

    def setCarrier(self, carrier):
        r"""setCarrier(Contact self, std::string const & carrier)"""
        return _yarp.Contact_setCarrier(self, carrier)

    def getNested(self):
        r"""getNested(Contact self) -> NestedContact const &"""
        return _yarp.Contact_getNested(self)

    def setNestedContact(self, nestedContact):
        r"""setNestedContact(Contact self, yarp::os::NestedContact const & nestedContact)"""
        return _yarp.Contact_setNestedContact(self, nestedContact)

    def hasTimeout(self):
        r"""hasTimeout(Contact self) -> bool"""
        return _yarp.Contact_hasTimeout(self)

    def getTimeout(self):
        r"""getTimeout(Contact self) -> float"""
        return _yarp.Contact_getTimeout(self)

    def setTimeout(self, timeout):
        r"""setTimeout(Contact self, float timeout)"""
        return _yarp.Contact_setTimeout(self, timeout)

    def setSocket(self, carrier, hostname, port):
        r"""setSocket(Contact self, std::string const & carrier, std::string const & hostname, int port)"""
        return _yarp.Contact_setSocket(self, carrier, hostname, port)

    def isValid(self):
        r"""isValid(Contact self) -> bool"""
        return _yarp.Contact_isValid(self)

    def toString_c(self):
        r"""toString_c(Contact self) -> std::string"""
        return _yarp.Contact_toString_c(self)

    def toURI(self, includeCarrier=True):
        r"""toURI(Contact self, bool includeCarrier=True) -> std::string"""
        return _yarp.Contact_toURI(self, includeCarrier)

    @staticmethod
    def convertHostToIp(name):
        r"""convertHostToIp(char const * name) -> std::string"""
        return _yarp.Contact_convertHostToIp(name)

# Register Contact in _yarp:
_yarp.Contact_swigregister(Contact)

def Contact_fromConfig(config):
    r"""Contact_fromConfig(Searchable config) -> Contact"""
    return _yarp.Contact_fromConfig(config)

def Contact_fromString(txt):
    r"""Contact_fromString(std::string const & txt) -> Contact"""
    return _yarp.Contact_fromString(txt)

def Contact_convertHostToIp(name):
    r"""Contact_convertHostToIp(char const * name) -> std::string"""
    return _yarp.Contact_convertHostToIp(name)

class ConnectionReader(object):
    r"""Proxy of C++ yarp::os::ConnectionReader class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _yarp.delete_ConnectionReader

    def expectBlock(self, data, len):
        r"""expectBlock(ConnectionReader self, char * data, size_t len) -> bool"""
        return _yarp.ConnectionReader_expectBlock(self, data, len)

    def expectText(self, *args):
        r"""expectText(ConnectionReader self, char const terminatingChar='\n') -> std::string"""
        return _yarp.ConnectionReader_expectText(self, *args)

    def expectString(self):
        r"""expectString(ConnectionReader self) -> std::string"""
        return _yarp.ConnectionReader_expectString(self)

    def expectInt(self):
        r"""expectInt(ConnectionReader self) -> int"""
        return _yarp.ConnectionReader_expectInt(self)

    def expectInt8(self):
        r"""expectInt8(ConnectionReader self) -> std::int8_t"""
        return _yarp.ConnectionReader_expectInt8(self)

    def expectInt16(self):
        r"""expectInt16(ConnectionReader self) -> std::int16_t"""
        return _yarp.ConnectionReader_expectInt16(self)

    def expectInt32(self):
        r"""expectInt32(ConnectionReader self) -> std::int32_t"""
        return _yarp.ConnectionReader_expectInt32(self)

    def expectInt64(self):
        r"""expectInt64(ConnectionReader self) -> std::int64_t"""
        return _yarp.ConnectionReader_expectInt64(self)

    def expectDouble(self):
        r"""expectDouble(ConnectionReader self) -> double"""
        return _yarp.ConnectionReader_expectDouble(self)

    def expectFloat32(self):
        r"""expectFloat32(ConnectionReader self) -> yarp::conf::float32_t"""
        return _yarp.ConnectionReader_expectFloat32(self)

    def expectFloat64(self):
        r"""expectFloat64(ConnectionReader self) -> yarp::conf::float64_t"""
        return _yarp.ConnectionReader_expectFloat64(self)

    def isTextMode(self):
        r"""isTextMode(ConnectionReader self) -> bool"""
        return _yarp.ConnectionReader_isTextMode(self)

    def isBareMode(self):
        r"""isBareMode(ConnectionReader self) -> bool"""
        return _yarp.ConnectionReader_isBareMode(self)

    def convertTextMode(self):
        r"""convertTextMode(ConnectionReader self) -> bool"""
        return _yarp.ConnectionReader_convertTextMode(self)

    def getSize(self):
        r"""getSize(ConnectionReader self) -> size_t"""
        return _yarp.ConnectionReader_getSize(self)

    def getWriter(self):
        r"""getWriter(ConnectionReader self) -> ConnectionWriter"""
        return _yarp.ConnectionReader_getWriter(self)

    def readEnvelope(self):
        r"""readEnvelope(ConnectionReader self) -> Bytes"""
        return _yarp.ConnectionReader_readEnvelope(self)

    def getReference(self):
        r"""getReference(ConnectionReader self) -> Portable"""
        return _yarp.ConnectionReader_getReference(self)

    def getRemoteContact(self):
        r"""getRemoteContact(ConnectionReader self) -> Contact"""
        return _yarp.ConnectionReader_getRemoteContact(self)

    def getLocalContact(self):
        r"""getLocalContact(ConnectionReader self) -> Contact"""
        return _yarp.ConnectionReader_getLocalContact(self)

    def isValid(self):
        r"""isValid(ConnectionReader self) -> bool"""
        return _yarp.ConnectionReader_isValid(self)

    def isActive(self):
        r"""isActive(ConnectionReader self) -> bool"""
        return _yarp.ConnectionReader_isActive(self)

    def isError(self):
        r"""isError(ConnectionReader self) -> bool"""
        return _yarp.ConnectionReader_isError(self)

    def requestDrop(self):
        r"""requestDrop(ConnectionReader self)"""
        return _yarp.ConnectionReader_requestDrop(self)

    def getConnectionModifiers(self):
        r"""getConnectionModifiers(ConnectionReader self) -> Searchable"""
        return _yarp.ConnectionReader_getConnectionModifiers(self)

    def pushInt(self, x):
        r"""pushInt(ConnectionReader self, int x) -> bool"""
        return _yarp.ConnectionReader_pushInt(self, x)

    def setSize(self, len):
        r"""setSize(ConnectionReader self, size_t len) -> bool"""
        return _yarp.ConnectionReader_setSize(self, len)

    @staticmethod
    def createConnectionReader(_is):
        r"""createConnectionReader(yarp::os::InputStream & _is) -> ConnectionReader"""
        return _yarp.ConnectionReader_createConnectionReader(_is)

    @staticmethod
    def readFromStream(portable, _is):
        r"""readFromStream(PortReader portable, yarp::os::InputStream & _is) -> bool"""
        return _yarp.ConnectionReader_readFromStream(portable, _is)

    def setParentConnectionReader(self, parentConnectionReader):
        r"""setParentConnectionReader(ConnectionReader self, ConnectionReader parentConnectionReader)"""
        return _yarp.ConnectionReader_setParentConnectionReader(self, parentConnectionReader)

    def flushWriter(self):
        r"""flushWriter(ConnectionReader self)"""
        return _yarp.ConnectionReader_flushWriter(self)

# Register ConnectionReader in _yarp:
_yarp.ConnectionReader_swigregister(ConnectionReader)

def ConnectionReader_createConnectionReader(_is):
    r"""ConnectionReader_createConnectionReader(yarp::os::InputStream & _is) -> ConnectionReader"""
    return _yarp.ConnectionReader_createConnectionReader(_is)

def ConnectionReader_readFromStream(portable, _is):
    r"""ConnectionReader_readFromStream(PortReader portable, yarp::os::InputStream & _is) -> bool"""
    return _yarp.ConnectionReader_readFromStream(portable, _is)

class ConnectionWriter(object):
    r"""Proxy of C++ yarp::os::ConnectionWriter class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _yarp.delete_ConnectionWriter

    def appendBlock(self, data, len):
        r"""appendBlock(ConnectionWriter self, char const * data, size_t len)"""
        return _yarp.ConnectionWriter_appendBlock(self, data, len)

    def appendInt(self, data):
        r"""appendInt(ConnectionWriter self, int data)"""
        return _yarp.ConnectionWriter_appendInt(self, data)

    def appendInt8(self, data):
        r"""appendInt8(ConnectionWriter self, std::int8_t data)"""
        return _yarp.ConnectionWriter_appendInt8(self, data)

    def appendInt16(self, data):
        r"""appendInt16(ConnectionWriter self, std::int16_t data)"""
        return _yarp.ConnectionWriter_appendInt16(self, data)

    def appendInt32(self, data):
        r"""appendInt32(ConnectionWriter self, std::int32_t data)"""
        return _yarp.ConnectionWriter_appendInt32(self, data)

    def appendInt64(self, data):
        r"""appendInt64(ConnectionWriter self, std::int64_t data)"""
        return _yarp.ConnectionWriter_appendInt64(self, data)

    def appendDouble(self, data):
        r"""appendDouble(ConnectionWriter self, double data)"""
        return _yarp.ConnectionWriter_appendDouble(self, data)

    def appendFloat32(self, data):
        r"""appendFloat32(ConnectionWriter self, yarp::conf::float32_t data)"""
        return _yarp.ConnectionWriter_appendFloat32(self, data)

    def appendFloat64(self, data):
        r"""appendFloat64(ConnectionWriter self, yarp::conf::float64_t data)"""
        return _yarp.ConnectionWriter_appendFloat64(self, data)

    def appendText(self, *args):
        r"""appendText(ConnectionWriter self, std::string const & str, char const terminate='\n')"""
        return _yarp.ConnectionWriter_appendText(self, *args)

    def appendRawString(self, str):
        r"""appendRawString(ConnectionWriter self, std::string const & str)"""
        return _yarp.ConnectionWriter_appendRawString(self, str)

    def appendString(self, *args):
        r"""
        appendString(ConnectionWriter self, char const * str, char const terminate='\n')
        appendString(ConnectionWriter self, std::string const & str)
        """
        return _yarp.ConnectionWriter_appendString(self, *args)

    def appendExternalBlock(self, data, len):
        r"""appendExternalBlock(ConnectionWriter self, char const * data, size_t len)"""
        return _yarp.ConnectionWriter_appendExternalBlock(self, data, len)

    def isTextMode(self):
        r"""isTextMode(ConnectionWriter self) -> bool"""
        return _yarp.ConnectionWriter_isTextMode(self)

    def isBareMode(self):
        r"""isBareMode(ConnectionWriter self) -> bool"""
        return _yarp.ConnectionWriter_isBareMode(self)

    def declareSizes(self, argc, argv):
        r"""declareSizes(ConnectionWriter self, int argc, int * argv)"""
        return _yarp.ConnectionWriter_declareSizes(self, argc, argv)

    def setReplyHandler(self, reader):
        r"""setReplyHandler(ConnectionWriter self, PortReader reader)"""
        return _yarp.ConnectionWriter_setReplyHandler(self, reader)

    def setReference(self, obj):
        r"""setReference(ConnectionWriter self, Portable obj)"""
        return _yarp.ConnectionWriter_setReference(self, obj)

    def convertTextMode(self):
        r"""convertTextMode(ConnectionWriter self) -> bool"""
        return _yarp.ConnectionWriter_convertTextMode(self)

    def isValid(self):
        r"""isValid(ConnectionWriter self) -> bool"""
        return _yarp.ConnectionWriter_isValid(self)

    def isActive(self):
        r"""isActive(ConnectionWriter self) -> bool"""
        return _yarp.ConnectionWriter_isActive(self)

    def isError(self):
        r"""isError(ConnectionWriter self) -> bool"""
        return _yarp.ConnectionWriter_isError(self)

    def requestDrop(self):
        r"""requestDrop(ConnectionWriter self)"""
        return _yarp.ConnectionWriter_requestDrop(self)

    def isNull(self):
        r"""isNull(ConnectionWriter self) -> bool"""
        return _yarp.ConnectionWriter_isNull(self)

    def getBuffer(self, *args):
        r"""
        getBuffer(ConnectionWriter self) -> yarp::os::SizedWriter
        getBuffer(ConnectionWriter self) -> yarp::os::SizedWriter const *
        """
        return _yarp.ConnectionWriter_getBuffer(self, *args)

    @staticmethod
    def createBufferedConnectionWriter():
        r"""createBufferedConnectionWriter() -> ConnectionWriter"""
        return _yarp.ConnectionWriter_createBufferedConnectionWriter()

    @staticmethod
    def writeToStream(portable, os):
        r"""writeToStream(PortWriter portable, yarp::os::OutputStream & os) -> bool"""
        return _yarp.ConnectionWriter_writeToStream(portable, os)

# Register ConnectionWriter in _yarp:
_yarp.ConnectionWriter_swigregister(ConnectionWriter)

def ConnectionWriter_createBufferedConnectionWriter():
    r"""ConnectionWriter_createBufferedConnectionWriter() -> ConnectionWriter"""
    return _yarp.ConnectionWriter_createBufferedConnectionWriter()

def ConnectionWriter_writeToStream(portable, os):
    r"""ConnectionWriter_writeToStream(PortWriter portable, yarp::os::OutputStream & os) -> bool"""
    return _yarp.ConnectionWriter_writeToStream(portable, os)

class PortReader(object):
    r"""Proxy of C++ yarp::os::PortReader class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _yarp.delete_PortReader

    def read(self, reader):
        r"""read(PortReader self, ConnectionReader reader) -> bool"""
        return _yarp.PortReader_read(self, reader)

    def getReadType(self):
        r"""getReadType(PortReader self) -> yarp::os::Type"""
        return _yarp.PortReader_getReadType(self)

    def __init__(self):
        r"""__init__(PortReader self) -> PortReader"""
        if self.__class__ == PortReader:
            _self = None
        else:
            _self = self
        _yarp.PortReader_swiginit(self, _yarp.new_PortReader(_self, ))
    def __disown__(self):
        self.this.disown()
        _yarp.disown_PortReader(self)
        return weakref.proxy(self)

# Register PortReader in _yarp:
_yarp.PortReader_swigregister(PortReader)

class PortWriter(object):
    r"""Proxy of C++ yarp::os::PortWriter class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _yarp.delete_PortWriter

    def write(self, writer):
        r"""write(PortWriter self, ConnectionWriter writer) -> bool"""
        return _yarp.PortWriter_write(self, writer)

    def onCompletion(self):
        r"""onCompletion(PortWriter self)"""
        return _yarp.PortWriter_onCompletion(self)

    def onCommencement(self):
        r"""onCommencement(PortWriter self)"""
        return _yarp.PortWriter_onCommencement(self)

    def getWriteType(self):
        r"""getWriteType(PortWriter self) -> yarp::os::Type"""
        return _yarp.PortWriter_getWriteType(self)

# Register PortWriter in _yarp:
_yarp.PortWriter_swigregister(PortWriter)

class Portable(PortReader, PortWriter):
    r"""Proxy of C++ yarp::os::Portable class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def read(self, reader):
        r"""read(Portable self, ConnectionReader reader) -> bool"""
        return _yarp.Portable_read(self, reader)

    def write(self, writer):
        r"""write(Portable self, ConnectionWriter writer) -> bool"""
        return _yarp.Portable_write(self, writer)

    def getType(self):
        r"""getType(Portable self) -> yarp::os::Type"""
        return _yarp.Portable_getType(self)

    @staticmethod
    def copyPortable(writer, reader):
        r"""copyPortable(PortWriter writer, PortReader reader) -> bool"""
        return _yarp.Portable_copyPortable(writer, reader)
    __swig_destroy__ = _yarp.delete_Portable

# Register Portable in _yarp:
_yarp.Portable_swigregister(Portable)

def Portable_copyPortable(writer, reader):
    r"""Portable_copyPortable(PortWriter writer, PortReader reader) -> bool"""
    return _yarp.Portable_copyPortable(writer, reader)

class SearchReport(object):
    r"""Proxy of C++ yarp::os::SearchReport class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    key = property(_yarp.SearchReport_key_get, _yarp.SearchReport_key_set, doc=r"""key : std::string""")
    value = property(_yarp.SearchReport_value_get, _yarp.SearchReport_value_set, doc=r"""value : std::string""")
    isFound = property(_yarp.SearchReport_isFound_get, _yarp.SearchReport_isFound_set, doc=r"""isFound : bool""")
    isGroup = property(_yarp.SearchReport_isGroup_get, _yarp.SearchReport_isGroup_set, doc=r"""isGroup : bool""")
    isComment = property(_yarp.SearchReport_isComment_get, _yarp.SearchReport_isComment_set, doc=r"""isComment : bool""")
    isDefault = property(_yarp.SearchReport_isDefault_get, _yarp.SearchReport_isDefault_set, doc=r"""isDefault : bool""")

    def __init__(self):
        r"""__init__(SearchReport self) -> SearchReport"""
        _yarp.SearchReport_swiginit(self, _yarp.new_SearchReport())
    __swig_destroy__ = _yarp.delete_SearchReport

# Register SearchReport in _yarp:
_yarp.SearchReport_swigregister(SearchReport)

class SearchMonitor(object):
    r"""Proxy of C++ yarp::os::SearchMonitor class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _yarp.delete_SearchMonitor

    def report(self, report, context):
        r"""report(SearchMonitor self, SearchReport report, char const * context)"""
        return _yarp.SearchMonitor_report(self, report, context)

# Register SearchMonitor in _yarp:
_yarp.SearchMonitor_swigregister(SearchMonitor)

class Searchable(object):
    r"""Proxy of C++ yarp::os::Searchable class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _yarp.delete_Searchable

    def find(self, key):
        r"""find(Searchable self, std::string const & key) -> Value"""
        return _yarp.Searchable_find(self, key)

    def findGroup(self, *args):
        r"""
        findGroup(Searchable self, std::string const & key) -> Bottle
        findGroup(Searchable self, std::string const & key, std::string const & comment) -> Bottle
        """
        return _yarp.Searchable_findGroup(self, *args)

    def check(self, *args):
        r"""
        check(Searchable self, std::string const & key) -> bool
        check(Searchable self, std::string const & key, std::string const & comment) -> bool
        check(Searchable self, std::string const & key, Value fallback, std::string const & comment="") -> Value
        """
        return _yarp.Searchable_check(self, *args)

    def isNull(self):
        r"""isNull(Searchable self) -> bool"""
        return _yarp.Searchable_isNull(self)

    def toString_c(self):
        r"""toString_c(Searchable self) -> std::string"""
        return _yarp.Searchable_toString_c(self)

    def setMonitor(self, *args):
        r"""setMonitor(Searchable self, SearchMonitor monitor, char const * context="")"""
        return _yarp.Searchable_setMonitor(self, *args)

    def getMonitor(self):
        r"""getMonitor(Searchable self) -> SearchMonitor"""
        return _yarp.Searchable_getMonitor(self)

    def getMonitorContext(self):
        r"""getMonitorContext(Searchable self) -> std::string"""
        return _yarp.Searchable_getMonitorContext(self)

    def reportToMonitor(self, report):
        r"""reportToMonitor(Searchable self, SearchReport report)"""
        return _yarp.Searchable_reportToMonitor(self, report)

# Register Searchable in _yarp:
_yarp.Searchable_swigregister(Searchable)

class Value(Portable, Searchable):
    r"""Proxy of C++ yarp::os::Value class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        __init__(Value self) -> Value
        __init__(Value self, std::int32_t x, bool isVocab32=False) -> Value
        __init__(Value self, yarp::conf::float64_t x) -> Value
        __init__(Value self, std::string const & str, bool isVocab32=False) -> Value
        __init__(Value self, void * data, int length) -> Value
        __init__(Value self, Value alt) -> Value
        """
        _yarp.Value_swiginit(self, _yarp.new_Value(*args))
    __swig_destroy__ = _yarp.delete_Value

    def isBool(self):
        r"""isBool(Value self) -> bool"""
        return _yarp.Value_isBool(self)

    def isInt(self):
        r"""isInt(Value self) -> bool"""
        return _yarp.Value_isInt(self)

    def isInt8(self):
        r"""isInt8(Value self) -> bool"""
        return _yarp.Value_isInt8(self)

    def isInt16(self):
        r"""isInt16(Value self) -> bool"""
        return _yarp.Value_isInt16(self)

    def isInt32(self):
        r"""isInt32(Value self) -> bool"""
        return _yarp.Value_isInt32(self)

    def isInt64(self):
        r"""isInt64(Value self) -> bool"""
        return _yarp.Value_isInt64(self)

    def isDouble(self):
        r"""isDouble(Value self) -> bool"""
        return _yarp.Value_isDouble(self)

    def isFloat32(self):
        r"""isFloat32(Value self) -> bool"""
        return _yarp.Value_isFloat32(self)

    def isFloat64(self):
        r"""isFloat64(Value self) -> bool"""
        return _yarp.Value_isFloat64(self)

    def isString(self):
        r"""isString(Value self) -> bool"""
        return _yarp.Value_isString(self)

    def isList(self):
        r"""isList(Value self) -> bool"""
        return _yarp.Value_isList(self)

    def isDict(self):
        r"""isDict(Value self) -> bool"""
        return _yarp.Value_isDict(self)

    def isVocab32(self):
        r"""isVocab32(Value self) -> bool"""
        return _yarp.Value_isVocab32(self)

    def isVocab(self):
        r"""isVocab(Value self) -> bool"""
        return _yarp.Value_isVocab(self)

    def isBlob(self):
        r"""isBlob(Value self) -> bool"""
        return _yarp.Value_isBlob(self)

    def asBool(self):
        r"""asBool(Value self) -> bool"""
        return _yarp.Value_asBool(self)

    def asInt(self):
        r"""asInt(Value self) -> int"""
        return _yarp.Value_asInt(self)

    def asInt8(self):
        r"""asInt8(Value self) -> std::int8_t"""
        return _yarp.Value_asInt8(self)

    def asInt16(self):
        r"""asInt16(Value self) -> std::int16_t"""
        return _yarp.Value_asInt16(self)

    def asInt32(self):
        r"""asInt32(Value self) -> std::int32_t"""
        return _yarp.Value_asInt32(self)

    def asInt64(self):
        r"""asInt64(Value self) -> std::int64_t"""
        return _yarp.Value_asInt64(self)

    def asDouble(self):
        r"""asDouble(Value self) -> double"""
        return _yarp.Value_asDouble(self)

    def asFloat32(self):
        r"""asFloat32(Value self) -> yarp::conf::float32_t"""
        return _yarp.Value_asFloat32(self)

    def asFloat64(self):
        r"""asFloat64(Value self) -> yarp::conf::float64_t"""
        return _yarp.Value_asFloat64(self)

    def asVocab32(self):
        r"""asVocab32(Value self) -> yarp::conf::vocab32_t"""
        return _yarp.Value_asVocab32(self)

    def asVocab(self):
        r"""asVocab(Value self) -> yarp::conf::vocab32_t"""
        return _yarp.Value_asVocab(self)

    def asString(self):
        r"""asString(Value self) -> std::string"""
        return _yarp.Value_asString(self)

    def asList(self):
        r"""asList(Value self) -> Bottle"""
        return _yarp.Value_asList(self)

    def asDict(self):
        r"""asDict(Value self) -> Property"""
        return _yarp.Value_asDict(self)

    def asSearchable(self):
        r"""asSearchable(Value self) -> Searchable"""
        return _yarp.Value_asSearchable(self)

    def asBlob(self):
        r"""asBlob(Value self) -> char const *"""
        return _yarp.Value_asBlob(self)

    def asBlobLength(self):
        r"""asBlobLength(Value self) -> size_t"""
        return _yarp.Value_asBlobLength(self)

    def read(self, connection):
        r"""read(Value self, ConnectionReader connection) -> bool"""
        return _yarp.Value_read(self, connection)

    def write(self, connection):
        r"""write(Value self, ConnectionWriter connection) -> bool"""
        return _yarp.Value_write(self, connection)

    def check(self, *args):
        r"""
        check(Value self, std::string const & key, std::string const & comment) -> bool
        check(Value self, std::string const & key, Value fallback, std::string const & comment="") -> Value
        check(Value self, std::string const & key, Value fallback) -> Value
        check(Value self, std::string const & key) -> bool
        """
        return _yarp.Value_check(self, *args)

    def find(self, key):
        r"""find(Value self, std::string const & key) -> Value"""
        return _yarp.Value_find(self, key)

    def findGroup(self, *args):
        r"""
        findGroup(Value self, std::string const & key, std::string const & comment) -> Bottle
        findGroup(Value self, std::string const & key) -> Bottle
        """
        return _yarp.Value_findGroup(self, *args)

    def isEqual(self, alt):
        r"""isEqual(Value self, Value alt) -> bool"""
        return _yarp.Value_isEqual(self, alt)

    def notEqual(self, alt):
        r"""notEqual(Value self, Value alt) -> bool"""
        return _yarp.Value_notEqual(self, alt)

    def fromString(self, str):
        r"""fromString(Value self, char const * str)"""
        return _yarp.Value_fromString(self, str)

    def toString_c(self):
        r"""toString_c(Value self) -> std::string"""
        return _yarp.Value_toString_c(self)

    def create(self):
        r"""create(Value self) -> Value"""
        return _yarp.Value_create(self)

    def clone(self):
        r"""clone(Value self) -> Value"""
        return _yarp.Value_clone(self)

    def getCode(self):
        r"""getCode(Value self) -> std::int32_t"""
        return _yarp.Value_getCode(self)

    def isNull(self):
        r"""isNull(Value self) -> bool"""
        return _yarp.Value_isNull(self)

    def isLeaf(self):
        r"""isLeaf(Value self) -> bool"""
        return _yarp.Value_isLeaf(self)

    @staticmethod
    def makeInt(x):
        r"""makeInt(int x) -> Value"""
        return _yarp.Value_makeInt(x)

    @staticmethod
    def makeInt8(x):
        r"""makeInt8(std::int8_t x) -> Value"""
        return _yarp.Value_makeInt8(x)

    @staticmethod
    def makeInt16(x):
        r"""makeInt16(std::int16_t x) -> Value"""
        return _yarp.Value_makeInt16(x)

    @staticmethod
    def makeInt32(x):
        r"""makeInt32(std::int32_t x) -> Value"""
        return _yarp.Value_makeInt32(x)

    @staticmethod
    def makeInt64(x):
        r"""makeInt64(std::int64_t x) -> Value"""
        return _yarp.Value_makeInt64(x)

    @staticmethod
    def makeDouble(x):
        r"""makeDouble(double x) -> Value"""
        return _yarp.Value_makeDouble(x)

    @staticmethod
    def makeFloat32(x):
        r"""makeFloat32(yarp::conf::float32_t x) -> Value"""
        return _yarp.Value_makeFloat32(x)

    @staticmethod
    def makeFloat64(x):
        r"""makeFloat64(yarp::conf::float64_t x) -> Value"""
        return _yarp.Value_makeFloat64(x)

    @staticmethod
    def makeString(str):
        r"""makeString(std::string const & str) -> Value"""
        return _yarp.Value_makeString(str)

    @staticmethod
    def makeVocab32(*args):
        r"""
        makeVocab32(yarp::conf::vocab32_t v) -> Value
        makeVocab32(char a, char b=0, char c=0, char d=0) -> Value
        makeVocab32(std::string const & str) -> Value
        """
        return _yarp.Value_makeVocab32(*args)

    @staticmethod
    def makeVocab(*args):
        r"""
        makeVocab(yarp::conf::vocab32_t v) -> Value
        makeVocab(std::string const & str) -> Value
        """
        return _yarp.Value_makeVocab(*args)

    @staticmethod
    def makeBlob(data, length):
        r"""makeBlob(void * data, int length) -> Value"""
        return _yarp.Value_makeBlob(data, length)

    @staticmethod
    def makeList(*args):
        r"""
        makeList() -> Value
        makeList(char const * txt) -> Value
        """
        return _yarp.Value_makeList(*args)

    @staticmethod
    def makeValue(txt):
        r"""makeValue(std::string const & txt) -> Value"""
        return _yarp.Value_makeValue(txt)

    @staticmethod
    def getNullValue():
        r"""getNullValue() -> Value"""
        return _yarp.Value_getNullValue()

    def toString(self):
        r"""toString(Value self) -> std::string"""
        return _yarp.Value_toString(self)

# Register Value in _yarp:
_yarp.Value_swigregister(Value)

def Value_makeInt(x):
    r"""Value_makeInt(int x) -> Value"""
    return _yarp.Value_makeInt(x)

def Value_makeInt8(x):
    r"""Value_makeInt8(std::int8_t x) -> Value"""
    return _yarp.Value_makeInt8(x)

def Value_makeInt16(x):
    r"""Value_makeInt16(std::int16_t x) -> Value"""
    return _yarp.Value_makeInt16(x)

def Value_makeInt32(x):
    r"""Value_makeInt32(std::int32_t x) -> Value"""
    return _yarp.Value_makeInt32(x)

def Value_makeInt64(x):
    r"""Value_makeInt64(std::int64_t x) -> Value"""
    return _yarp.Value_makeInt64(x)

def Value_makeDouble(x):
    r"""Value_makeDouble(double x) -> Value"""
    return _yarp.Value_makeDouble(x)

def Value_makeFloat32(x):
    r"""Value_makeFloat32(yarp::conf::float32_t x) -> Value"""
    return _yarp.Value_makeFloat32(x)

def Value_makeFloat64(x):
    r"""Value_makeFloat64(yarp::conf::float64_t x) -> Value"""
    return _yarp.Value_makeFloat64(x)

def Value_makeString(str):
    r"""Value_makeString(std::string const & str) -> Value"""
    return _yarp.Value_makeString(str)

def Value_makeVocab32(*args):
    r"""
    Value_makeVocab32(yarp::conf::vocab32_t v) -> Value
    Value_makeVocab32(char a, char b=0, char c=0, char d=0) -> Value
    Value_makeVocab32(std::string const & str) -> Value
    """
    return _yarp.Value_makeVocab32(*args)

def Value_makeVocab(*args):
    r"""
    Value_makeVocab(yarp::conf::vocab32_t v) -> Value
    Value_makeVocab(std::string const & str) -> Value
    """
    return _yarp.Value_makeVocab(*args)

def Value_makeBlob(data, length):
    r"""Value_makeBlob(void * data, int length) -> Value"""
    return _yarp.Value_makeBlob(data, length)

def Value_makeList(*args):
    r"""
    Value_makeList() -> Value
    Value_makeList(char const * txt) -> Value
    """
    return _yarp.Value_makeList(*args)

def Value_makeValue(txt):
    r"""Value_makeValue(std::string const & txt) -> Value"""
    return _yarp.Value_makeValue(txt)

def Value_getNullValue():
    r"""Value_getNullValue() -> Value"""
    return _yarp.Value_getNullValue()


def createVocab32(a, b=0, c=0, d=0):
    r"""createVocab32(char a, char b=0, char c=0, char d=0) -> yarp::conf::vocab32_t"""
    return _yarp.createVocab32(a, b, c, d)

def createVocab(a, b=0, c=0, d=0):
    r"""createVocab(char a, char b=0, char c=0, char d=0) -> yarp::conf::vocab32_t"""
    return _yarp.createVocab(a, b, c, d)

def encode(str):
    r"""encode(std::string const & str) -> yarp::os::NetInt32"""
    return _yarp.encode(str)

def decode(code):
    r"""decode(yarp::os::NetInt32 code) -> std::string"""
    return _yarp.decode(code)

def VOCAB(a, b, c, d):
    r"""VOCAB(char a, char b, char c, char d) -> int32_t"""
    return _yarp.VOCAB(a, b, c, d)

def VOCAB4(a, b, c, d):
    r"""VOCAB4(char a, char b, char c, char d) -> int32_t"""
    return _yarp.VOCAB4(a, b, c, d)

def VOCAB3(a, b, c):
    r"""VOCAB3(char a, char b, char c) -> int32_t"""
    return _yarp.VOCAB3(a, b, c)

def VOCAB2(a, b):
    r"""VOCAB2(char a, char b) -> int32_t"""
    return _yarp.VOCAB2(a, b)

def VOCAB1(a):
    r"""VOCAB1(char a) -> int32_t"""
    return _yarp.VOCAB1(a)
class Contactable(object):
    r"""Proxy of C++ yarp::os::Contactable class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _yarp.delete_Contactable

    def open(self, *args):
        r"""
        open(Contactable self, std::string const & name) -> bool
        open(Contactable self, Contact contact, bool registerName=True) -> bool
        """
        return _yarp.Contactable_open(self, *args)

    def addOutput(self, *args):
        r"""
        addOutput(Contactable self, std::string const & name) -> bool
        addOutput(Contactable self, std::string const & name, std::string const & carrier) -> bool
        addOutput(Contactable self, Contact contact) -> bool
        """
        return _yarp.Contactable_addOutput(self, *args)

    def close(self):
        r"""close(Contactable self)"""
        return _yarp.Contactable_close(self)

    def interrupt(self):
        r"""interrupt(Contactable self)"""
        return _yarp.Contactable_interrupt(self)

    def resume(self):
        r"""resume(Contactable self)"""
        return _yarp.Contactable_resume(self)

    def where(self):
        r"""where(Contactable self) -> Contact"""
        return _yarp.Contactable_where(self)

    def getName(self):
        r"""getName(Contactable self) -> std::string"""
        return _yarp.Contactable_getName(self)

    def getEnvelope(self, envelope):
        r"""getEnvelope(Contactable self, PortReader envelope) -> bool"""
        return _yarp.Contactable_getEnvelope(self, envelope)

    def getInputCount(self):
        r"""getInputCount(Contactable self) -> int"""
        return _yarp.Contactable_getInputCount(self)

    def getOutputCount(self):
        r"""getOutputCount(Contactable self) -> int"""
        return _yarp.Contactable_getOutputCount(self)

    def getReport(self, reporter):
        r"""getReport(Contactable self, PortReport reporter)"""
        return _yarp.Contactable_getReport(self, reporter)

    def setReporter(self, reporter):
        r"""setReporter(Contactable self, PortReport reporter)"""
        return _yarp.Contactable_setReporter(self, reporter)

    def resetReporter(self):
        r"""resetReporter(Contactable self)"""
        return _yarp.Contactable_resetReporter(self)

    def isWriting(self):
        r"""isWriting(Contactable self) -> bool"""
        return _yarp.Contactable_isWriting(self)

    def setReader(self, reader):
        r"""setReader(Contactable self, PortReader reader)"""
        return _yarp.Contactable_setReader(self, reader)

    def setAdminReader(self, reader):
        r"""setAdminReader(Contactable self, PortReader reader)"""
        return _yarp.Contactable_setAdminReader(self, reader)

    def setInputMode(self, expectInput):
        r"""setInputMode(Contactable self, bool expectInput)"""
        return _yarp.Contactable_setInputMode(self, expectInput)

    def setOutputMode(self, expectOutput):
        r"""setOutputMode(Contactable self, bool expectOutput)"""
        return _yarp.Contactable_setOutputMode(self, expectOutput)

    def setRpcMode(self, expectRpc):
        r"""setRpcMode(Contactable self, bool expectRpc)"""
        return _yarp.Contactable_setRpcMode(self, expectRpc)

    def getType(self):
        r"""getType(Contactable self) -> yarp::os::Type"""
        return _yarp.Contactable_getType(self)

    def promiseType(self, typ):
        r"""promiseType(Contactable self, yarp::os::Type const & typ)"""
        return _yarp.Contactable_promiseType(self, typ)

    def acquireProperties(self, readOnly):
        r"""acquireProperties(Contactable self, bool readOnly) -> Property"""
        return _yarp.Contactable_acquireProperties(self, readOnly)

    def releaseProperties(self, prop):
        r"""releaseProperties(Contactable self, Property prop)"""
        return _yarp.Contactable_releaseProperties(self, prop)

    def includeNodeInName(self, flag):
        r"""includeNodeInName(Contactable self, bool flag)"""
        return _yarp.Contactable_includeNodeInName(self, flag)

    def setReadOnly(self):
        r"""setReadOnly(Contactable self)"""
        return _yarp.Contactable_setReadOnly(self)

    def setWriteOnly(self):
        r"""setWriteOnly(Contactable self)"""
        return _yarp.Contactable_setWriteOnly(self)

    def setRpcServer(self):
        r"""setRpcServer(Contactable self)"""
        return _yarp.Contactable_setRpcServer(self)

    def setRpcClient(self):
        r"""setRpcClient(Contactable self)"""
        return _yarp.Contactable_setRpcClient(self)

    def setCallbackLock(self, *args):
        r"""
        setCallbackLock(Contactable self, yarp::os::Mutex * mutex) -> bool
        setCallbackLock(Contactable self, std::mutex * mutex=None) -> bool
        """
        return _yarp.Contactable_setCallbackLock(self, *args)

    def removeCallbackLock(self):
        r"""removeCallbackLock(Contactable self) -> bool"""
        return _yarp.Contactable_removeCallbackLock(self)

    def lockCallback(self):
        r"""lockCallback(Contactable self) -> bool"""
        return _yarp.Contactable_lockCallback(self)

    def tryLockCallback(self):
        r"""tryLockCallback(Contactable self) -> bool"""
        return _yarp.Contactable_tryLockCallback(self)

    def unlockCallback(self):
        r"""unlockCallback(Contactable self)"""
        return _yarp.Contactable_unlockCallback(self)

    def setEnvelope(self, *args):
        r"""
        setEnvelope(Contactable self, PortWriter envelope) -> bool
        setEnvelope(Contactable self, Portable data) -> bool
        """
        return _yarp.Contactable_setEnvelope(self, *args)

# Register Contactable in _yarp:
_yarp.Contactable_swigregister(Contactable)

class UnbufferedContactable(Contactable):
    r"""Proxy of C++ yarp::os::UnbufferedContactable class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def write(self, *args):
        r"""
        write(UnbufferedContactable self, PortWriter writer, PortWriter callback=None) -> bool
        write(UnbufferedContactable self, PortWriter writer, PortReader reader, PortWriter callback=None) -> bool
        """
        return _yarp.UnbufferedContactable_write(self, *args)

    def read(self, reader, willReply=False):
        r"""read(UnbufferedContactable self, PortReader reader, bool willReply=False) -> bool"""
        return _yarp.UnbufferedContactable_read(self, reader, willReply)

    def reply(self, writer):
        r"""reply(UnbufferedContactable self, PortWriter writer) -> bool"""
        return _yarp.UnbufferedContactable_reply(self, writer)

    def replyAndDrop(self, writer):
        r"""replyAndDrop(UnbufferedContactable self, PortWriter writer) -> bool"""
        return _yarp.UnbufferedContactable_replyAndDrop(self, writer)
    __swig_destroy__ = _yarp.delete_UnbufferedContactable

# Register UnbufferedContactable in _yarp:
_yarp.UnbufferedContactable_swigregister(UnbufferedContactable)

class Port(UnbufferedContactable):
    r"""Proxy of C++ yarp::os::Port class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        r"""__init__(Port self) -> Port"""
        _yarp.Port_swiginit(self, _yarp.new_Port())
    __swig_destroy__ = _yarp.delete_Port

    def sharedOpen(self, port):
        r"""sharedOpen(Port self, Port port) -> bool"""
        return _yarp.Port_sharedOpen(self, port)

    def openFake(self, name):
        r"""openFake(Port self, std::string const & name) -> bool"""
        return _yarp.Port_openFake(self, name)

    def addOutput(self, *args):
        r"""
        addOutput(Port self, std::string const & name) -> bool
        addOutput(Port self, std::string const & name, std::string const & carrier) -> bool
        addOutput(Port self, Contact contact) -> bool
        """
        return _yarp.Port_addOutput(self, *args)

    def close(self):
        r"""close(Port self)"""
        return _yarp.Port_close(self)

    def interrupt(self):
        r"""interrupt(Port self)"""
        return _yarp.Port_interrupt(self)

    def resume(self):
        r"""resume(Port self)"""
        return _yarp.Port_resume(self)

    def where(self):
        r"""where(Port self) -> Contact"""
        return _yarp.Port_where(self)

    def read(self, reader, willReply=False):
        r"""read(Port self, PortReader reader, bool willReply=False) -> bool"""
        return _yarp.Port_read(self, reader, willReply)

    def replyAndDrop(self, writer):
        r"""replyAndDrop(Port self, PortWriter writer) -> bool"""
        return _yarp.Port_replyAndDrop(self, writer)

    def setReader(self, reader):
        r"""setReader(Port self, PortReader reader)"""
        return _yarp.Port_setReader(self, reader)

    def setAdminReader(self, reader):
        r"""setAdminReader(Port self, PortReader reader)"""
        return _yarp.Port_setAdminReader(self, reader)

    def setReaderCreator(self, creator):
        r"""setReaderCreator(Port self, PortReaderCreator & creator)"""
        return _yarp.Port_setReaderCreator(self, creator)

    def enableBackgroundWrite(self, backgroundFlag):
        r"""enableBackgroundWrite(Port self, bool backgroundFlag)"""
        return _yarp.Port_enableBackgroundWrite(self, backgroundFlag)

    def isWriting(self):
        r"""isWriting(Port self) -> bool"""
        return _yarp.Port_isWriting(self)

    def setEnvelope(self, envelope):
        r"""setEnvelope(Port self, PortWriter envelope) -> bool"""
        return _yarp.Port_setEnvelope(self, envelope)

    def getEnvelope(self, envelope):
        r"""getEnvelope(Port self, PortReader envelope) -> bool"""
        return _yarp.Port_getEnvelope(self, envelope)

    def getInputCount(self):
        r"""getInputCount(Port self) -> int"""
        return _yarp.Port_getInputCount(self)

    def getOutputCount(self):
        r"""getOutputCount(Port self) -> int"""
        return _yarp.Port_getOutputCount(self)

    def getReport(self, reporter):
        r"""getReport(Port self, PortReport reporter)"""
        return _yarp.Port_getReport(self, reporter)

    def setReporter(self, reporter):
        r"""setReporter(Port self, PortReport reporter)"""
        return _yarp.Port_setReporter(self, reporter)

    def resetReporter(self):
        r"""resetReporter(Port self)"""
        return _yarp.Port_resetReporter(self)

    def setAdminMode(self, adminMode=True):
        r"""setAdminMode(Port self, bool adminMode=True)"""
        return _yarp.Port_setAdminMode(self, adminMode)

    def setInputMode(self, expectInput):
        r"""setInputMode(Port self, bool expectInput)"""
        return _yarp.Port_setInputMode(self, expectInput)

    def setOutputMode(self, expectOutput):
        r"""setOutputMode(Port self, bool expectOutput)"""
        return _yarp.Port_setOutputMode(self, expectOutput)

    def setRpcMode(self, expectRpc):
        r"""setRpcMode(Port self, bool expectRpc)"""
        return _yarp.Port_setRpcMode(self, expectRpc)

    def setTimeout(self, timeout):
        r"""setTimeout(Port self, float timeout) -> bool"""
        return _yarp.Port_setTimeout(self, timeout)

    def setVerbosity(self, level):
        r"""setVerbosity(Port self, int level)"""
        return _yarp.Port_setVerbosity(self, level)

    def getVerbosity(self):
        r"""getVerbosity(Port self) -> int"""
        return _yarp.Port_getVerbosity(self)

    def getType(self):
        r"""getType(Port self) -> yarp::os::Type"""
        return _yarp.Port_getType(self)

    def promiseType(self, typ):
        r"""promiseType(Port self, yarp::os::Type const & typ)"""
        return _yarp.Port_promiseType(self, typ)

    def acquireProperties(self, readOnly):
        r"""acquireProperties(Port self, bool readOnly) -> Property"""
        return _yarp.Port_acquireProperties(self, readOnly)

    def releaseProperties(self, prop):
        r"""releaseProperties(Port self, Property prop)"""
        return _yarp.Port_releaseProperties(self, prop)

    def includeNodeInName(self, flag):
        r"""includeNodeInName(Port self, bool flag)"""
        return _yarp.Port_includeNodeInName(self, flag)

    def isOpen(self):
        r"""isOpen(Port self) -> bool"""
        return _yarp.Port_isOpen(self)

    def setCallbackLock(self, *args):
        r"""
        setCallbackLock(Port self, yarp::os::Mutex * mutex) -> bool
        setCallbackLock(Port self, std::mutex * mutex=None) -> bool
        """
        return _yarp.Port_setCallbackLock(self, *args)

    def removeCallbackLock(self):
        r"""removeCallbackLock(Port self) -> bool"""
        return _yarp.Port_removeCallbackLock(self)

    def lockCallback(self):
        r"""lockCallback(Port self) -> bool"""
        return _yarp.Port_lockCallback(self)

    def tryLockCallback(self):
        r"""tryLockCallback(Port self) -> bool"""
        return _yarp.Port_tryLockCallback(self)

    def unlockCallback(self):
        r"""unlockCallback(Port self)"""
        return _yarp.Port_unlockCallback(self)

    def write(self, *args):
        r"""
        write(Port self, PortWriter writer, PortWriter callback=None) -> bool
        write(Port self, PortWriter writer, PortReader reader, PortWriter callback=None) -> bool
        write(Port self, Bottle data) -> bool
        write(Port self, Property data) -> bool
        write(Port self, ImageRgb data) -> bool
        write(Port self, ImageFloat data) -> bool
        write(Port self, Bottle data1, Bottle data2) -> bool
        write(Port self, Bottle data1, ImageFloat data2) -> bool
        """
        return _yarp.Port_write(self, *args)

    def reply(self, *args):
        r"""
        reply(Port self, PortWriter writer) -> bool
        reply(Port self, Bottle data) -> bool
        """
        return _yarp.Port_reply(self, *args)

# Register Port in _yarp:
_yarp.Port_swigregister(Port)

class AbstractContactable(UnbufferedContactable):
    r"""Proxy of C++ yarp::os::AbstractContactable class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def asPort(self, *args):
        r"""
        asPort(AbstractContactable self) -> Port
        asPort(AbstractContactable self) -> Port
        """
        return _yarp.AbstractContactable_asPort(self, *args)

    def open(self, *args):
        r"""
        open(AbstractContactable self, std::string const & name) -> bool
        open(AbstractContactable self, Contact contact, bool registerName=True) -> bool
        """
        return _yarp.AbstractContactable_open(self, *args)

    def addOutput(self, *args):
        r"""
        addOutput(AbstractContactable self, std::string const & name) -> bool
        addOutput(AbstractContactable self, std::string const & name, std::string const & carrier) -> bool
        addOutput(AbstractContactable self, Contact contact) -> bool
        """
        return _yarp.AbstractContactable_addOutput(self, *args)

    def close(self):
        r"""close(AbstractContactable self)"""
        return _yarp.AbstractContactable_close(self)

    def interrupt(self):
        r"""interrupt(AbstractContactable self)"""
        return _yarp.AbstractContactable_interrupt(self)

    def resume(self):
        r"""resume(AbstractContactable self)"""
        return _yarp.AbstractContactable_resume(self)

    def where(self):
        r"""where(AbstractContactable self) -> Contact"""
        return _yarp.AbstractContactable_where(self)

    def getName(self):
        r"""getName(AbstractContactable self) -> std::string"""
        return _yarp.AbstractContactable_getName(self)

    def setEnvelope(self, envelope):
        r"""setEnvelope(AbstractContactable self, PortWriter envelope) -> bool"""
        return _yarp.AbstractContactable_setEnvelope(self, envelope)

    def getEnvelope(self, envelope):
        r"""getEnvelope(AbstractContactable self, PortReader envelope) -> bool"""
        return _yarp.AbstractContactable_getEnvelope(self, envelope)

    def getInputCount(self):
        r"""getInputCount(AbstractContactable self) -> int"""
        return _yarp.AbstractContactable_getInputCount(self)

    def getOutputCount(self):
        r"""getOutputCount(AbstractContactable self) -> int"""
        return _yarp.AbstractContactable_getOutputCount(self)

    def getReport(self, reporter):
        r"""getReport(AbstractContactable self, PortReport reporter)"""
        return _yarp.AbstractContactable_getReport(self, reporter)

    def setReporter(self, reporter):
        r"""setReporter(AbstractContactable self, PortReport reporter)"""
        return _yarp.AbstractContactable_setReporter(self, reporter)

    def resetReporter(self):
        r"""resetReporter(AbstractContactable self)"""
        return _yarp.AbstractContactable_resetReporter(self)

    def isWriting(self):
        r"""isWriting(AbstractContactable self) -> bool"""
        return _yarp.AbstractContactable_isWriting(self)

    def setReader(self, reader):
        r"""setReader(AbstractContactable self, PortReader reader)"""
        return _yarp.AbstractContactable_setReader(self, reader)

    def setAdminReader(self, reader):
        r"""setAdminReader(AbstractContactable self, PortReader reader)"""
        return _yarp.AbstractContactable_setAdminReader(self, reader)

    def setInputMode(self, expectInput):
        r"""setInputMode(AbstractContactable self, bool expectInput)"""
        return _yarp.AbstractContactable_setInputMode(self, expectInput)

    def setOutputMode(self, expectOutput):
        r"""setOutputMode(AbstractContactable self, bool expectOutput)"""
        return _yarp.AbstractContactable_setOutputMode(self, expectOutput)

    def setRpcMode(self, expectRpc):
        r"""setRpcMode(AbstractContactable self, bool expectRpc)"""
        return _yarp.AbstractContactable_setRpcMode(self, expectRpc)

    def getType(self):
        r"""getType(AbstractContactable self) -> yarp::os::Type"""
        return _yarp.AbstractContactable_getType(self)

    def promiseType(self, typ):
        r"""promiseType(AbstractContactable self, yarp::os::Type const & typ)"""
        return _yarp.AbstractContactable_promiseType(self, typ)

    def acquireProperties(self, readOnly):
        r"""acquireProperties(AbstractContactable self, bool readOnly) -> Property"""
        return _yarp.AbstractContactable_acquireProperties(self, readOnly)

    def releaseProperties(self, prop):
        r"""releaseProperties(AbstractContactable self, Property prop)"""
        return _yarp.AbstractContactable_releaseProperties(self, prop)

    def write(self, *args):
        r"""
        write(AbstractContactable self, PortWriter writer, PortWriter callback=None) -> bool
        write(AbstractContactable self, PortWriter writer, PortReader reader, PortWriter callback=None) -> bool
        """
        return _yarp.AbstractContactable_write(self, *args)

    def read(self, reader, willReply=False):
        r"""read(AbstractContactable self, PortReader reader, bool willReply=False) -> bool"""
        return _yarp.AbstractContactable_read(self, reader, willReply)

    def reply(self, writer):
        r"""reply(AbstractContactable self, PortWriter writer) -> bool"""
        return _yarp.AbstractContactable_reply(self, writer)

    def replyAndDrop(self, writer):
        r"""replyAndDrop(AbstractContactable self, PortWriter writer) -> bool"""
        return _yarp.AbstractContactable_replyAndDrop(self, writer)

    def includeNodeInName(self, flag):
        r"""includeNodeInName(AbstractContactable self, bool flag)"""
        return _yarp.AbstractContactable_includeNodeInName(self, flag)

    def setCallbackLock(self, *args):
        r"""
        setCallbackLock(AbstractContactable self, yarp::os::Mutex * mutex) -> bool
        setCallbackLock(AbstractContactable self, std::mutex * mutex=None) -> bool
        """
        return _yarp.AbstractContactable_setCallbackLock(self, *args)

    def removeCallbackLock(self):
        r"""removeCallbackLock(AbstractContactable self) -> bool"""
        return _yarp.AbstractContactable_removeCallbackLock(self)

    def lockCallback(self):
        r"""lockCallback(AbstractContactable self) -> bool"""
        return _yarp.AbstractContactable_lockCallback(self)

    def tryLockCallback(self):
        r"""tryLockCallback(AbstractContactable self) -> bool"""
        return _yarp.AbstractContactable_tryLockCallback(self)

    def unlockCallback(self):
        r"""unlockCallback(AbstractContactable self)"""
        return _yarp.AbstractContactable_unlockCallback(self)
    __swig_destroy__ = _yarp.delete_AbstractContactable

# Register AbstractContactable in _yarp:
_yarp.AbstractContactable_swigregister(AbstractContactable)

class NetworkBase(object):
    r"""Proxy of C++ yarp::os::NetworkBase class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def initMinimum(*args):
        r"""
        initMinimum()
        initMinimum(yarp::os::yarpClockType clockType, yarp::os::Clock * custom=None)
        """
        return _yarp.NetworkBase_initMinimum(*args)

    @staticmethod
    def autoInitMinimum(*args):
        r"""
        autoInitMinimum()
        autoInitMinimum(yarp::os::yarpClockType clockType, yarp::os::Clock * custom=None)
        """
        return _yarp.NetworkBase_autoInitMinimum(*args)

    @staticmethod
    def yarpClockInit(clockType, custom=None):
        r"""yarpClockInit(yarp::os::yarpClockType clockType, Clock * custom=None)"""
        return _yarp.NetworkBase_yarpClockInit(clockType, custom)

    @staticmethod
    def finiMinimum():
        r"""finiMinimum()"""
        return _yarp.NetworkBase_finiMinimum()

    @staticmethod
    def isNetworkInitialized():
        r"""isNetworkInitialized() -> bool"""
        return _yarp.NetworkBase_isNetworkInitialized()

    @staticmethod
    def connect(*args):
        r"""
        connect(std::string const & src, std::string const & dest, std::string const & carrier="", bool quiet=True) -> bool
        connect(char const * src, char const * dest, char const * carrier, bool quiet=True) -> bool
        connect(std::string const & src, std::string const & dest, ContactStyle style) -> bool
        """
        return _yarp.NetworkBase_connect(*args)

    @staticmethod
    def disconnect(*args):
        r"""
        disconnect(std::string const & src, std::string const & dest, bool quiet) -> bool
        disconnect(std::string const & src, std::string const & dest, ContactStyle style) -> bool
        disconnect(std::string const & src, std::string const & dest, std::string const & carrier="", bool quiet=True) -> bool
        disconnect(char const * src, char const * dest, char const * carrier, bool quiet=True) -> bool
        """
        return _yarp.NetworkBase_disconnect(*args)

    @staticmethod
    def isConnected(*args):
        r"""
        isConnected(std::string const & src, std::string const & dest, bool quiet) -> bool
        isConnected(std::string const & src, std::string const & dest, ContactStyle style) -> bool
        isConnected(std::string const & src, std::string const & dest, std::string const & carrier="", bool quiet=True) -> bool
        isConnected(char const * src, char const * dest, char const * carrier, bool quiet=True) -> bool
        """
        return _yarp.NetworkBase_isConnected(*args)

    @staticmethod
    def exists(*args):
        r"""
        exists(std::string const & port, bool quiet=True, bool checkVer=True) -> bool
        exists(std::string const & port, ContactStyle style, bool checkVer=True) -> bool
        """
        return _yarp.NetworkBase_exists(*args)

    @staticmethod
    def sync(port, quiet=True):
        r"""sync(std::string const & port, bool quiet=True) -> bool"""
        return _yarp.NetworkBase_sync(port, quiet)

    @staticmethod
    def assertion(shouldBeTrue):
        r"""assertion(bool shouldBeTrue)"""
        return _yarp.NetworkBase_assertion(shouldBeTrue)

    @staticmethod
    def queryName(name):
        r"""queryName(std::string const & name) -> Contact"""
        return _yarp.NetworkBase_queryName(name)

    @staticmethod
    def registerName(name):
        r"""registerName(std::string const & name) -> Contact"""
        return _yarp.NetworkBase_registerName(name)

    @staticmethod
    def registerContact(contact):
        r"""registerContact(Contact contact) -> Contact"""
        return _yarp.NetworkBase_registerContact(contact)

    @staticmethod
    def unregisterName(name):
        r"""unregisterName(std::string const & name) -> Contact"""
        return _yarp.NetworkBase_unregisterName(name)

    @staticmethod
    def unregisterContact(contact):
        r"""unregisterContact(Contact contact) -> Contact"""
        return _yarp.NetworkBase_unregisterContact(contact)

    @staticmethod
    def setProperty(name, key, value):
        r"""setProperty(char const * name, char const * key, Value value) -> bool"""
        return _yarp.NetworkBase_setProperty(name, key, value)

    @staticmethod
    def getProperty(name, key):
        r"""getProperty(char const * name, char const * key) -> Value"""
        return _yarp.NetworkBase_getProperty(name, key)

    @staticmethod
    def getNameServerName():
        r"""getNameServerName() -> std::string"""
        return _yarp.NetworkBase_getNameServerName()

    @staticmethod
    def getNameServerContact():
        r"""getNameServerContact() -> Contact"""
        return _yarp.NetworkBase_getNameServerContact()

    @staticmethod
    def setNameServerName(name):
        r"""setNameServerName(std::string const & name) -> bool"""
        return _yarp.NetworkBase_setNameServerName(name)

    @staticmethod
    def setLocalMode(flag):
        r"""setLocalMode(bool flag) -> bool"""
        return _yarp.NetworkBase_setLocalMode(flag)

    @staticmethod
    def getLocalMode():
        r"""getLocalMode() -> bool"""
        return _yarp.NetworkBase_getLocalMode()

    @staticmethod
    def readString(eof=None):
        r"""readString(bool * eof=None) -> std::string"""
        return _yarp.NetworkBase_readString(eof)

    @staticmethod
    def writeToNameServer(cmd, reply, style):
        r"""writeToNameServer(PortWriter cmd, PortReader reply, ContactStyle style) -> bool"""
        return _yarp.NetworkBase_writeToNameServer(cmd, reply, style)

    @staticmethod
    def write(*args):
        r"""
        write(Contact contact, PortWriter cmd, PortReader reply, bool admin=False, bool quiet=False, double timeout=-1) -> bool
        write(Contact contact, PortWriter cmd, PortReader reply, ContactStyle style) -> bool
        write(std::string const & port_name, PortWriter cmd, PortReader reply) -> bool
        """
        return _yarp.NetworkBase_write(*args)

    @staticmethod
    def checkNetwork(*args):
        r"""
        checkNetwork() -> bool
        checkNetwork(double timeout) -> bool
        """
        return _yarp.NetworkBase_checkNetwork(*args)

    @staticmethod
    def initialized():
        r"""initialized() -> bool"""
        return _yarp.NetworkBase_initialized()

    @staticmethod
    def setVerbosity(verbosity):
        r"""setVerbosity(int verbosity)"""
        return _yarp.NetworkBase_setVerbosity(verbosity)

    @staticmethod
    def queryBypass(store):
        r"""queryBypass(NameStore * store)"""
        return _yarp.NetworkBase_queryBypass(store)

    @staticmethod
    def getQueryBypass():
        r"""getQueryBypass() -> NameStore *"""
        return _yarp.NetworkBase_getQueryBypass()

    @staticmethod
    def getEnvironment(key, found=None):
        r"""getEnvironment(char const * key, bool * found=None) -> std::string"""
        return _yarp.NetworkBase_getEnvironment(key, found)

    @staticmethod
    def setEnvironment(key, val):
        r"""setEnvironment(std::string const & key, std::string const & val)"""
        return _yarp.NetworkBase_setEnvironment(key, val)

    @staticmethod
    def unsetEnvironment(key):
        r"""unsetEnvironment(std::string const & key)"""
        return _yarp.NetworkBase_unsetEnvironment(key)

    @staticmethod
    def getDirectorySeparator():
        r"""getDirectorySeparator() -> std::string"""
        return _yarp.NetworkBase_getDirectorySeparator()

    @staticmethod
    def getPathSeparator():
        r"""getPathSeparator() -> std::string"""
        return _yarp.NetworkBase_getPathSeparator()

    @staticmethod
    def registerCarrier(name, dll):
        r"""registerCarrier(char const * name, char const * dll) -> bool"""
        return _yarp.NetworkBase_registerCarrier(name, dll)

    @staticmethod
    def lock():
        r"""lock()"""
        return _yarp.NetworkBase_lock()

    @staticmethod
    def unlock():
        r"""unlock()"""
        return _yarp.NetworkBase_unlock()

    @staticmethod
    def localNetworkAllocation():
        r"""localNetworkAllocation() -> bool"""
        return _yarp.NetworkBase_localNetworkAllocation()

    @staticmethod
    def detectNameServer(useDetectedServer, scanNeeded, serverUsed):
        r"""detectNameServer(bool useDetectedServer, bool & scanNeeded, bool & serverUsed) -> Contact"""
        return _yarp.NetworkBase_detectNameServer(useDetectedServer, scanNeeded, serverUsed)

    @staticmethod
    def setNameServerContact(nameServerContact):
        r"""setNameServerContact(Contact nameServerContact) -> bool"""
        return _yarp.NetworkBase_setNameServerContact(nameServerContact)

    @staticmethod
    def getConfigFile(fname):
        r"""getConfigFile(char const * fname) -> std::string"""
        return _yarp.NetworkBase_getConfigFile(fname)

    @staticmethod
    def getDefaultPortRange():
        r"""getDefaultPortRange() -> int"""
        return _yarp.NetworkBase_getDefaultPortRange()

    @staticmethod
    def setConnectionQos(*args):
        r"""
        setConnectionQos(std::string const & src, std::string const & dest, QosStyle srcStyle, QosStyle destStyle, bool quiet=True) -> bool
        setConnectionQos(std::string const & src, std::string const & dest, QosStyle style, bool quiet=True) -> bool
        """
        return _yarp.NetworkBase_setConnectionQos(*args)

    @staticmethod
    def getConnectionQos(src, dest, srcStyle, destStyle, quiet=True):
        r"""getConnectionQos(std::string const & src, std::string const & dest, QosStyle srcStyle, QosStyle destStyle, bool quiet=True) -> bool"""
        return _yarp.NetworkBase_getConnectionQos(src, dest, srcStyle, destStyle, quiet)

    @staticmethod
    def isValidPortName(portName):
        r"""isValidPortName(std::string const & portName) -> bool"""
        return _yarp.NetworkBase_isValidPortName(portName)

    @staticmethod
    def waitConnection(source, destination, quiet=False):
        r"""waitConnection(std::string const & source, std::string const & destination, bool quiet=False) -> bool"""
        return _yarp.NetworkBase_waitConnection(source, destination, quiet)

    @staticmethod
    def waitPort(target, quiet=False):
        r"""waitPort(std::string const & target, bool quiet=False) -> bool"""
        return _yarp.NetworkBase_waitPort(target, quiet)

    @staticmethod
    def sendMessage(*args):
        r"""
        sendMessage(std::string const & port, PortWriter writable, bool silent=False) -> int
        sendMessage(std::string const & port, PortWriter writable, std::string & output, bool quiet) -> int
        """
        return _yarp.NetworkBase_sendMessage(*args)

    @staticmethod
    def disconnectInput(src, dest, silent=False):
        r"""disconnectInput(std::string const & src, std::string const & dest, bool silent=False) -> int"""
        return _yarp.NetworkBase_disconnectInput(src, dest, silent)

    @staticmethod
    def poll(target, silent=False):
        r"""poll(std::string const & target, bool silent=False) -> int"""
        return _yarp.NetworkBase_poll(target, silent)

    def __init__(self):
        r"""__init__(NetworkBase self) -> NetworkBase"""
        _yarp.NetworkBase_swiginit(self, _yarp.new_NetworkBase())
    __swig_destroy__ = _yarp.delete_NetworkBase

# Register NetworkBase in _yarp:
_yarp.NetworkBase_swigregister(NetworkBase)

def NetworkBase_initMinimum(*args):
    r"""
    NetworkBase_initMinimum()
    NetworkBase_initMinimum(yarp::os::yarpClockType clockType, yarp::os::Clock * custom=None)
    """
    return _yarp.NetworkBase_initMinimum(*args)

def NetworkBase_autoInitMinimum(*args):
    r"""
    NetworkBase_autoInitMinimum()
    NetworkBase_autoInitMinimum(yarp::os::yarpClockType clockType, yarp::os::Clock * custom=None)
    """
    return _yarp.NetworkBase_autoInitMinimum(*args)

def NetworkBase_yarpClockInit(clockType, custom=None):
    r"""NetworkBase_yarpClockInit(yarp::os::yarpClockType clockType, Clock * custom=None)"""
    return _yarp.NetworkBase_yarpClockInit(clockType, custom)

def NetworkBase_finiMinimum():
    r"""NetworkBase_finiMinimum()"""
    return _yarp.NetworkBase_finiMinimum()

def NetworkBase_isNetworkInitialized():
    r"""NetworkBase_isNetworkInitialized() -> bool"""
    return _yarp.NetworkBase_isNetworkInitialized()

def NetworkBase_connect(*args):
    r"""
    NetworkBase_connect(std::string const & src, std::string const & dest, std::string const & carrier="", bool quiet=True) -> bool
    NetworkBase_connect(char const * src, char const * dest, char const * carrier, bool quiet=True) -> bool
    NetworkBase_connect(std::string const & src, std::string const & dest, ContactStyle style) -> bool
    """
    return _yarp.NetworkBase_connect(*args)

def NetworkBase_disconnect(*args):
    r"""
    NetworkBase_disconnect(std::string const & src, std::string const & dest, bool quiet) -> bool
    NetworkBase_disconnect(std::string const & src, std::string const & dest, ContactStyle style) -> bool
    NetworkBase_disconnect(std::string const & src, std::string const & dest, std::string const & carrier="", bool quiet=True) -> bool
    NetworkBase_disconnect(char const * src, char const * dest, char const * carrier, bool quiet=True) -> bool
    """
    return _yarp.NetworkBase_disconnect(*args)

def NetworkBase_isConnected(*args):
    r"""
    NetworkBase_isConnected(std::string const & src, std::string const & dest, bool quiet) -> bool
    NetworkBase_isConnected(std::string const & src, std::string const & dest, ContactStyle style) -> bool
    NetworkBase_isConnected(std::string const & src, std::string const & dest, std::string const & carrier="", bool quiet=True) -> bool
    NetworkBase_isConnected(char const * src, char const * dest, char const * carrier, bool quiet=True) -> bool
    """
    return _yarp.NetworkBase_isConnected(*args)

def NetworkBase_exists(*args):
    r"""
    NetworkBase_exists(std::string const & port, bool quiet=True, bool checkVer=True) -> bool
    NetworkBase_exists(std::string const & port, ContactStyle style, bool checkVer=True) -> bool
    """
    return _yarp.NetworkBase_exists(*args)

def NetworkBase_sync(port, quiet=True):
    r"""NetworkBase_sync(std::string const & port, bool quiet=True) -> bool"""
    return _yarp.NetworkBase_sync(port, quiet)

def NetworkBase_assertion(shouldBeTrue):
    r"""NetworkBase_assertion(bool shouldBeTrue)"""
    return _yarp.NetworkBase_assertion(shouldBeTrue)

def NetworkBase_queryName(name):
    r"""NetworkBase_queryName(std::string const & name) -> Contact"""
    return _yarp.NetworkBase_queryName(name)

def NetworkBase_registerName(name):
    r"""NetworkBase_registerName(std::string const & name) -> Contact"""
    return _yarp.NetworkBase_registerName(name)

def NetworkBase_registerContact(contact):
    r"""NetworkBase_registerContact(Contact contact) -> Contact"""
    return _yarp.NetworkBase_registerContact(contact)

def NetworkBase_unregisterName(name):
    r"""NetworkBase_unregisterName(std::string const & name) -> Contact"""
    return _yarp.NetworkBase_unregisterName(name)

def NetworkBase_unregisterContact(contact):
    r"""NetworkBase_unregisterContact(Contact contact) -> Contact"""
    return _yarp.NetworkBase_unregisterContact(contact)

def NetworkBase_setProperty(name, key, value):
    r"""NetworkBase_setProperty(char const * name, char const * key, Value value) -> bool"""
    return _yarp.NetworkBase_setProperty(name, key, value)

def NetworkBase_getProperty(name, key):
    r"""NetworkBase_getProperty(char const * name, char const * key) -> Value"""
    return _yarp.NetworkBase_getProperty(name, key)

def NetworkBase_getNameServerName():
    r"""NetworkBase_getNameServerName() -> std::string"""
    return _yarp.NetworkBase_getNameServerName()

def NetworkBase_getNameServerContact():
    r"""NetworkBase_getNameServerContact() -> Contact"""
    return _yarp.NetworkBase_getNameServerContact()

def NetworkBase_setNameServerName(name):
    r"""NetworkBase_setNameServerName(std::string const & name) -> bool"""
    return _yarp.NetworkBase_setNameServerName(name)

def NetworkBase_setLocalMode(flag):
    r"""NetworkBase_setLocalMode(bool flag) -> bool"""
    return _yarp.NetworkBase_setLocalMode(flag)

def NetworkBase_getLocalMode():
    r"""NetworkBase_getLocalMode() -> bool"""
    return _yarp.NetworkBase_getLocalMode()

def NetworkBase_readString(eof=None):
    r"""NetworkBase_readString(bool * eof=None) -> std::string"""
    return _yarp.NetworkBase_readString(eof)

def NetworkBase_writeToNameServer(cmd, reply, style):
    r"""NetworkBase_writeToNameServer(PortWriter cmd, PortReader reply, ContactStyle style) -> bool"""
    return _yarp.NetworkBase_writeToNameServer(cmd, reply, style)

def NetworkBase_write(*args):
    r"""
    NetworkBase_write(Contact contact, PortWriter cmd, PortReader reply, bool admin=False, bool quiet=False, double timeout=-1) -> bool
    NetworkBase_write(Contact contact, PortWriter cmd, PortReader reply, ContactStyle style) -> bool
    NetworkBase_write(std::string const & port_name, PortWriter cmd, PortReader reply) -> bool
    """
    return _yarp.NetworkBase_write(*args)

def NetworkBase_checkNetwork(*args):
    r"""
    NetworkBase_checkNetwork() -> bool
    NetworkBase_checkNetwork(double timeout) -> bool
    """
    return _yarp.NetworkBase_checkNetwork(*args)

def NetworkBase_initialized():
    r"""NetworkBase_initialized() -> bool"""
    return _yarp.NetworkBase_initialized()

def NetworkBase_setVerbosity(verbosity):
    r"""NetworkBase_setVerbosity(int verbosity)"""
    return _yarp.NetworkBase_setVerbosity(verbosity)

def NetworkBase_queryBypass(store):
    r"""NetworkBase_queryBypass(NameStore * store)"""
    return _yarp.NetworkBase_queryBypass(store)

def NetworkBase_getQueryBypass():
    r"""NetworkBase_getQueryBypass() -> NameStore *"""
    return _yarp.NetworkBase_getQueryBypass()

def NetworkBase_getEnvironment(key, found=None):
    r"""NetworkBase_getEnvironment(char const * key, bool * found=None) -> std::string"""
    return _yarp.NetworkBase_getEnvironment(key, found)

def NetworkBase_setEnvironment(key, val):
    r"""NetworkBase_setEnvironment(std::string const & key, std::string const & val)"""
    return _yarp.NetworkBase_setEnvironment(key, val)

def NetworkBase_unsetEnvironment(key):
    r"""NetworkBase_unsetEnvironment(std::string const & key)"""
    return _yarp.NetworkBase_unsetEnvironment(key)

def NetworkBase_getDirectorySeparator():
    r"""NetworkBase_getDirectorySeparator() -> std::string"""
    return _yarp.NetworkBase_getDirectorySeparator()

def NetworkBase_getPathSeparator():
    r"""NetworkBase_getPathSeparator() -> std::string"""
    return _yarp.NetworkBase_getPathSeparator()

def NetworkBase_registerCarrier(name, dll):
    r"""NetworkBase_registerCarrier(char const * name, char const * dll) -> bool"""
    return _yarp.NetworkBase_registerCarrier(name, dll)

def NetworkBase_lock():
    r"""NetworkBase_lock()"""
    return _yarp.NetworkBase_lock()

def NetworkBase_unlock():
    r"""NetworkBase_unlock()"""
    return _yarp.NetworkBase_unlock()

def NetworkBase_localNetworkAllocation():
    r"""NetworkBase_localNetworkAllocation() -> bool"""
    return _yarp.NetworkBase_localNetworkAllocation()

def NetworkBase_detectNameServer(useDetectedServer, scanNeeded, serverUsed):
    r"""NetworkBase_detectNameServer(bool useDetectedServer, bool & scanNeeded, bool & serverUsed) -> Contact"""
    return _yarp.NetworkBase_detectNameServer(useDetectedServer, scanNeeded, serverUsed)

def NetworkBase_setNameServerContact(nameServerContact):
    r"""NetworkBase_setNameServerContact(Contact nameServerContact) -> bool"""
    return _yarp.NetworkBase_setNameServerContact(nameServerContact)

def NetworkBase_getConfigFile(fname):
    r"""NetworkBase_getConfigFile(char const * fname) -> std::string"""
    return _yarp.NetworkBase_getConfigFile(fname)

def NetworkBase_getDefaultPortRange():
    r"""NetworkBase_getDefaultPortRange() -> int"""
    return _yarp.NetworkBase_getDefaultPortRange()

def NetworkBase_setConnectionQos(*args):
    r"""
    NetworkBase_setConnectionQos(std::string const & src, std::string const & dest, QosStyle srcStyle, QosStyle destStyle, bool quiet=True) -> bool
    NetworkBase_setConnectionQos(std::string const & src, std::string const & dest, QosStyle style, bool quiet=True) -> bool
    """
    return _yarp.NetworkBase_setConnectionQos(*args)

def NetworkBase_getConnectionQos(src, dest, srcStyle, destStyle, quiet=True):
    r"""NetworkBase_getConnectionQos(std::string const & src, std::string const & dest, QosStyle srcStyle, QosStyle destStyle, bool quiet=True) -> bool"""
    return _yarp.NetworkBase_getConnectionQos(src, dest, srcStyle, destStyle, quiet)

def NetworkBase_isValidPortName(portName):
    r"""NetworkBase_isValidPortName(std::string const & portName) -> bool"""
    return _yarp.NetworkBase_isValidPortName(portName)

def NetworkBase_waitConnection(source, destination, quiet=False):
    r"""NetworkBase_waitConnection(std::string const & source, std::string const & destination, bool quiet=False) -> bool"""
    return _yarp.NetworkBase_waitConnection(source, destination, quiet)

def NetworkBase_waitPort(target, quiet=False):
    r"""NetworkBase_waitPort(std::string const & target, bool quiet=False) -> bool"""
    return _yarp.NetworkBase_waitPort(target, quiet)

def NetworkBase_sendMessage(*args):
    r"""
    NetworkBase_sendMessage(std::string const & port, PortWriter writable, bool silent=False) -> int
    NetworkBase_sendMessage(std::string const & port, PortWriter writable, std::string & output, bool quiet) -> int
    """
    return _yarp.NetworkBase_sendMessage(*args)

def NetworkBase_disconnectInput(src, dest, silent=False):
    r"""NetworkBase_disconnectInput(std::string const & src, std::string const & dest, bool silent=False) -> int"""
    return _yarp.NetworkBase_disconnectInput(src, dest, silent)

def NetworkBase_poll(target, silent=False):
    r"""NetworkBase_poll(std::string const & target, bool silent=False) -> int"""
    return _yarp.NetworkBase_poll(target, silent)

class Network(NetworkBase):
    r"""Proxy of C++ yarp::os::Network class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        __init__(Network self) -> Network
        __init__(Network self, yarp::os::yarpClockType clockType, yarp::os::Clock * custom=None) -> Network
        """
        _yarp.Network_swiginit(self, _yarp.new_Network(*args))
    __swig_destroy__ = _yarp.delete_Network

    @staticmethod
    def init(*args):
        r"""
        init()
        init(yarp::os::yarpClockType clockType, Clock * custom=None)
        """
        return _yarp.Network_init(*args)

    @staticmethod
    def fini():
        r"""fini()"""
        return _yarp.Network_fini()

# Register Network in _yarp:
_yarp.Network_swigregister(Network)

def Network_init(*args):
    r"""
    Network_init()
    Network_init(yarp::os::yarpClockType clockType, Clock * custom=None)
    """
    return _yarp.Network_init(*args)

def Network_fini():
    r"""Network_fini()"""
    return _yarp.Network_fini()

class PortablePairBase(Portable):
    r"""Proxy of C++ yarp::os::PortablePairBase class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @staticmethod
    def readPair(connection, head, body):
        r"""readPair(ConnectionReader connection, Portable head, Portable body) -> bool"""
        return _yarp.PortablePairBase_readPair(connection, head, body)

    @staticmethod
    def writePair(connection, head, body):
        r"""writePair(ConnectionWriter connection, Portable head, Portable body) -> bool"""
        return _yarp.PortablePairBase_writePair(connection, head, body)
    __swig_destroy__ = _yarp.delete_PortablePairBase

# Register PortablePairBase in _yarp:
_yarp.PortablePairBase_swigregister(PortablePairBase)

def PortablePairBase_readPair(connection, head, body):
    r"""PortablePairBase_readPair(ConnectionReader connection, Portable head, Portable body) -> bool"""
    return _yarp.PortablePairBase_readPair(connection, head, body)

def PortablePairBase_writePair(connection, head, body):
    r"""PortablePairBase_writePair(ConnectionWriter connection, Portable head, Portable body) -> bool"""
    return _yarp.PortablePairBase_writePair(connection, head, body)

class PortReaderCreator(object):
    r"""Proxy of C++ yarp::os::PortReaderCreator class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _yarp.delete_PortReaderCreator

    def create(self):
        r"""create(PortReaderCreator self) -> PortReader"""
        return _yarp.PortReaderCreator_create(self)

# Register PortReaderCreator in _yarp:
_yarp.PortReaderCreator_swigregister(PortReaderCreator)

class Property(Searchable, Portable):
    r"""Proxy of C++ yarp::os::Property class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        __init__(Property self) -> Property
        __init__(Property self, int hash_size) -> Property
        __init__(Property self, char const * str) -> Property
        __init__(Property self, Property rhs) -> Property
        __init__(Property self, Property rhs) -> Property
        __init__(Property self, std::initializer_list< std::pair< std::string,yarp::os::Value > > values) -> Property
        """
        _yarp.Property_swiginit(self, _yarp.new_Property(*args))
    __swig_destroy__ = _yarp.delete_Property

    def check(self, *args):
        r"""
        check(Property self, std::string const & key, std::string const & comment) -> bool
        check(Property self, std::string const & key, Value fallback, std::string const & comment="") -> Value
        check(Property self, std::string const & key, Value fallback) -> Value
        check(Property self, std::string const & key) -> bool
        """
        return _yarp.Property_check(self, *args)

    def put(self, *args):
        r"""
        put(Property self, std::string const & key, std::string const & value)
        put(Property self, std::string const & key, Value value)
        put(Property self, std::string const & key, Value value)
        put(Property self, std::string const & key, int value)
        put(Property self, std::string const & key, double value)
        """
        return _yarp.Property_put(self, *args)

    def addGroup(self, key):
        r"""addGroup(Property self, std::string const & key) -> Property"""
        return _yarp.Property_addGroup(self, key)

    def unput(self, key):
        r"""unput(Property self, std::string const & key)"""
        return _yarp.Property_unput(self, key)

    def find(self, key):
        r"""find(Property self, std::string const & key) -> Value"""
        return _yarp.Property_find(self, key)

    def findGroup(self, *args):
        r"""
        findGroup(Property self, std::string const & key, std::string const & comment) -> Bottle
        findGroup(Property self, std::string const & key) -> Bottle
        """
        return _yarp.Property_findGroup(self, *args)

    def clear(self):
        r"""clear(Property self)"""
        return _yarp.Property_clear(self)

    def fromString(self, txt, wipe=True):
        r"""fromString(Property self, std::string const & txt, bool wipe=True)"""
        return _yarp.Property_fromString(self, txt, wipe)

    def fromCommand(self, argc, skipFirst=True, wipe=True):
        r"""fromCommand(Property self, int argc, bool skipFirst=True, bool wipe=True)"""
        return _yarp.Property_fromCommand(self, argc, skipFirst, wipe)

    def fromArguments(self, arguments, wipe=True):
        r"""fromArguments(Property self, char const * arguments, bool wipe=True)"""
        return _yarp.Property_fromArguments(self, arguments, wipe)

    def fromConfigFile(self, *args):
        r"""
        fromConfigFile(Property self, std::string const & fname, bool wipe=True) -> bool
        fromConfigFile(Property self, std::string const & fname, Searchable env, bool wipe=True) -> bool
        """
        return _yarp.Property_fromConfigFile(self, *args)

    def fromConfigDir(self, *args):
        r"""fromConfigDir(Property self, std::string const & dirname, std::string const & section=std::string(), bool wipe=True) -> bool"""
        return _yarp.Property_fromConfigDir(self, *args)

    def fromConfig(self, *args):
        r"""
        fromConfig(Property self, char const * txt, bool wipe=True)
        fromConfig(Property self, char const * txt, Searchable env, bool wipe=True)
        """
        return _yarp.Property_fromConfig(self, *args)

    def fromQuery(self, url, wipe=True):
        r"""fromQuery(Property self, char const * url, bool wipe=True)"""
        return _yarp.Property_fromQuery(self, url, wipe)

    def toString_c(self):
        r"""toString_c(Property self) -> std::string"""
        return _yarp.Property_toString_c(self)

    def read(self, reader):
        r"""read(Property self, ConnectionReader reader) -> bool"""
        return _yarp.Property_read(self, reader)

    def write(self, writer):
        r"""write(Property self, ConnectionWriter writer) -> bool"""
        return _yarp.Property_write(self, writer)

    def toString(self):
        r"""toString(Property self) -> std::string"""
        return _yarp.Property_toString(self)

# Register Property in _yarp:
_yarp.Property_swigregister(Property)

BOTTLE_TAG_INT8 = _yarp.BOTTLE_TAG_INT8

BOTTLE_TAG_INT16 = _yarp.BOTTLE_TAG_INT16

BOTTLE_TAG_INT32 = _yarp.BOTTLE_TAG_INT32

BOTTLE_TAG_INT64 = _yarp.BOTTLE_TAG_INT64

BOTTLE_TAG_VOCAB32 = _yarp.BOTTLE_TAG_VOCAB32

BOTTLE_TAG_FLOAT32 = _yarp.BOTTLE_TAG_FLOAT32

BOTTLE_TAG_FLOAT64 = _yarp.BOTTLE_TAG_FLOAT64

BOTTLE_TAG_STRING = _yarp.BOTTLE_TAG_STRING

BOTTLE_TAG_BLOB = _yarp.BOTTLE_TAG_BLOB

BOTTLE_TAG_LIST = _yarp.BOTTLE_TAG_LIST

BOTTLE_TAG_DICT = _yarp.BOTTLE_TAG_DICT

class Bottle(Portable, Searchable):
    r"""Proxy of C++ yarp::os::Bottle class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        __init__(Bottle self) -> Bottle
        __init__(Bottle self, std::string const & text) -> Bottle
        __init__(Bottle self, Bottle rhs) -> Bottle
        __init__(Bottle self, Bottle rhs) -> Bottle
        __init__(Bottle self, std::initializer_list< yarp::os::Value > values) -> Bottle
        """
        _yarp.Bottle_swiginit(self, _yarp.new_Bottle(*args))
    __swig_destroy__ = _yarp.delete_Bottle

    def clear(self):
        r"""clear(Bottle self)"""
        return _yarp.Bottle_clear(self)

    def addInt(self, x):
        r"""addInt(Bottle self, int x)"""
        return _yarp.Bottle_addInt(self, x)

    def addInt8(self, x):
        r"""addInt8(Bottle self, std::int8_t x)"""
        return _yarp.Bottle_addInt8(self, x)

    def addInt16(self, x):
        r"""addInt16(Bottle self, std::int16_t x)"""
        return _yarp.Bottle_addInt16(self, x)

    def addInt32(self, x):
        r"""addInt32(Bottle self, std::int32_t x)"""
        return _yarp.Bottle_addInt32(self, x)

    def addInt64(self, x):
        r"""addInt64(Bottle self, std::int64_t x)"""
        return _yarp.Bottle_addInt64(self, x)

    def addVocab(self, x):
        r"""addVocab(Bottle self, yarp::conf::vocab32_t x)"""
        return _yarp.Bottle_addVocab(self, x)

    def addVocab32(self, *args):
        r"""
        addVocab32(Bottle self, yarp::conf::vocab32_t x)
        addVocab32(Bottle self, char a, char b=0, char c=0, char d=0)
        addVocab32(Bottle self, std::string const & str)
        """
        return _yarp.Bottle_addVocab32(self, *args)

    def addDouble(self, x):
        r"""addDouble(Bottle self, double x)"""
        return _yarp.Bottle_addDouble(self, x)

    def addFloat32(self, x):
        r"""addFloat32(Bottle self, yarp::conf::float32_t x)"""
        return _yarp.Bottle_addFloat32(self, x)

    def addFloat64(self, x):
        r"""addFloat64(Bottle self, yarp::conf::float64_t x)"""
        return _yarp.Bottle_addFloat64(self, x)

    def addString(self, *args):
        r"""
        addString(Bottle self, char const * str)
        addString(Bottle self, std::string const & str)
        """
        return _yarp.Bottle_addString(self, *args)

    def add(self, value):
        r"""add(Bottle self, Value value)"""
        return _yarp.Bottle_add(self, value)

    def addList(self):
        r"""addList(Bottle self) -> Bottle"""
        return _yarp.Bottle_addList(self)

    def addDict(self):
        r"""addDict(Bottle self) -> Property"""
        return _yarp.Bottle_addDict(self)

    def pop(self):
        r"""pop(Bottle self) -> Value"""
        return _yarp.Bottle_pop(self)

    def get(self, index):
        r"""get(Bottle self, yarp::os::Bottle::size_type index) -> Value"""
        return _yarp.Bottle_get(self, index)

    def size(self):
        r"""size(Bottle self) -> yarp::os::Bottle::size_type"""
        return _yarp.Bottle_size(self)

    def fromString(self, text):
        r"""fromString(Bottle self, std::string const & text)"""
        return _yarp.Bottle_fromString(self, text)

    def fromBinary(self, buf, len):
        r"""fromBinary(Bottle self, char const * buf, size_t len)"""
        return _yarp.Bottle_fromBinary(self, buf, len)

    def toBinary(self, size=None):
        r"""toBinary(Bottle self, size_t * size=None) -> char const"""
        return _yarp.Bottle_toBinary(self, size)

    def toString_c(self):
        r"""toString_c(Bottle self) -> std::string"""
        return _yarp.Bottle_toString_c(self)

    def write(self, *args):
        r"""
        write(Bottle self, ConnectionWriter writer) -> bool
        write(Bottle self, PortReader reader, bool textMode=False) -> bool
        """
        return _yarp.Bottle_write(self, *args)

    def read(self, *args):
        r"""
        read(Bottle self, ConnectionReader reader) -> bool
        read(Bottle self, PortWriter writer, bool textMode=False) -> bool
        """
        return _yarp.Bottle_read(self, *args)

    def onCommencement(self):
        r"""onCommencement(Bottle self)"""
        return _yarp.Bottle_onCommencement(self)

    def check(self, *args):
        r"""
        check(Bottle self, std::string const & key, std::string const & comment) -> bool
        check(Bottle self, std::string const & key, Value fallback, std::string const & comment="") -> Value
        check(Bottle self, std::string const & key, Value fallback) -> Value
        check(Bottle self, std::string const & key) -> bool
        """
        return _yarp.Bottle_check(self, *args)

    def find(self, key):
        r"""find(Bottle self, std::string const & key) -> Value"""
        return _yarp.Bottle_find(self, key)

    def findGroup(self, *args):
        r"""
        findGroup(Bottle self, std::string const & key, std::string const & comment) -> Bottle
        findGroup(Bottle self, std::string const & key) -> Bottle
        """
        return _yarp.Bottle_findGroup(self, *args)

    def isNull(self):
        r"""isNull(Bottle self) -> bool"""
        return _yarp.Bottle_isNull(self)

    def copy(self, *args):
        r"""copy(Bottle self, Bottle alt, yarp::os::Bottle::size_type first=0, yarp::os::Bottle::size_type len=npos)"""
        return _yarp.Bottle_copy(self, *args)

    @staticmethod
    def getNullBottle():
        r"""getNullBottle() -> Bottle"""
        return _yarp.Bottle_getNullBottle()

    def isEqual(self, alt):
        r"""isEqual(Bottle self, Bottle alt) -> bool"""
        return _yarp.Bottle_isEqual(self, alt)

    def notEqual(self, alt):
        r"""notEqual(Bottle self, Bottle alt) -> bool"""
        return _yarp.Bottle_notEqual(self, alt)

    def append(self, alt):
        r"""append(Bottle self, Bottle alt)"""
        return _yarp.Bottle_append(self, alt)

    def tail(self):
        r"""tail(Bottle self) -> Bottle"""
        return _yarp.Bottle_tail(self)

    def hasChanged(self):
        r"""hasChanged(Bottle self)"""
        return _yarp.Bottle_hasChanged(self)

    def getSpecialization(self):
        r"""getSpecialization(Bottle self) -> int"""
        return _yarp.Bottle_getSpecialization(self)

    @staticmethod
    def describeBottleCode(code):
        r"""describeBottleCode(int code) -> std::string"""
        return _yarp.Bottle_describeBottleCode(code)

    def toString(self, *args):
        r"""
        toString(Bottle self, int x) -> std::string
        toString(Bottle self) -> std::string
        """
        return _yarp.Bottle_toString(self, *args)

# Register Bottle in _yarp:
_yarp.Bottle_swigregister(Bottle)
BOTTLE_TAG_DOUBLE = cvar.BOTTLE_TAG_DOUBLE
BOTTLE_TAG_INT = cvar.BOTTLE_TAG_INT
BOTTLE_TAG_VOCAB = cvar.BOTTLE_TAG_VOCAB
Bottle.npos = _yarp.cvar.Bottle_npos

def Bottle_getNullBottle():
    r"""Bottle_getNullBottle() -> Bottle"""
    return _yarp.Bottle_getNullBottle()

def Bottle_describeBottleCode(code):
    r"""Bottle_describeBottleCode(int code) -> std::string"""
    return _yarp.Bottle_describeBottleCode(code)

class Random(object):
    r"""Proxy of C++ yarp::os::Random class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def seed_c(seed):
        r"""seed_c(int seed)"""
        return _yarp.Random_seed_c(seed)

    @staticmethod
    def normal(*args):
        r"""
        normal(double m, double s) -> double
        normal() -> double
        """
        return _yarp.Random_normal(*args)

    @staticmethod
    def uniform(*args):
        r"""
        uniform() -> double
        uniform(int min, int max) -> int
        """
        return _yarp.Random_uniform(*args)

    def __init__(self):
        r"""__init__(Random self) -> Random"""
        _yarp.Random_swiginit(self, _yarp.new_Random())
    __swig_destroy__ = _yarp.delete_Random

# Register Random in _yarp:
_yarp.Random_swigregister(Random)

def Random_seed_c(seed):
    r"""Random_seed_c(int seed)"""
    return _yarp.Random_seed_c(seed)

def Random_normal(*args):
    r"""
    Random_normal(double m, double s) -> double
    Random_normal() -> double
    """
    return _yarp.Random_normal(*args)

def Random_uniform(*args):
    r"""
    Random_uniform() -> double
    Random_uniform(int min, int max) -> int
    """
    return _yarp.Random_uniform(*args)

class Semaphore(object):
    r"""Proxy of C++ yarp::os::Semaphore class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, initialCount=1):
        r"""__init__(Semaphore self, unsigned int initialCount=1) -> Semaphore"""
        _yarp.Semaphore_swiginit(self, _yarp.new_Semaphore(initialCount))
    __swig_destroy__ = _yarp.delete_Semaphore

    def wait(self):
        r"""wait(Semaphore self)"""
        return _yarp.Semaphore_wait(self)

    def waitWithTimeout(self, timeoutInSeconds):
        r"""waitWithTimeout(Semaphore self, double timeoutInSeconds) -> bool"""
        return _yarp.Semaphore_waitWithTimeout(self, timeoutInSeconds)

    def check(self):
        r"""check(Semaphore self) -> bool"""
        return _yarp.Semaphore_check(self)

    def post(self):
        r"""post(Semaphore self)"""
        return _yarp.Semaphore_post(self)

# Register Semaphore in _yarp:
_yarp.Semaphore_swigregister(Semaphore)

class Thread(object):
    r"""Proxy of C++ yarp::os::Thread class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        r"""__init__(Thread self) -> Thread"""
        if self.__class__ == Thread:
            _self = None
        else:
            _self = self
        _yarp.Thread_swiginit(self, _yarp.new_Thread(_self, ))
    __swig_destroy__ = _yarp.delete_Thread

    def run(self):
        r"""run(Thread self)"""
        return _yarp.Thread_run(self)

    def onStop(self):
        r"""onStop(Thread self)"""
        return _yarp.Thread_onStop(self)

    def start(self):
        r"""start(Thread self) -> bool"""
        return _yarp.Thread_start(self)

    def stop(self):
        r"""stop(Thread self) -> bool"""
        return _yarp.Thread_stop(self)

    def beforeStart(self):
        r"""beforeStart(Thread self)"""
        return _yarp.Thread_beforeStart(self)

    def afterStart(self, success):
        r"""afterStart(Thread self, bool success)"""
        return _yarp.Thread_afterStart(self, success)

    def threadInit(self):
        r"""threadInit(Thread self) -> bool"""
        return _yarp.Thread_threadInit(self)

    def threadRelease(self):
        r"""threadRelease(Thread self)"""
        return _yarp.Thread_threadRelease(self)

    def isStopping(self):
        r"""isStopping(Thread self) -> bool"""
        return _yarp.Thread_isStopping(self)

    def isRunning(self):
        r"""isRunning(Thread self) -> bool"""
        return _yarp.Thread_isRunning(self)

    @staticmethod
    def getCount():
        r"""getCount() -> int"""
        return _yarp.Thread_getCount()

    def getKey(self):
        r"""getKey(Thread self) -> long"""
        return _yarp.Thread_getKey(self)

    @staticmethod
    def getKeyOfCaller():
        r"""getKeyOfCaller() -> long"""
        return _yarp.Thread_getKeyOfCaller()

    def setPriority(self, priority, policy=-1):
        r"""setPriority(Thread self, int priority, int policy=-1) -> int"""
        return _yarp.Thread_setPriority(self, priority, policy)

    def getPriority(self):
        r"""getPriority(Thread self) -> int"""
        return _yarp.Thread_getPriority(self)

    def getPolicy(self):
        r"""getPolicy(Thread self) -> int"""
        return _yarp.Thread_getPolicy(self)

    def join(self, seconds=-1):
        r"""join(Thread self, double seconds=-1) -> bool"""
        return _yarp.Thread_join(self, seconds)

    @staticmethod
    def yield_c():
        r"""yield_c()"""
        return _yarp.Thread_yield_c()

    def setOptions(self, stackSize=0):
        r"""setOptions(Thread self, int stackSize=0)"""
        return _yarp.Thread_setOptions(self, stackSize)

    @staticmethod
    def setDefaultStackSize(stackSize):
        r"""setDefaultStackSize(int stackSize)"""
        return _yarp.Thread_setDefaultStackSize(stackSize)
    def __disown__(self):
        self.this.disown()
        _yarp.disown_Thread(self)
        return weakref.proxy(self)

# Register Thread in _yarp:
_yarp.Thread_swigregister(Thread)

def Thread_getCount():
    r"""Thread_getCount() -> int"""
    return _yarp.Thread_getCount()

def Thread_getKeyOfCaller():
    r"""Thread_getKeyOfCaller() -> long"""
    return _yarp.Thread_getKeyOfCaller()

def Thread_yield_c():
    r"""Thread_yield_c()"""
    return _yarp.Thread_yield_c()

def Thread_setDefaultStackSize(stackSize):
    r"""Thread_setDefaultStackSize(int stackSize)"""
    return _yarp.Thread_setDefaultStackSize(stackSize)

PeriodicThreadClock_Relative = _yarp.PeriodicThreadClock_Relative

PeriodicThreadClock_Absolute = _yarp.PeriodicThreadClock_Absolute

class PeriodicThread(object):
    r"""Proxy of C++ yarp::os::PeriodicThread class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _yarp.delete_PeriodicThread

    def start(self):
        r"""start(PeriodicThread self) -> bool"""
        return _yarp.PeriodicThread_start(self)

    def step(self):
        r"""step(PeriodicThread self)"""
        return _yarp.PeriodicThread_step(self)

    def stop(self):
        r"""stop(PeriodicThread self)"""
        return _yarp.PeriodicThread_stop(self)

    def askToStop(self):
        r"""askToStop(PeriodicThread self)"""
        return _yarp.PeriodicThread_askToStop(self)

    def isRunning(self):
        r"""isRunning(PeriodicThread self) -> bool"""
        return _yarp.PeriodicThread_isRunning(self)

    def isSuspended(self):
        r"""isSuspended(PeriodicThread self) -> bool"""
        return _yarp.PeriodicThread_isSuspended(self)

    def setPeriod(self, period):
        r"""setPeriod(PeriodicThread self, double period) -> bool"""
        return _yarp.PeriodicThread_setPeriod(self, period)

    def getPeriod(self):
        r"""getPeriod(PeriodicThread self) -> double"""
        return _yarp.PeriodicThread_getPeriod(self)

    def suspend(self):
        r"""suspend(PeriodicThread self)"""
        return _yarp.PeriodicThread_suspend(self)

    def resume(self):
        r"""resume(PeriodicThread self)"""
        return _yarp.PeriodicThread_resume(self)

    def resetStat(self):
        r"""resetStat(PeriodicThread self)"""
        return _yarp.PeriodicThread_resetStat(self)

    def getEstimatedPeriod(self, *args):
        r"""
        getEstimatedPeriod(PeriodicThread self) -> double
        getEstimatedPeriod(PeriodicThread self, double & av, double & std)
        """
        return _yarp.PeriodicThread_getEstimatedPeriod(self, *args)

    def getIterations(self):
        r"""getIterations(PeriodicThread self) -> unsigned int"""
        return _yarp.PeriodicThread_getIterations(self)

    def getEstimatedUsed(self, *args):
        r"""
        getEstimatedUsed(PeriodicThread self) -> double
        getEstimatedUsed(PeriodicThread self, double & av, double & std)
        """
        return _yarp.PeriodicThread_getEstimatedUsed(self, *args)

    def setPriority(self, priority, policy=-1):
        r"""setPriority(PeriodicThread self, int priority, int policy=-1) -> int"""
        return _yarp.PeriodicThread_setPriority(self, priority, policy)

    def getPriority(self):
        r"""getPriority(PeriodicThread self) -> int"""
        return _yarp.PeriodicThread_getPriority(self)

    def getPolicy(self):
        r"""getPolicy(PeriodicThread self) -> int"""
        return _yarp.PeriodicThread_getPolicy(self)

# Register PeriodicThread in _yarp:
_yarp.PeriodicThread_swigregister(PeriodicThread)

ShouldUseSystemClock_No = _yarp.ShouldUseSystemClock_No

ShouldUseSystemClock_Yes = _yarp.ShouldUseSystemClock_Yes

YARP_CLOCK_UNINITIALIZED = _yarp.YARP_CLOCK_UNINITIALIZED

YARP_CLOCK_DEFAULT = _yarp.YARP_CLOCK_DEFAULT

YARP_CLOCK_SYSTEM = _yarp.YARP_CLOCK_SYSTEM

YARP_CLOCK_NETWORK = _yarp.YARP_CLOCK_NETWORK

YARP_CLOCK_CUSTOM = _yarp.YARP_CLOCK_CUSTOM


def delay(seconds):
    r"""delay(double seconds)"""
    return _yarp.delay(seconds)

def now():
    r"""now() -> double"""
    return _yarp.now()

def yield_c():
    r"""yield_c()"""
    return _yarp.yield_c()

def useSystemClock():
    r"""useSystemClock()"""
    return _yarp.useSystemClock()

def useNetworkClock(*args):
    r"""useNetworkClock(std::string const & clock, std::string const & localPortName="")"""
    return _yarp.useNetworkClock(*args)

def useCustomClock(clock):
    r"""useCustomClock(Clock * clock)"""
    return _yarp.useCustomClock(clock)

def isClockInitialized():
    r"""isClockInitialized() -> bool"""
    return _yarp.isClockInitialized()

def isSystemClock():
    r"""isSystemClock() -> bool"""
    return _yarp.isSystemClock()

def isNetworkClock():
    r"""isNetworkClock() -> bool"""
    return _yarp.isNetworkClock()

def isCustomClock():
    r"""isCustomClock() -> bool"""
    return _yarp.isCustomClock()

def getClockType():
    r"""getClockType() -> yarp::os::yarpClockType"""
    return _yarp.getClockType()

def clockTypeToString(type):
    r"""clockTypeToString(yarp::os::yarpClockType type) -> std::string"""
    return _yarp.clockTypeToString(type)

def isValid():
    r"""isValid() -> bool"""
    return _yarp.isValid()

def turboBoost():
    r"""turboBoost()"""
    return _yarp.turboBoost()
class RFModule(object):
    r"""Proxy of C++ yarp::os::RFModule class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        r"""__init__(RFModule self) -> RFModule"""
        if self.__class__ == RFModule:
            _self = None
        else:
            _self = self
        _yarp.RFModule_swiginit(self, _yarp.new_RFModule(_self, ))
    __swig_destroy__ = _yarp.delete_RFModule

    def getPeriod(self):
        r"""getPeriod(RFModule self) -> double"""
        return _yarp.RFModule_getPeriod(self)

    def updateModule(self):
        r"""updateModule(RFModule self) -> bool"""
        return _yarp.RFModule_updateModule(self)

    def runModule(self, *args):
        r"""
        runModule(RFModule self) -> int
        runModule(RFModule self, ResourceFinder rf) -> int
        """
        return _yarp.RFModule_runModule(self, *args)

    def runModuleThreaded(self, *args):
        r"""
        runModuleThreaded(RFModule self) -> int
        runModuleThreaded(RFModule self, ResourceFinder rf) -> int
        """
        return _yarp.RFModule_runModuleThreaded(self, *args)

    def getThreadKey(self):
        r"""getThreadKey(RFModule self) -> int"""
        return _yarp.RFModule_getThreadKey(self)

    def configure(self, rf):
        r"""configure(RFModule self, ResourceFinder rf) -> bool"""
        return _yarp.RFModule_configure(self, rf)

    def respond(self, command, reply):
        r"""respond(RFModule self, Bottle command, Bottle reply) -> bool"""
        return _yarp.RFModule_respond(self, command, reply)

    def attach(self, source):
        r"""attach(RFModule self, Port source) -> bool"""
        return _yarp.RFModule_attach(self, source)

    def attach_rpc_server(self, source):
        r"""attach_rpc_server(RFModule self, RpcServer source) -> bool"""
        return _yarp.RFModule_attach_rpc_server(self, source)

    def attachTerminal(self):
        r"""attachTerminal(RFModule self) -> bool"""
        return _yarp.RFModule_attachTerminal(self)

    def detachTerminal(self):
        r"""detachTerminal(RFModule self) -> bool"""
        return _yarp.RFModule_detachTerminal(self)

    def interruptModule(self):
        r"""interruptModule(RFModule self) -> bool"""
        return _yarp.RFModule_interruptModule(self)

    def close(self):
        r"""close(RFModule self) -> bool"""
        return _yarp.RFModule_close(self)

    def stopModule(self, wait=False):
        r"""stopModule(RFModule self, bool wait=False)"""
        return _yarp.RFModule_stopModule(self, wait)

    def isStopping(self):
        r"""isStopping(RFModule self) -> bool"""
        return _yarp.RFModule_isStopping(self)

    def joinModule(self, seconds=-1):
        r"""joinModule(RFModule self, double seconds=-1) -> bool"""
        return _yarp.RFModule_joinModule(self, seconds)

    def getName(self, *args):
        r"""getName(RFModule self, std::string const & subName="") -> std::string"""
        return _yarp.RFModule_getName(self, *args)

    def setName(self, name):
        r"""setName(RFModule self, char const * name)"""
        return _yarp.RFModule_setName(self, name)

    def safeRespond(self, command, reply):
        r"""safeRespond(RFModule self, Bottle command, Bottle reply) -> bool"""
        return _yarp.RFModule_safeRespond(self, command, reply)
    def __disown__(self):
        self.this.disown()
        _yarp.disown_RFModule(self)
        return weakref.proxy(self)

# Register RFModule in _yarp:
_yarp.RFModule_swigregister(RFModule)

class Stamp(Portable):
    r"""Proxy of C++ yarp::os::Stamp class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        __init__(Stamp self) -> Stamp
        __init__(Stamp self, int count, double time) -> Stamp
        """
        _yarp.Stamp_swiginit(self, _yarp.new_Stamp(*args))

    def getCount(self):
        r"""getCount(Stamp self) -> int"""
        return _yarp.Stamp_getCount(self)

    def getTime(self):
        r"""getTime(Stamp self) -> double"""
        return _yarp.Stamp_getTime(self)

    def isValid(self):
        r"""isValid(Stamp self) -> bool"""
        return _yarp.Stamp_isValid(self)

    def getMaxCount(self):
        r"""getMaxCount(Stamp self) -> int"""
        return _yarp.Stamp_getMaxCount(self)

    def update(self, *args):
        r"""
        update(Stamp self)
        update(Stamp self, double time)
        """
        return _yarp.Stamp_update(self, *args)

    def read(self, connection):
        r"""read(Stamp self, ConnectionReader connection) -> bool"""
        return _yarp.Stamp_read(self, connection)

    def write(self, connection):
        r"""write(Stamp self, ConnectionWriter connection) -> bool"""
        return _yarp.Stamp_write(self, connection)
    __swig_destroy__ = _yarp.delete_Stamp

# Register Stamp in _yarp:
_yarp.Stamp_swigregister(Stamp)

class Stamped(object):
    r"""Proxy of C++ yarp::os::Stamped class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _yarp.delete_Stamped

    def getStamp(self):
        r"""getStamp(Stamped self) -> Stamp"""
        return _yarp.Stamped_getStamp(self)

# Register Stamped in _yarp:
_yarp.Stamped_swigregister(Stamped)

class NameStore(object):
    r"""Proxy of C++ yarp::os::NameStore class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _yarp.delete_NameStore

    def query(self, name):
        r"""query(NameStore self, std::string const & name) -> Contact"""
        return _yarp.NameStore_query(self, name)

    def announce(self, name, activity):
        r"""announce(NameStore self, std::string const & name, int activity) -> bool"""
        return _yarp.NameStore_announce(self, name, activity)

    def process(self, _in, out, source):
        r"""process(NameStore self, PortWriter _in, PortReader out, Contact source) -> bool"""
        return _yarp.NameStore_process(self, _in, out, source)

# Register NameStore in _yarp:
_yarp.NameStore_swigregister(NameStore)

class ContactStyle(object):
    r"""Proxy of C++ yarp::os::ContactStyle class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    admin = property(_yarp.ContactStyle_admin_get, _yarp.ContactStyle_admin_set, doc=r"""admin : bool""")
    quiet = property(_yarp.ContactStyle_quiet_get, _yarp.ContactStyle_quiet_set, doc=r"""quiet : bool""")
    verboseOnSuccess = property(_yarp.ContactStyle_verboseOnSuccess_get, _yarp.ContactStyle_verboseOnSuccess_set, doc=r"""verboseOnSuccess : bool""")
    timeout = property(_yarp.ContactStyle_timeout_get, _yarp.ContactStyle_timeout_set, doc=r"""timeout : double""")
    carrier = property(_yarp.ContactStyle_carrier_get, _yarp.ContactStyle_carrier_set, doc=r"""carrier : std::string""")
    expectReply = property(_yarp.ContactStyle_expectReply_get, _yarp.ContactStyle_expectReply_set, doc=r"""expectReply : bool""")
    persistent = property(_yarp.ContactStyle_persistent_get, _yarp.ContactStyle_persistent_set, doc=r"""persistent : bool""")
    OPENENDED = _yarp.ContactStyle_OPENENDED
    
    END_WITH_FROM_PORT = _yarp.ContactStyle_END_WITH_FROM_PORT
    
    END_WITH_TO_PORT = _yarp.ContactStyle_END_WITH_TO_PORT
    
    NO_PERSISTENCE = _yarp.ContactStyle_NO_PERSISTENCE
    
    persistenceType = property(_yarp.ContactStyle_persistenceType_get, _yarp.ContactStyle_persistenceType_set, doc=r"""persistenceType : yarp::os::ContactStyle::PersistenceType""")

    def __init__(self):
        r"""__init__(ContactStyle self) -> ContactStyle"""
        _yarp.ContactStyle_swiginit(self, _yarp.new_ContactStyle())
    __swig_destroy__ = _yarp.delete_ContactStyle

# Register ContactStyle in _yarp:
_yarp.ContactStyle_swigregister(ContactStyle)

class ResourceFinder(Searchable):
    r"""Proxy of C++ yarp::os::ResourceFinder class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        __init__(ResourceFinder self) -> ResourceFinder
        __init__(ResourceFinder self, ResourceFinder alt) -> ResourceFinder
        """
        _yarp.ResourceFinder_swiginit(self, _yarp.new_ResourceFinder(*args))
    __swig_destroy__ = _yarp.delete_ResourceFinder

    def configure(self, argc, skipFirstArgument=True):
        r"""configure(ResourceFinder self, int argc, bool skipFirstArgument=True) -> bool"""
        return _yarp.ResourceFinder_configure(self, argc, skipFirstArgument)

    def setDefaultContext(self, contextName):
        r"""setDefaultContext(ResourceFinder self, std::string const & contextName) -> bool"""
        return _yarp.ResourceFinder_setDefaultContext(self, contextName)

    def setDefault(self, *args):
        r"""
        setDefault(ResourceFinder self, std::string const & key, std::string const & val) -> bool
        setDefault(ResourceFinder self, std::string const & key, std::int32_t val) -> bool
        setDefault(ResourceFinder self, std::string const & key, yarp::conf::float64_t val) -> bool
        setDefault(ResourceFinder self, std::string const & key, Value val) -> bool
        """
        return _yarp.ResourceFinder_setDefault(self, *args)

    def setDefaultConfigFile(self, fname):
        r"""setDefaultConfigFile(ResourceFinder self, std::string const & fname) -> bool"""
        return _yarp.ResourceFinder_setDefaultConfigFile(self, fname)

    def getContext(self):
        r"""getContext(ResourceFinder self) -> std::string"""
        return _yarp.ResourceFinder_getContext(self)

    def getContexts(self):
        r"""getContexts(ResourceFinder self) -> Bottle"""
        return _yarp.ResourceFinder_getContexts(self)

    def find(self, key):
        r"""find(ResourceFinder self, std::string const & key) -> Value"""
        return _yarp.ResourceFinder_find(self, key)

    def isNull(self):
        r"""isNull(ResourceFinder self) -> bool"""
        return _yarp.ResourceFinder_isNull(self)

    def toString_c(self):
        r"""toString_c(ResourceFinder self) -> std::string"""
        return _yarp.ResourceFinder_toString_c(self)

    def findNestedResourceFinder(self, key):
        r"""findNestedResourceFinder(ResourceFinder self, std::string const & key) -> ResourceFinder"""
        return _yarp.ResourceFinder_findNestedResourceFinder(self, key)

    def isConfigured(self):
        r"""isConfigured(ResourceFinder self) -> bool"""
        return _yarp.ResourceFinder_isConfigured(self)

    @staticmethod
    def getResourceFinderSingleton():
        r"""getResourceFinderSingleton() -> ResourceFinder"""
        return _yarp.ResourceFinder_getResourceFinderSingleton()

    def check(self, *args):
        r"""
        check(ResourceFinder self, std::string const & key) -> bool
        check(ResourceFinder self, std::string const & key, std::string const & comment) -> bool
        check(ResourceFinder self, std::string const & key, Value fallback, std::string const & comment="") -> Value
        check(ResourceFinder self, std::string const & key, Value fallback) -> Value
        """
        return _yarp.ResourceFinder_check(self, *args)

    def findGroup(self, *args):
        r"""
        findGroup(ResourceFinder self, std::string const & key) -> Bottle
        findGroup(ResourceFinder self, std::string const & key, std::string const & comment) -> Bottle
        """
        return _yarp.ResourceFinder_findGroup(self, *args)

    def getHomeContextPath(self):
        r"""getHomeContextPath(ResourceFinder self) -> std::string"""
        return _yarp.ResourceFinder_getHomeContextPath(self)

    def getHomeRobotPath(self):
        r"""getHomeRobotPath(ResourceFinder self) -> std::string"""
        return _yarp.ResourceFinder_getHomeRobotPath(self)

    def findPaths(self, *args):
        r"""
        findPaths(ResourceFinder self, std::string const & name) -> Bottle
        findPaths(ResourceFinder self, std::string const & name, ResourceFinderOptions const & options) -> Bottle
        """
        return _yarp.ResourceFinder_findPaths(self, *args)

    def findPath(self, *args):
        r"""
        findPath(ResourceFinder self, std::string const & name) -> std::string
        findPath(ResourceFinder self) -> std::string
        findPath(ResourceFinder self, std::string const & name, ResourceFinderOptions const & options) -> std::string
        """
        return _yarp.ResourceFinder_findPath(self, *args)

    def findFile(self, *args):
        r"""
        findFile(ResourceFinder self, std::string const & name) -> std::string
        findFile(ResourceFinder self, std::string const & name, ResourceFinderOptions const & options) -> std::string
        """
        return _yarp.ResourceFinder_findFile(self, *args)

    def findFileByName(self, *args):
        r"""
        findFileByName(ResourceFinder self, std::string const & name) -> std::string
        findFileByName(ResourceFinder self, std::string const & name, ResourceFinderOptions const & options) -> std::string
        """
        return _yarp.ResourceFinder_findFileByName(self, *args)

    def readConfig(self, config, key, options):
        r"""readConfig(ResourceFinder self, Property config, std::string const & key, ResourceFinderOptions const & options) -> bool"""
        return _yarp.ResourceFinder_readConfig(self, config, key, options)

    def setVerbose(self, verbose=True):
        r"""setVerbose(ResourceFinder self, bool verbose=True) -> bool"""
        return _yarp.ResourceFinder_setVerbose(self, verbose)

    def setQuiet(self, quiet=True):
        r"""setQuiet(ResourceFinder self, bool quiet=True) -> bool"""
        return _yarp.ResourceFinder_setQuiet(self, quiet)

    @staticmethod
    def getDataHome():
        r"""getDataHome() -> std::string"""
        return _yarp.ResourceFinder_getDataHome()

    @staticmethod
    def getDataHomeNoCreate():
        r"""getDataHomeNoCreate() -> std::string"""
        return _yarp.ResourceFinder_getDataHomeNoCreate()

    @staticmethod
    def getConfigHome():
        r"""getConfigHome() -> std::string"""
        return _yarp.ResourceFinder_getConfigHome()

    @staticmethod
    def getConfigHomeNoCreate():
        r"""getConfigHomeNoCreate() -> std::string"""
        return _yarp.ResourceFinder_getConfigHomeNoCreate()

    @staticmethod
    def getDataDirs():
        r"""getDataDirs() -> Bottle"""
        return _yarp.ResourceFinder_getDataDirs()

    @staticmethod
    def getConfigDirs():
        r"""getConfigDirs() -> Bottle"""
        return _yarp.ResourceFinder_getConfigDirs()

# Register ResourceFinder in _yarp:
_yarp.ResourceFinder_swigregister(ResourceFinder)

def ResourceFinder_getResourceFinderSingleton():
    r"""ResourceFinder_getResourceFinderSingleton() -> ResourceFinder"""
    return _yarp.ResourceFinder_getResourceFinderSingleton()

def ResourceFinder_getDataHome():
    r"""ResourceFinder_getDataHome() -> std::string"""
    return _yarp.ResourceFinder_getDataHome()

def ResourceFinder_getDataHomeNoCreate():
    r"""ResourceFinder_getDataHomeNoCreate() -> std::string"""
    return _yarp.ResourceFinder_getDataHomeNoCreate()

def ResourceFinder_getConfigHome():
    r"""ResourceFinder_getConfigHome() -> std::string"""
    return _yarp.ResourceFinder_getConfigHome()

def ResourceFinder_getConfigHomeNoCreate():
    r"""ResourceFinder_getConfigHomeNoCreate() -> std::string"""
    return _yarp.ResourceFinder_getConfigHomeNoCreate()

def ResourceFinder_getDataDirs():
    r"""ResourceFinder_getDataDirs() -> Bottle"""
    return _yarp.ResourceFinder_getDataDirs()

def ResourceFinder_getConfigDirs():
    r"""ResourceFinder_getConfigDirs() -> Bottle"""
    return _yarp.ResourceFinder_getConfigDirs()

class RpcServer(AbstractContactable):
    r"""Proxy of C++ yarp::os::RpcServer class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        r"""__init__(RpcServer self) -> RpcServer"""
        _yarp.RpcServer_swiginit(self, _yarp.new_RpcServer())
    __swig_destroy__ = _yarp.delete_RpcServer

    def write(self, *args):
        r"""
        write(RpcServer self, PortWriter writer, PortWriter callback=None) -> bool
        write(RpcServer self, PortWriter writer, PortReader reader, PortWriter callback=None) -> bool
        """
        return _yarp.RpcServer_write(self, *args)

    def read(self, reader, willReply=True):
        r"""read(RpcServer self, PortReader reader, bool willReply=True) -> bool"""
        return _yarp.RpcServer_read(self, reader, willReply)

    def setInputMode(self, expectInput):
        r"""setInputMode(RpcServer self, bool expectInput)"""
        return _yarp.RpcServer_setInputMode(self, expectInput)

    def setOutputMode(self, expectOutput):
        r"""setOutputMode(RpcServer self, bool expectOutput)"""
        return _yarp.RpcServer_setOutputMode(self, expectOutput)

    def setRpcMode(self, expectRpc):
        r"""setRpcMode(RpcServer self, bool expectRpc)"""
        return _yarp.RpcServer_setRpcMode(self, expectRpc)

    def asPort(self, *args):
        r"""
        asPort(RpcServer self) -> Port
        asPort(RpcServer self) -> Port
        """
        return _yarp.RpcServer_asPort(self, *args)

# Register RpcServer in _yarp:
_yarp.RpcServer_swigregister(RpcServer)

class RpcClient(AbstractContactable):
    r"""Proxy of C++ yarp::os::RpcClient class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        r"""__init__(RpcClient self) -> RpcClient"""
        _yarp.RpcClient_swiginit(self, _yarp.new_RpcClient())
    __swig_destroy__ = _yarp.delete_RpcClient

    def read(self, reader, willReply=False):
        r"""read(RpcClient self, PortReader reader, bool willReply=False) -> bool"""
        return _yarp.RpcClient_read(self, reader, willReply)

    def reply(self, writer):
        r"""reply(RpcClient self, PortWriter writer) -> bool"""
        return _yarp.RpcClient_reply(self, writer)

    def replyAndDrop(self, writer):
        r"""replyAndDrop(RpcClient self, PortWriter writer) -> bool"""
        return _yarp.RpcClient_replyAndDrop(self, writer)

    def setInputMode(self, expectInput):
        r"""setInputMode(RpcClient self, bool expectInput)"""
        return _yarp.RpcClient_setInputMode(self, expectInput)

    def setOutputMode(self, expectOutput):
        r"""setOutputMode(RpcClient self, bool expectOutput)"""
        return _yarp.RpcClient_setOutputMode(self, expectOutput)

    def setRpcMode(self, expectRpc):
        r"""setRpcMode(RpcClient self, bool expectRpc)"""
        return _yarp.RpcClient_setRpcMode(self, expectRpc)

    def asPort(self, *args):
        r"""
        asPort(RpcClient self) -> Port
        asPort(RpcClient self) -> Port
        """
        return _yarp.RpcClient_asPort(self, *args)

    def write(self, data1, data2):
        r"""write(RpcClient self, Bottle data1, Bottle data2) -> bool"""
        return _yarp.RpcClient_write(self, data1, data2)

# Register RpcClient in _yarp:
_yarp.RpcClient_swigregister(RpcClient)

class DummyConnector(object):
    r"""Proxy of C++ yarp::os::DummyConnector class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        r"""__init__(DummyConnector self) -> DummyConnector"""
        _yarp.DummyConnector_swiginit(self, _yarp.new_DummyConnector())
    __swig_destroy__ = _yarp.delete_DummyConnector

    def setTextMode(self, textmode):
        r"""setTextMode(DummyConnector self, bool textmode)"""
        return _yarp.DummyConnector_setTextMode(self, textmode)

    def getCleanWriter(self):
        r"""getCleanWriter(DummyConnector self) -> ConnectionWriter"""
        return _yarp.DummyConnector_getCleanWriter(self)

    def getWriter(self):
        r"""getWriter(DummyConnector self) -> ConnectionWriter"""
        return _yarp.DummyConnector_getWriter(self)

    def getReader(self, replyWriter=None):
        r"""getReader(DummyConnector self, ConnectionWriter replyWriter=None) -> ConnectionReader"""
        return _yarp.DummyConnector_getReader(self, replyWriter)

    def reset(self):
        r"""reset(DummyConnector self)"""
        return _yarp.DummyConnector_reset(self)

# Register DummyConnector in _yarp:
_yarp.DummyConnector_swigregister(DummyConnector)

class Things(object):
    r"""Proxy of C++ yarp::os::Things class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        r"""__init__(Things self) -> Things"""
        _yarp.Things_swiginit(self, _yarp.new_Things())
    __swig_destroy__ = _yarp.delete_Things

    def setPortWriter(self, writer):
        r"""setPortWriter(Things self, PortWriter writer)"""
        return _yarp.Things_setPortWriter(self, writer)

    def getPortWriter(self):
        r"""getPortWriter(Things self) -> PortWriter"""
        return _yarp.Things_getPortWriter(self)

    def setPortReader(self, reader):
        r"""setPortReader(Things self, PortReader reader)"""
        return _yarp.Things_setPortReader(self, reader)

    def getPortReader(self):
        r"""getPortReader(Things self) -> PortReader"""
        return _yarp.Things_getPortReader(self)

    def setConnectionReader(self, reader):
        r"""setConnectionReader(Things self, ConnectionReader reader) -> bool"""
        return _yarp.Things_setConnectionReader(self, reader)

    def write(self, connection):
        r"""write(Things self, ConnectionWriter connection) -> bool"""
        return _yarp.Things_write(self, connection)

    def reset(self):
        r"""reset(Things self)"""
        return _yarp.Things_reset(self)

    def hasBeenRead(self):
        r"""hasBeenRead(Things self) -> bool"""
        return _yarp.Things_hasBeenRead(self)

    def asValue(self):
        r"""asValue(Things self) -> Value"""
        return _yarp.Things_asValue(self)

    def asBottle(self):
        r"""asBottle(Things self) -> Bottle"""
        return _yarp.Things_asBottle(self)

    def asProperty(self):
        r"""asProperty(Things self) -> Property"""
        return _yarp.Things_asProperty(self)

    def asVector(self):
        r"""asVector(Things self) -> Vector"""
        return _yarp.Things_asVector(self)

    def asMatrix(self):
        r"""asMatrix(Things self) -> Matrix"""
        return _yarp.Things_asMatrix(self)

    def asImage(self):
        r"""asImage(Things self) -> Image"""
        return _yarp.Things_asImage(self)

    def asImageOfPixelRgb(self):
        r"""asImageOfPixelRgb(Things self) -> ImageRgb"""
        return _yarp.Things_asImageOfPixelRgb(self)

    def asImageOfPixelBgr(self):
        r"""asImageOfPixelBgr(Things self) -> yarp::sig::ImageOf< yarp::sig::PixelBgr > *"""
        return _yarp.Things_asImageOfPixelBgr(self)

    def asImageOfPixelMono(self):
        r"""asImageOfPixelMono(Things self) -> ImageMono"""
        return _yarp.Things_asImageOfPixelMono(self)

# Register Things in _yarp:
_yarp.Things_swigregister(Things)

class QosStyle(object):
    r"""Proxy of C++ yarp::os::QosStyle class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    PacketPriorityInvalid = _yarp.QosStyle_PacketPriorityInvalid
    
    PacketPriorityNormal = _yarp.QosStyle_PacketPriorityNormal
    
    PacketPriorityLow = _yarp.QosStyle_PacketPriorityLow
    
    PacketPriorityHigh = _yarp.QosStyle_PacketPriorityHigh
    
    PacketPriorityCritical = _yarp.QosStyle_PacketPriorityCritical
    
    PacketPriorityUndefined = _yarp.QosStyle_PacketPriorityUndefined
    
    DSCP_Invalid = _yarp.QosStyle_DSCP_Invalid
    
    DSCP_CS0 = _yarp.QosStyle_DSCP_CS0
    
    DSCP_CS1 = _yarp.QosStyle_DSCP_CS1
    
    DSCP_CS2 = _yarp.QosStyle_DSCP_CS2
    
    DSCP_CS3 = _yarp.QosStyle_DSCP_CS3
    
    DSCP_CS4 = _yarp.QosStyle_DSCP_CS4
    
    DSCP_CS5 = _yarp.QosStyle_DSCP_CS5
    
    DSCP_CS6 = _yarp.QosStyle_DSCP_CS6
    
    DSCP_CS7 = _yarp.QosStyle_DSCP_CS7
    
    DSCP_AF11 = _yarp.QosStyle_DSCP_AF11
    
    DSCP_AF12 = _yarp.QosStyle_DSCP_AF12
    
    DSCP_AF13 = _yarp.QosStyle_DSCP_AF13
    
    DSCP_AF21 = _yarp.QosStyle_DSCP_AF21
    
    DSCP_AF22 = _yarp.QosStyle_DSCP_AF22
    
    DSCP_AF23 = _yarp.QosStyle_DSCP_AF23
    
    DSCP_AF31 = _yarp.QosStyle_DSCP_AF31
    
    DSCP_AF32 = _yarp.QosStyle_DSCP_AF32
    
    DSCP_AF33 = _yarp.QosStyle_DSCP_AF33
    
    DSCP_AF41 = _yarp.QosStyle_DSCP_AF41
    
    DSCP_AF42 = _yarp.QosStyle_DSCP_AF42
    
    DSCP_AF43 = _yarp.QosStyle_DSCP_AF43
    
    DSCP_VA = _yarp.QosStyle_DSCP_VA
    
    DSCP_EF = _yarp.QosStyle_DSCP_EF
    
    DSCP_Undefined = _yarp.QosStyle_DSCP_Undefined
    

    def __init__(self):
        r"""__init__(QosStyle self) -> QosStyle"""
        _yarp.QosStyle_swiginit(self, _yarp.new_QosStyle())

    def setPacketPriorityByDscp(self, dscp):
        r"""setPacketPriorityByDscp(QosStyle self, yarp::os::QosStyle::PacketPriorityDSCP dscp)"""
        return _yarp.QosStyle_setPacketPriorityByDscp(self, dscp)

    def setPacketPriorityByLevel(self, level):
        r"""setPacketPriorityByLevel(QosStyle self, yarp::os::QosStyle::PacketPriorityLevel level)"""
        return _yarp.QosStyle_setPacketPriorityByLevel(self, level)

    def setPacketPrioritybyTOS(self, tos):
        r"""setPacketPrioritybyTOS(QosStyle self, int tos)"""
        return _yarp.QosStyle_setPacketPrioritybyTOS(self, tos)

    def setPacketPriority(self, priority):
        r"""setPacketPriority(QosStyle self, std::string const & priority) -> bool"""
        return _yarp.QosStyle_setPacketPriority(self, priority)

    def setThreadPriority(self, priority):
        r"""setThreadPriority(QosStyle self, int priority)"""
        return _yarp.QosStyle_setThreadPriority(self, priority)

    def setThreadPolicy(self, policy):
        r"""setThreadPolicy(QosStyle self, int policy)"""
        return _yarp.QosStyle_setThreadPolicy(self, policy)

    def getPacketPriorityAsTOS(self):
        r"""getPacketPriorityAsTOS(QosStyle self) -> int"""
        return _yarp.QosStyle_getPacketPriorityAsTOS(self)

    def getPacketPriorityAsDSCP(self):
        r"""getPacketPriorityAsDSCP(QosStyle self) -> yarp::os::QosStyle::PacketPriorityDSCP"""
        return _yarp.QosStyle_getPacketPriorityAsDSCP(self)

    def getPacketPriorityAsLevel(self):
        r"""getPacketPriorityAsLevel(QosStyle self) -> yarp::os::QosStyle::PacketPriorityLevel"""
        return _yarp.QosStyle_getPacketPriorityAsLevel(self)

    def getThreadPriority(self):
        r"""getThreadPriority(QosStyle self) -> int"""
        return _yarp.QosStyle_getThreadPriority(self)

    def getThreadPolicy(self):
        r"""getThreadPolicy(QosStyle self) -> int"""
        return _yarp.QosStyle_getThreadPolicy(self)

    @staticmethod
    def getDSCPByVocab(vocab):
        r"""getDSCPByVocab(yarp::conf::vocab32_t vocab) -> yarp::os::QosStyle::PacketPriorityDSCP"""
        return _yarp.QosStyle_getDSCPByVocab(vocab)

    @staticmethod
    def getLevelByVocab(vocab):
        r"""getLevelByVocab(yarp::conf::vocab32_t vocab) -> yarp::os::QosStyle::PacketPriorityLevel"""
        return _yarp.QosStyle_getLevelByVocab(vocab)
    __swig_destroy__ = _yarp.delete_QosStyle

# Register QosStyle in _yarp:
_yarp.QosStyle_swigregister(QosStyle)

def QosStyle_getDSCPByVocab(vocab):
    r"""QosStyle_getDSCPByVocab(yarp::conf::vocab32_t vocab) -> yarp::os::QosStyle::PacketPriorityDSCP"""
    return _yarp.QosStyle_getDSCPByVocab(vocab)

def QosStyle_getLevelByVocab(vocab):
    r"""QosStyle_getLevelByVocab(yarp::conf::vocab32_t vocab) -> yarp::os::QosStyle::PacketPriorityLevel"""
    return _yarp.QosStyle_getLevelByVocab(vocab)

class Log(object):
    r"""Proxy of C++ yarp::os::Log class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        __init__(Log self, char const * file, unsigned int const line, char const * func, yarp::os::Log::Predicate const pred=None, yarp::os::LogComponent const & comp=defaultLogComponent()) -> Log
        __init__(Log self, char const * file, unsigned int const line, char const * func, double const externaltime, yarp::os::Log::Predicate const pred=None, yarp::os::LogComponent const & comp=defaultLogComponent()) -> Log
        __init__(Log self) -> Log
        """
        _yarp.Log_swiginit(self, _yarp.new_Log(*args))
    __swig_destroy__ = _yarp.delete_Log
    LogTypeUnknown = _yarp.Log_LogTypeUnknown
    
    TraceType = _yarp.Log_TraceType
    
    DebugType = _yarp.Log_DebugType
    
    InfoType = _yarp.Log_InfoType
    
    WarningType = _yarp.Log_WarningType
    
    ErrorType = _yarp.Log_ErrorType
    
    FatalType = _yarp.Log_FatalType
    
    LogTypeReserved = _yarp.Log_LogTypeReserved
    

    def trace(self, *args):
        r"""
        trace(Log self, char const * msg)
        trace(Log self) -> LogStream
        """
        return _yarp.Log_trace(self, *args)

    def debug(self, *args):
        r"""
        debug(Log self, char const * msg)
        debug(Log self) -> LogStream
        """
        return _yarp.Log_debug(self, *args)

    def info(self, *args):
        r"""
        info(Log self, char const * msg)
        info(Log self) -> LogStream
        """
        return _yarp.Log_info(self, *args)

    def warning(self, *args):
        r"""
        warning(Log self, char const * msg)
        warning(Log self) -> LogStream
        """
        return _yarp.Log_warning(self, *args)

    def error(self, *args):
        r"""
        error(Log self, char const * msg)
        error(Log self) -> LogStream
        """
        return _yarp.Log_error(self, *args)

    def fatal(self, *args):
        r"""
        fatal(Log self, char const * msg)
        fatal(Log self) -> LogStream
        """
        return _yarp.Log_fatal(self, *args)

    @staticmethod
    def setLogCallback(arg1):
        r"""setLogCallback(yarp::os::Log::LogCallback arg1)"""
        return _yarp.Log_setLogCallback(arg1)

    @staticmethod
    def setMinimumPrintLevel(level):
        r"""setMinimumPrintLevel(yarp::os::Log::LogType level)"""
        return _yarp.Log_setMinimumPrintLevel(level)

    @staticmethod
    def minimumPrintLevel():
        r"""minimumPrintLevel() -> yarp::os::Log::LogType"""
        return _yarp.Log_minimumPrintLevel()

    @staticmethod
    def defaultMinimumPrintLevel():
        r"""defaultMinimumPrintLevel() -> yarp::os::Log::LogType"""
        return _yarp.Log_defaultMinimumPrintLevel()

    @staticmethod
    def setMinimumForwardLevel(level):
        r"""setMinimumForwardLevel(yarp::os::Log::LogType level)"""
        return _yarp.Log_setMinimumForwardLevel(level)

    @staticmethod
    def minimumForwardLevel():
        r"""minimumForwardLevel() -> yarp::os::Log::LogType"""
        return _yarp.Log_minimumForwardLevel()

    @staticmethod
    def defaultMinimumForwardLevel():
        r"""defaultMinimumForwardLevel() -> yarp::os::Log::LogType"""
        return _yarp.Log_defaultMinimumForwardLevel()

    @staticmethod
    def setPrintCallback(arg1):
        r"""setPrintCallback(yarp::os::Log::LogCallback arg1)"""
        return _yarp.Log_setPrintCallback(arg1)

    @staticmethod
    def printCallback():
        r"""printCallback() -> yarp::os::Log::LogCallback"""
        return _yarp.Log_printCallback()

    @staticmethod
    def defaultPrintCallback():
        r"""defaultPrintCallback() -> yarp::os::Log::LogCallback"""
        return _yarp.Log_defaultPrintCallback()

    @staticmethod
    def setForwardCallback(arg1):
        r"""setForwardCallback(yarp::os::Log::LogCallback arg1)"""
        return _yarp.Log_setForwardCallback(arg1)

    @staticmethod
    def forwardCallback():
        r"""forwardCallback() -> yarp::os::Log::LogCallback"""
        return _yarp.Log_forwardCallback()

    @staticmethod
    def defaultForwardCallback():
        r"""defaultForwardCallback() -> yarp::os::Log::LogCallback"""
        return _yarp.Log_defaultForwardCallback()

    @staticmethod
    def nolog(*args):
        r"""
        nolog(char const * msg)
        nolog() -> yarp::os::Log::NoLog
        """
        return _yarp.Log_nolog(*args)

# Register Log in _yarp:
_yarp.Log_swigregister(Log)

def Log_setLogCallback(arg1):
    r"""Log_setLogCallback(yarp::os::Log::LogCallback arg1)"""
    return _yarp.Log_setLogCallback(arg1)

def Log_setMinimumPrintLevel(level):
    r"""Log_setMinimumPrintLevel(yarp::os::Log::LogType level)"""
    return _yarp.Log_setMinimumPrintLevel(level)

def Log_minimumPrintLevel():
    r"""Log_minimumPrintLevel() -> yarp::os::Log::LogType"""
    return _yarp.Log_minimumPrintLevel()

def Log_defaultMinimumPrintLevel():
    r"""Log_defaultMinimumPrintLevel() -> yarp::os::Log::LogType"""
    return _yarp.Log_defaultMinimumPrintLevel()

def Log_setMinimumForwardLevel(level):
    r"""Log_setMinimumForwardLevel(yarp::os::Log::LogType level)"""
    return _yarp.Log_setMinimumForwardLevel(level)

def Log_minimumForwardLevel():
    r"""Log_minimumForwardLevel() -> yarp::os::Log::LogType"""
    return _yarp.Log_minimumForwardLevel()

def Log_defaultMinimumForwardLevel():
    r"""Log_defaultMinimumForwardLevel() -> yarp::os::Log::LogType"""
    return _yarp.Log_defaultMinimumForwardLevel()

def Log_setPrintCallback(arg1):
    r"""Log_setPrintCallback(yarp::os::Log::LogCallback arg1)"""
    return _yarp.Log_setPrintCallback(arg1)

def Log_printCallback():
    r"""Log_printCallback() -> yarp::os::Log::LogCallback"""
    return _yarp.Log_printCallback()

def Log_defaultPrintCallback():
    r"""Log_defaultPrintCallback() -> yarp::os::Log::LogCallback"""
    return _yarp.Log_defaultPrintCallback()

def Log_setForwardCallback(arg1):
    r"""Log_setForwardCallback(yarp::os::Log::LogCallback arg1)"""
    return _yarp.Log_setForwardCallback(arg1)

def Log_forwardCallback():
    r"""Log_forwardCallback() -> yarp::os::Log::LogCallback"""
    return _yarp.Log_forwardCallback()

def Log_defaultForwardCallback():
    r"""Log_defaultForwardCallback() -> yarp::os::Log::LogCallback"""
    return _yarp.Log_defaultForwardCallback()

def Log_nolog(*args):
    r"""
    Log_nolog(char const * msg)
    Log_nolog() -> yarp::os::Log::NoLog
    """
    return _yarp.Log_nolog(*args)


def yarp_print_trace(out, file, line):
    r"""yarp_print_trace(FILE * out, char const * file, unsigned int line)"""
    return _yarp.yarp_print_trace(out, file, line)
class LogStream(object):
    r"""Proxy of C++ yarp::os::LogStream class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        __init__(LogStream self, yarp::os::Log::LogType type, char const * file, unsigned int line, char const * func, double const externaltime, yarp::os::Log::Predicate const pred=None, yarp::os::LogComponent const & comp=yarp::os::Log::defaultLogComponent()) -> LogStream
        __init__(LogStream self, LogStream o) -> LogStream
        """
        _yarp.LogStream_swiginit(self, _yarp.new_LogStream(*args))
    __swig_destroy__ = _yarp.delete_LogStream

    def __lshift__(self, *args):
        r"""
        __lshift__(LogStream self, bool t) -> LogStream
        __lshift__(LogStream self, char t) -> LogStream
        __lshift__(LogStream self, short t) -> LogStream
        __lshift__(LogStream self, unsigned short t) -> LogStream
        __lshift__(LogStream self, int t) -> LogStream
        __lshift__(LogStream self, unsigned int t) -> LogStream
        __lshift__(LogStream self, long t) -> LogStream
        __lshift__(LogStream self, unsigned long t) -> LogStream
        __lshift__(LogStream self, long long t) -> LogStream
        __lshift__(LogStream self, unsigned long long t) -> LogStream
        __lshift__(LogStream self, float t) -> LogStream
        __lshift__(LogStream self, double t) -> LogStream
        __lshift__(LogStream self, char const * t) -> LogStream
        __lshift__(LogStream self, void const * t) -> LogStream
        __lshift__(LogStream self, std::string const & t) -> LogStream
        """
        return _yarp.LogStream___lshift__(self, *args)

# Register LogStream in _yarp:
_yarp.LogStream_swigregister(LogStream)

class Wire(PortReader):
    r"""Proxy of C++ yarp::os::Wire class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def yarp(self, *args):
        r"""
        yarp(Wire self) -> WireLink
        yarp(Wire self) -> WireLink
        """
        return _yarp.Wire_yarp(self, *args)
    __swig_destroy__ = _yarp.delete_Wire

# Register Wire in _yarp:
_yarp.Wire_swigregister(Wire)

class WireLink(object):
    r"""Proxy of C++ yarp::os::WireLink class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        r"""__init__(WireLink self) -> WireLink"""
        _yarp.WireLink_swiginit(self, _yarp.new_WireLink())
    __swig_destroy__ = _yarp.delete_WireLink

    def isValid(self):
        r"""isValid(WireLink self) -> bool"""
        return _yarp.WireLink_isValid(self)

    def setOwner(self, owner):
        r"""setOwner(WireLink self, PortReader owner) -> bool"""
        return _yarp.WireLink_setOwner(self, owner)

    def attachAsClient(self, *args):
        r"""
        attachAsClient(WireLink self, UnbufferedContactable port) -> bool
        attachAsClient(WireLink self, PortReader reader) -> bool
        """
        return _yarp.WireLink_attachAsClient(self, *args)

    def attachAsServer(self, port):
        r"""attachAsServer(WireLink self, UnbufferedContactable port) -> bool"""
        return _yarp.WireLink_attachAsServer(self, port)

    def setStreamingMode(self, streaming):
        r"""setStreamingMode(WireLink self, bool streaming) -> bool"""
        return _yarp.WireLink_setStreamingMode(self, streaming)

    def write(self, *args):
        r"""
        write(WireLink self, PortWriter writer) -> bool
        write(WireLink self, PortWriter writer, PortReader reader) -> bool
        """
        return _yarp.WireLink_write(self, *args)

    def callback(self, *args):
        r"""callback(WireLink self, PortWriter writer, PortReader reader, std::string const & tag="") -> bool"""
        return _yarp.WireLink_callback(self, *args)

    def canWrite(self):
        r"""canWrite(WireLink self) -> bool"""
        return _yarp.WireLink_canWrite(self)

    def canRead(self):
        r"""canRead(WireLink self) -> bool"""
        return _yarp.WireLink_canRead(self)

# Register WireLink in _yarp:
_yarp.WireLink_swigregister(WireLink)

class RateThread(object):
    r"""Proxy of C++ yarp::os::RateThread class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _yarp.delete_RateThread

    def start(self):
        r"""start(RateThread self) -> bool"""
        return _yarp.RateThread_start(self)

    def step(self):
        r"""step(RateThread self) -> bool"""
        return _yarp.RateThread_step(self)

    def stop(self):
        r"""stop(RateThread self)"""
        return _yarp.RateThread_stop(self)

    def askToStop(self):
        r"""askToStop(RateThread self)"""
        return _yarp.RateThread_askToStop(self)

    def isRunning(self):
        r"""isRunning(RateThread self) -> bool"""
        return _yarp.RateThread_isRunning(self)

    def isSuspended(self):
        r"""isSuspended(RateThread self) -> bool"""
        return _yarp.RateThread_isSuspended(self)

    def setRate(self, period):
        r"""setRate(RateThread self, int period) -> bool"""
        return _yarp.RateThread_setRate(self, period)

    def getRate(self):
        r"""getRate(RateThread self) -> double"""
        return _yarp.RateThread_getRate(self)

    def suspend(self):
        r"""suspend(RateThread self)"""
        return _yarp.RateThread_suspend(self)

    def resume(self):
        r"""resume(RateThread self)"""
        return _yarp.RateThread_resume(self)

    def resetStat(self):
        r"""resetStat(RateThread self)"""
        return _yarp.RateThread_resetStat(self)

    def getEstPeriod(self, *args):
        r"""
        getEstPeriod(RateThread self) -> double
        getEstPeriod(RateThread self, double & av, double & std)
        """
        return _yarp.RateThread_getEstPeriod(self, *args)

    def getIterations(self):
        r"""getIterations(RateThread self) -> unsigned int"""
        return _yarp.RateThread_getIterations(self)

    def getEstUsed(self, *args):
        r"""
        getEstUsed(RateThread self) -> double
        getEstUsed(RateThread self, double & av, double & std)
        """
        return _yarp.RateThread_getEstUsed(self, *args)

    def setPriority(self, priority, policy=-1):
        r"""setPriority(RateThread self, int priority, int policy=-1) -> int"""
        return _yarp.RateThread_setPriority(self, priority, policy)

    def getPriority(self):
        r"""getPriority(RateThread self) -> int"""
        return _yarp.RateThread_getPriority(self)

    def getPolicy(self):
        r"""getPolicy(RateThread self) -> int"""
        return _yarp.RateThread_getPolicy(self)

# Register RateThread in _yarp:
_yarp.RateThread_swigregister(RateThread)

class SystemRateThread(PeriodicThread):
    r"""Proxy of C++ yarp::os::SystemRateThread class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _yarp.delete_SystemRateThread

    def stepSystem(self):
        r"""stepSystem(SystemRateThread self) -> bool"""
        return _yarp.SystemRateThread_stepSystem(self)

# Register SystemRateThread in _yarp:
_yarp.SystemRateThread_swigregister(SystemRateThread)

class RateThreadWrapper(PeriodicThread):
    r"""Proxy of C++ yarp::os::RateThreadWrapper class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        __init__(RateThreadWrapper self) -> RateThreadWrapper
        __init__(RateThreadWrapper self, Runnable * helper) -> RateThreadWrapper
        __init__(RateThreadWrapper self, Runnable & helper) -> RateThreadWrapper
        """
        _yarp.RateThreadWrapper_swiginit(self, _yarp.new_RateThreadWrapper(*args))
    __swig_destroy__ = _yarp.delete_RateThreadWrapper

    def detach(self):
        r"""detach(RateThreadWrapper self)"""
        return _yarp.RateThreadWrapper_detach(self)

    def attach(self, *args):
        r"""
        attach(RateThreadWrapper self, Runnable & helper) -> bool
        attach(RateThreadWrapper self, Runnable * helper) -> bool
        """
        return _yarp.RateThreadWrapper_attach(self, *args)

    def open(self, framerate=-1, polling=False):
        r"""open(RateThreadWrapper self, double framerate=-1, bool polling=False) -> bool"""
        return _yarp.RateThreadWrapper_open(self, framerate, polling)

    def close(self):
        r"""close(RateThreadWrapper self)"""
        return _yarp.RateThreadWrapper_close(self)

    def stop(self):
        r"""stop(RateThreadWrapper self)"""
        return _yarp.RateThreadWrapper_stop(self)

    def run(self):
        r"""run(RateThreadWrapper self)"""
        return _yarp.RateThreadWrapper_run(self)

    def threadInit(self):
        r"""threadInit(RateThreadWrapper self) -> bool"""
        return _yarp.RateThreadWrapper_threadInit(self)

    def threadRelease(self):
        r"""threadRelease(RateThreadWrapper self)"""
        return _yarp.RateThreadWrapper_threadRelease(self)

    def afterStart(self, success):
        r"""afterStart(RateThreadWrapper self, bool success)"""
        return _yarp.RateThreadWrapper_afterStart(self, success)

    def beforeStart(self):
        r"""beforeStart(RateThreadWrapper self)"""
        return _yarp.RateThreadWrapper_beforeStart(self)

    def getAttachment(self):
        r"""getAttachment(RateThreadWrapper self) -> Runnable *"""
        return _yarp.RateThreadWrapper_getAttachment(self)

# Register RateThreadWrapper in _yarp:
_yarp.RateThreadWrapper_swigregister(RateThreadWrapper)

class TypedReaderProperty(object):
    r"""Proxy of C++ yarp::os::TypedReader< Property > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def setStrict(self, strict=True):
        r"""setStrict(TypedReaderProperty self, bool strict=True)"""
        return _yarp.TypedReaderProperty_setStrict(self, strict)

    def read(self, shouldWait=True):
        r"""read(TypedReaderProperty self, bool shouldWait=True) -> Property"""
        return _yarp.TypedReaderProperty_read(self, shouldWait)

    def interrupt(self):
        r"""interrupt(TypedReaderProperty self)"""
        return _yarp.TypedReaderProperty_interrupt(self)

    def lastRead(self):
        r"""lastRead(TypedReaderProperty self) -> Property"""
        return _yarp.TypedReaderProperty_lastRead(self)

    def isClosed(self):
        r"""isClosed(TypedReaderProperty self) -> bool"""
        return _yarp.TypedReaderProperty_isClosed(self)

    def useCallback(self, callback):
        r"""useCallback(TypedReaderProperty self, PropertyCallback callback)"""
        return _yarp.TypedReaderProperty_useCallback(self, callback)

    def disableCallback(self):
        r"""disableCallback(TypedReaderProperty self)"""
        return _yarp.TypedReaderProperty_disableCallback(self)

    def getPendingReads(self):
        r"""getPendingReads(TypedReaderProperty self) -> int"""
        return _yarp.TypedReaderProperty_getPendingReads(self)
    __swig_destroy__ = _yarp.delete_TypedReaderProperty

    def getName(self):
        r"""getName(TypedReaderProperty self) -> std::string"""
        return _yarp.TypedReaderProperty_getName(self)

    def setReplier(self, reader):
        r"""setReplier(TypedReaderProperty self, PortReader reader)"""
        return _yarp.TypedReaderProperty_setReplier(self, reader)

    def acquire(self):
        r"""acquire(TypedReaderProperty self) -> void *"""
        return _yarp.TypedReaderProperty_acquire(self)

    def release(self, handle):
        r"""release(TypedReaderProperty self, void * handle)"""
        return _yarp.TypedReaderProperty_release(self, handle)

    def setTargetPeriod(self, period):
        r"""setTargetPeriod(TypedReaderProperty self, double period)"""
        return _yarp.TypedReaderProperty_setTargetPeriod(self, period)

# Register TypedReaderProperty in _yarp:
_yarp.TypedReaderProperty_swigregister(TypedReaderProperty)

class PropertyCallback(object):
    r"""Proxy of C++ yarp::os::TypedReaderCallback< Property > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _yarp.delete_PropertyCallback

    def onRead(self, *args):
        r"""
        onRead(PropertyCallback self, Property datum)
        onRead(PropertyCallback self, Property datum, TypedReaderProperty reader)
        """
        return _yarp.PropertyCallback_onRead(self, *args)

    def __init__(self):
        r"""__init__(PropertyCallback self) -> PropertyCallback"""
        if self.__class__ == PropertyCallback:
            _self = None
        else:
            _self = self
        _yarp.PropertyCallback_swiginit(self, _yarp.new_PropertyCallback(_self, ))
    def __disown__(self):
        self.this.disown()
        _yarp.disown_PropertyCallback(self)
        return weakref.proxy(self)

# Register PropertyCallback in _yarp:
_yarp.PropertyCallback_swigregister(PropertyCallback)

class BufferedPortProperty(Contactable, TypedReaderProperty, PropertyCallback):
    r"""Proxy of C++ yarp::os::BufferedPort< Property > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        __init__(BufferedPortProperty self) -> BufferedPortProperty
        __init__(BufferedPortProperty self, Port port) -> BufferedPortProperty
        """
        _yarp.BufferedPortProperty_swiginit(self, _yarp.new_BufferedPortProperty(*args))
    __swig_destroy__ = _yarp.delete_BufferedPortProperty

    def addOutput(self, *args):
        r"""
        addOutput(BufferedPortProperty self, std::string const & name) -> bool
        addOutput(BufferedPortProperty self, std::string const & name, std::string const & carrier) -> bool
        addOutput(BufferedPortProperty self, Contact contact) -> bool
        """
        return _yarp.BufferedPortProperty_addOutput(self, *args)

    def close(self):
        r"""close(BufferedPortProperty self)"""
        return _yarp.BufferedPortProperty_close(self)

    def interrupt(self):
        r"""interrupt(BufferedPortProperty self)"""
        return _yarp.BufferedPortProperty_interrupt(self)

    def resume(self):
        r"""resume(BufferedPortProperty self)"""
        return _yarp.BufferedPortProperty_resume(self)

    def getPendingReads(self):
        r"""getPendingReads(BufferedPortProperty self) -> int"""
        return _yarp.BufferedPortProperty_getPendingReads(self)

    def where(self):
        r"""where(BufferedPortProperty self) -> Contact"""
        return _yarp.BufferedPortProperty_where(self)

    def getName(self):
        r"""getName(BufferedPortProperty self) -> std::string"""
        return _yarp.BufferedPortProperty_getName(self)

    def prepare(self):
        r"""prepare(BufferedPortProperty self) -> Property"""
        return _yarp.BufferedPortProperty_prepare(self)

    def unprepare(self):
        r"""unprepare(BufferedPortProperty self) -> bool"""
        return _yarp.BufferedPortProperty_unprepare(self)

    def write(self, forceStrict=False):
        r"""write(BufferedPortProperty self, bool forceStrict=False)"""
        return _yarp.BufferedPortProperty_write(self, forceStrict)

    def writeStrict(self):
        r"""writeStrict(BufferedPortProperty self)"""
        return _yarp.BufferedPortProperty_writeStrict(self)

    def waitForWrite(self):
        r"""waitForWrite(BufferedPortProperty self)"""
        return _yarp.BufferedPortProperty_waitForWrite(self)

    def setStrict(self, strict=True):
        r"""setStrict(BufferedPortProperty self, bool strict=True)"""
        return _yarp.BufferedPortProperty_setStrict(self, strict)

    def read(self, shouldWait=True):
        r"""read(BufferedPortProperty self, bool shouldWait=True) -> Property"""
        return _yarp.BufferedPortProperty_read(self, shouldWait)

    def lastRead(self):
        r"""lastRead(BufferedPortProperty self) -> Property"""
        return _yarp.BufferedPortProperty_lastRead(self)

    def isClosed(self):
        r"""isClosed(BufferedPortProperty self) -> bool"""
        return _yarp.BufferedPortProperty_isClosed(self)

    def setReplier(self, reader):
        r"""setReplier(BufferedPortProperty self, PortReader reader)"""
        return _yarp.BufferedPortProperty_setReplier(self, reader)

    def setReader(self, reader):
        r"""setReader(BufferedPortProperty self, PortReader reader)"""
        return _yarp.BufferedPortProperty_setReader(self, reader)

    def setAdminReader(self, reader):
        r"""setAdminReader(BufferedPortProperty self, PortReader reader)"""
        return _yarp.BufferedPortProperty_setAdminReader(self, reader)

    def onRead(self, *args):
        r"""
        onRead(BufferedPortProperty self, Property datum, TypedReaderProperty reader)
        onRead(BufferedPortProperty self, Property datum)
        """
        return _yarp.BufferedPortProperty_onRead(self, *args)

    def useCallback(self, *args):
        r"""
        useCallback(BufferedPortProperty self, PropertyCallback callback)
        useCallback(BufferedPortProperty self)
        """
        return _yarp.BufferedPortProperty_useCallback(self, *args)

    def disableCallback(self):
        r"""disableCallback(BufferedPortProperty self)"""
        return _yarp.BufferedPortProperty_disableCallback(self)

    def setEnvelope(self, envelope):
        r"""setEnvelope(BufferedPortProperty self, PortWriter envelope) -> bool"""
        return _yarp.BufferedPortProperty_setEnvelope(self, envelope)

    def getEnvelope(self, envelope):
        r"""getEnvelope(BufferedPortProperty self, PortReader envelope) -> bool"""
        return _yarp.BufferedPortProperty_getEnvelope(self, envelope)

    def getInputCount(self):
        r"""getInputCount(BufferedPortProperty self) -> int"""
        return _yarp.BufferedPortProperty_getInputCount(self)

    def getOutputCount(self):
        r"""getOutputCount(BufferedPortProperty self) -> int"""
        return _yarp.BufferedPortProperty_getOutputCount(self)

    def isWriting(self):
        r"""isWriting(BufferedPortProperty self) -> bool"""
        return _yarp.BufferedPortProperty_isWriting(self)

    def getReport(self, reporter):
        r"""getReport(BufferedPortProperty self, PortReport reporter)"""
        return _yarp.BufferedPortProperty_getReport(self, reporter)

    def setReporter(self, reporter):
        r"""setReporter(BufferedPortProperty self, PortReport reporter)"""
        return _yarp.BufferedPortProperty_setReporter(self, reporter)

    def resetReporter(self):
        r"""resetReporter(BufferedPortProperty self)"""
        return _yarp.BufferedPortProperty_resetReporter(self)

    def acquire(self):
        r"""acquire(BufferedPortProperty self) -> void *"""
        return _yarp.BufferedPortProperty_acquire(self)

    def release(self, handle):
        r"""release(BufferedPortProperty self, void * handle)"""
        return _yarp.BufferedPortProperty_release(self, handle)

    def setTargetPeriod(self, period):
        r"""setTargetPeriod(BufferedPortProperty self, double period)"""
        return _yarp.BufferedPortProperty_setTargetPeriod(self, period)

    def getType(self):
        r"""getType(BufferedPortProperty self) -> yarp::os::Type"""
        return _yarp.BufferedPortProperty_getType(self)

    def promiseType(self, typ):
        r"""promiseType(BufferedPortProperty self, yarp::os::Type const & typ)"""
        return _yarp.BufferedPortProperty_promiseType(self, typ)

    def setInputMode(self, expectInput):
        r"""setInputMode(BufferedPortProperty self, bool expectInput)"""
        return _yarp.BufferedPortProperty_setInputMode(self, expectInput)

    def setOutputMode(self, expectOutput):
        r"""setOutputMode(BufferedPortProperty self, bool expectOutput)"""
        return _yarp.BufferedPortProperty_setOutputMode(self, expectOutput)

    def setRpcMode(self, expectRpc):
        r"""setRpcMode(BufferedPortProperty self, bool expectRpc)"""
        return _yarp.BufferedPortProperty_setRpcMode(self, expectRpc)

    def acquireProperties(self, readOnly):
        r"""acquireProperties(BufferedPortProperty self, bool readOnly) -> Property"""
        return _yarp.BufferedPortProperty_acquireProperties(self, readOnly)

    def releaseProperties(self, prop):
        r"""releaseProperties(BufferedPortProperty self, Property prop)"""
        return _yarp.BufferedPortProperty_releaseProperties(self, prop)

    def includeNodeInName(self, flag):
        r"""includeNodeInName(BufferedPortProperty self, bool flag)"""
        return _yarp.BufferedPortProperty_includeNodeInName(self, flag)

    def setCallbackLock(self, *args):
        r"""
        setCallbackLock(BufferedPortProperty self, yarp::os::Mutex * mutex) -> bool
        setCallbackLock(BufferedPortProperty self, std::mutex * mutex) -> bool
        """
        return _yarp.BufferedPortProperty_setCallbackLock(self, *args)

    def removeCallbackLock(self):
        r"""removeCallbackLock(BufferedPortProperty self) -> bool"""
        return _yarp.BufferedPortProperty_removeCallbackLock(self)

    def lockCallback(self):
        r"""lockCallback(BufferedPortProperty self) -> bool"""
        return _yarp.BufferedPortProperty_lockCallback(self)

    def tryLockCallback(self):
        r"""tryLockCallback(BufferedPortProperty self) -> bool"""
        return _yarp.BufferedPortProperty_tryLockCallback(self)

    def unlockCallback(self):
        r"""unlockCallback(BufferedPortProperty self)"""
        return _yarp.BufferedPortProperty_unlockCallback(self)

# Register BufferedPortProperty in _yarp:
_yarp.BufferedPortProperty_swigregister(BufferedPortProperty)

class TypedReaderBottle(object):
    r"""Proxy of C++ yarp::os::TypedReader< Bottle > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def setStrict(self, strict=True):
        r"""setStrict(TypedReaderBottle self, bool strict=True)"""
        return _yarp.TypedReaderBottle_setStrict(self, strict)

    def read(self, shouldWait=True):
        r"""read(TypedReaderBottle self, bool shouldWait=True) -> Bottle"""
        return _yarp.TypedReaderBottle_read(self, shouldWait)

    def interrupt(self):
        r"""interrupt(TypedReaderBottle self)"""
        return _yarp.TypedReaderBottle_interrupt(self)

    def lastRead(self):
        r"""lastRead(TypedReaderBottle self) -> Bottle"""
        return _yarp.TypedReaderBottle_lastRead(self)

    def isClosed(self):
        r"""isClosed(TypedReaderBottle self) -> bool"""
        return _yarp.TypedReaderBottle_isClosed(self)

    def useCallback(self, callback):
        r"""useCallback(TypedReaderBottle self, BottleCallback callback)"""
        return _yarp.TypedReaderBottle_useCallback(self, callback)

    def disableCallback(self):
        r"""disableCallback(TypedReaderBottle self)"""
        return _yarp.TypedReaderBottle_disableCallback(self)

    def getPendingReads(self):
        r"""getPendingReads(TypedReaderBottle self) -> int"""
        return _yarp.TypedReaderBottle_getPendingReads(self)
    __swig_destroy__ = _yarp.delete_TypedReaderBottle

    def getName(self):
        r"""getName(TypedReaderBottle self) -> std::string"""
        return _yarp.TypedReaderBottle_getName(self)

    def setReplier(self, reader):
        r"""setReplier(TypedReaderBottle self, PortReader reader)"""
        return _yarp.TypedReaderBottle_setReplier(self, reader)

    def acquire(self):
        r"""acquire(TypedReaderBottle self) -> void *"""
        return _yarp.TypedReaderBottle_acquire(self)

    def release(self, handle):
        r"""release(TypedReaderBottle self, void * handle)"""
        return _yarp.TypedReaderBottle_release(self, handle)

    def setTargetPeriod(self, period):
        r"""setTargetPeriod(TypedReaderBottle self, double period)"""
        return _yarp.TypedReaderBottle_setTargetPeriod(self, period)

# Register TypedReaderBottle in _yarp:
_yarp.TypedReaderBottle_swigregister(TypedReaderBottle)

class BottleCallback(object):
    r"""Proxy of C++ yarp::os::TypedReaderCallback< Bottle > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _yarp.delete_BottleCallback

    def onRead(self, *args):
        r"""
        onRead(BottleCallback self, Bottle datum)
        onRead(BottleCallback self, Bottle datum, TypedReaderBottle reader)
        """
        return _yarp.BottleCallback_onRead(self, *args)

    def __init__(self):
        r"""__init__(BottleCallback self) -> BottleCallback"""
        if self.__class__ == BottleCallback:
            _self = None
        else:
            _self = self
        _yarp.BottleCallback_swiginit(self, _yarp.new_BottleCallback(_self, ))
    def __disown__(self):
        self.this.disown()
        _yarp.disown_BottleCallback(self)
        return weakref.proxy(self)

# Register BottleCallback in _yarp:
_yarp.BottleCallback_swigregister(BottleCallback)

class BufferedPortBottle(Contactable, TypedReaderBottle, BottleCallback):
    r"""Proxy of C++ yarp::os::BufferedPort< Bottle > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        __init__(BufferedPortBottle self) -> BufferedPortBottle
        __init__(BufferedPortBottle self, Port port) -> BufferedPortBottle
        """
        _yarp.BufferedPortBottle_swiginit(self, _yarp.new_BufferedPortBottle(*args))
    __swig_destroy__ = _yarp.delete_BufferedPortBottle

    def addOutput(self, *args):
        r"""
        addOutput(BufferedPortBottle self, std::string const & name) -> bool
        addOutput(BufferedPortBottle self, std::string const & name, std::string const & carrier) -> bool
        addOutput(BufferedPortBottle self, Contact contact) -> bool
        """
        return _yarp.BufferedPortBottle_addOutput(self, *args)

    def close(self):
        r"""close(BufferedPortBottle self)"""
        return _yarp.BufferedPortBottle_close(self)

    def interrupt(self):
        r"""interrupt(BufferedPortBottle self)"""
        return _yarp.BufferedPortBottle_interrupt(self)

    def resume(self):
        r"""resume(BufferedPortBottle self)"""
        return _yarp.BufferedPortBottle_resume(self)

    def getPendingReads(self):
        r"""getPendingReads(BufferedPortBottle self) -> int"""
        return _yarp.BufferedPortBottle_getPendingReads(self)

    def where(self):
        r"""where(BufferedPortBottle self) -> Contact"""
        return _yarp.BufferedPortBottle_where(self)

    def getName(self):
        r"""getName(BufferedPortBottle self) -> std::string"""
        return _yarp.BufferedPortBottle_getName(self)

    def prepare(self):
        r"""prepare(BufferedPortBottle self) -> Bottle"""
        return _yarp.BufferedPortBottle_prepare(self)

    def unprepare(self):
        r"""unprepare(BufferedPortBottle self) -> bool"""
        return _yarp.BufferedPortBottle_unprepare(self)

    def write(self, forceStrict=False):
        r"""write(BufferedPortBottle self, bool forceStrict=False)"""
        return _yarp.BufferedPortBottle_write(self, forceStrict)

    def writeStrict(self):
        r"""writeStrict(BufferedPortBottle self)"""
        return _yarp.BufferedPortBottle_writeStrict(self)

    def waitForWrite(self):
        r"""waitForWrite(BufferedPortBottle self)"""
        return _yarp.BufferedPortBottle_waitForWrite(self)

    def setStrict(self, strict=True):
        r"""setStrict(BufferedPortBottle self, bool strict=True)"""
        return _yarp.BufferedPortBottle_setStrict(self, strict)

    def read(self, shouldWait=True):
        r"""read(BufferedPortBottle self, bool shouldWait=True) -> Bottle"""
        return _yarp.BufferedPortBottle_read(self, shouldWait)

    def lastRead(self):
        r"""lastRead(BufferedPortBottle self) -> Bottle"""
        return _yarp.BufferedPortBottle_lastRead(self)

    def isClosed(self):
        r"""isClosed(BufferedPortBottle self) -> bool"""
        return _yarp.BufferedPortBottle_isClosed(self)

    def setReplier(self, reader):
        r"""setReplier(BufferedPortBottle self, PortReader reader)"""
        return _yarp.BufferedPortBottle_setReplier(self, reader)

    def setReader(self, reader):
        r"""setReader(BufferedPortBottle self, PortReader reader)"""
        return _yarp.BufferedPortBottle_setReader(self, reader)

    def setAdminReader(self, reader):
        r"""setAdminReader(BufferedPortBottle self, PortReader reader)"""
        return _yarp.BufferedPortBottle_setAdminReader(self, reader)

    def onRead(self, *args):
        r"""
        onRead(BufferedPortBottle self, Bottle datum, TypedReaderBottle reader)
        onRead(BufferedPortBottle self, Bottle datum)
        """
        return _yarp.BufferedPortBottle_onRead(self, *args)

    def useCallback(self, *args):
        r"""
        useCallback(BufferedPortBottle self, BottleCallback callback)
        useCallback(BufferedPortBottle self)
        """
        return _yarp.BufferedPortBottle_useCallback(self, *args)

    def disableCallback(self):
        r"""disableCallback(BufferedPortBottle self)"""
        return _yarp.BufferedPortBottle_disableCallback(self)

    def setEnvelope(self, envelope):
        r"""setEnvelope(BufferedPortBottle self, PortWriter envelope) -> bool"""
        return _yarp.BufferedPortBottle_setEnvelope(self, envelope)

    def getEnvelope(self, envelope):
        r"""getEnvelope(BufferedPortBottle self, PortReader envelope) -> bool"""
        return _yarp.BufferedPortBottle_getEnvelope(self, envelope)

    def getInputCount(self):
        r"""getInputCount(BufferedPortBottle self) -> int"""
        return _yarp.BufferedPortBottle_getInputCount(self)

    def getOutputCount(self):
        r"""getOutputCount(BufferedPortBottle self) -> int"""
        return _yarp.BufferedPortBottle_getOutputCount(self)

    def isWriting(self):
        r"""isWriting(BufferedPortBottle self) -> bool"""
        return _yarp.BufferedPortBottle_isWriting(self)

    def getReport(self, reporter):
        r"""getReport(BufferedPortBottle self, PortReport reporter)"""
        return _yarp.BufferedPortBottle_getReport(self, reporter)

    def setReporter(self, reporter):
        r"""setReporter(BufferedPortBottle self, PortReport reporter)"""
        return _yarp.BufferedPortBottle_setReporter(self, reporter)

    def resetReporter(self):
        r"""resetReporter(BufferedPortBottle self)"""
        return _yarp.BufferedPortBottle_resetReporter(self)

    def acquire(self):
        r"""acquire(BufferedPortBottle self) -> void *"""
        return _yarp.BufferedPortBottle_acquire(self)

    def release(self, handle):
        r"""release(BufferedPortBottle self, void * handle)"""
        return _yarp.BufferedPortBottle_release(self, handle)

    def setTargetPeriod(self, period):
        r"""setTargetPeriod(BufferedPortBottle self, double period)"""
        return _yarp.BufferedPortBottle_setTargetPeriod(self, period)

    def getType(self):
        r"""getType(BufferedPortBottle self) -> yarp::os::Type"""
        return _yarp.BufferedPortBottle_getType(self)

    def promiseType(self, typ):
        r"""promiseType(BufferedPortBottle self, yarp::os::Type const & typ)"""
        return _yarp.BufferedPortBottle_promiseType(self, typ)

    def setInputMode(self, expectInput):
        r"""setInputMode(BufferedPortBottle self, bool expectInput)"""
        return _yarp.BufferedPortBottle_setInputMode(self, expectInput)

    def setOutputMode(self, expectOutput):
        r"""setOutputMode(BufferedPortBottle self, bool expectOutput)"""
        return _yarp.BufferedPortBottle_setOutputMode(self, expectOutput)

    def setRpcMode(self, expectRpc):
        r"""setRpcMode(BufferedPortBottle self, bool expectRpc)"""
        return _yarp.BufferedPortBottle_setRpcMode(self, expectRpc)

    def acquireProperties(self, readOnly):
        r"""acquireProperties(BufferedPortBottle self, bool readOnly) -> Property"""
        return _yarp.BufferedPortBottle_acquireProperties(self, readOnly)

    def releaseProperties(self, prop):
        r"""releaseProperties(BufferedPortBottle self, Property prop)"""
        return _yarp.BufferedPortBottle_releaseProperties(self, prop)

    def includeNodeInName(self, flag):
        r"""includeNodeInName(BufferedPortBottle self, bool flag)"""
        return _yarp.BufferedPortBottle_includeNodeInName(self, flag)

    def setCallbackLock(self, *args):
        r"""
        setCallbackLock(BufferedPortBottle self, yarp::os::Mutex * mutex) -> bool
        setCallbackLock(BufferedPortBottle self, std::mutex * mutex) -> bool
        """
        return _yarp.BufferedPortBottle_setCallbackLock(self, *args)

    def removeCallbackLock(self):
        r"""removeCallbackLock(BufferedPortBottle self) -> bool"""
        return _yarp.BufferedPortBottle_removeCallbackLock(self)

    def lockCallback(self):
        r"""lockCallback(BufferedPortBottle self) -> bool"""
        return _yarp.BufferedPortBottle_lockCallback(self)

    def tryLockCallback(self):
        r"""tryLockCallback(BufferedPortBottle self) -> bool"""
        return _yarp.BufferedPortBottle_tryLockCallback(self)

    def unlockCallback(self):
        r"""unlockCallback(BufferedPortBottle self)"""
        return _yarp.BufferedPortBottle_unlockCallback(self)

# Register BufferedPortBottle in _yarp:
_yarp.BufferedPortBottle_swigregister(BufferedPortBottle)


def PAD_BYTES(len, pad):
    r"""PAD_BYTES(size_t len, size_t pad) -> size_t"""
    return _yarp.PAD_BYTES(len, pad)
VOCAB_PIXEL_INVALID = _yarp.VOCAB_PIXEL_INVALID

VOCAB_PIXEL_MONO = _yarp.VOCAB_PIXEL_MONO

VOCAB_PIXEL_MONO16 = _yarp.VOCAB_PIXEL_MONO16

VOCAB_PIXEL_RGB = _yarp.VOCAB_PIXEL_RGB

VOCAB_PIXEL_RGBA = _yarp.VOCAB_PIXEL_RGBA

VOCAB_PIXEL_BGRA = _yarp.VOCAB_PIXEL_BGRA

VOCAB_PIXEL_INT = _yarp.VOCAB_PIXEL_INT

VOCAB_PIXEL_HSV = _yarp.VOCAB_PIXEL_HSV

VOCAB_PIXEL_BGR = _yarp.VOCAB_PIXEL_BGR

VOCAB_PIXEL_MONO_SIGNED = _yarp.VOCAB_PIXEL_MONO_SIGNED

VOCAB_PIXEL_RGB_SIGNED = _yarp.VOCAB_PIXEL_RGB_SIGNED

VOCAB_PIXEL_RGB_INT = _yarp.VOCAB_PIXEL_RGB_INT

VOCAB_PIXEL_MONO_FLOAT = _yarp.VOCAB_PIXEL_MONO_FLOAT

VOCAB_PIXEL_RGB_FLOAT = _yarp.VOCAB_PIXEL_RGB_FLOAT

VOCAB_PIXEL_HSV_FLOAT = _yarp.VOCAB_PIXEL_HSV_FLOAT

VOCAB_PIXEL_ENCODING_BAYER_GRBG8 = _yarp.VOCAB_PIXEL_ENCODING_BAYER_GRBG8

VOCAB_PIXEL_ENCODING_BAYER_GRBG16 = _yarp.VOCAB_PIXEL_ENCODING_BAYER_GRBG16

VOCAB_PIXEL_ENCODING_BAYER_BGGR8 = _yarp.VOCAB_PIXEL_ENCODING_BAYER_BGGR8

VOCAB_PIXEL_ENCODING_BAYER_BGGR16 = _yarp.VOCAB_PIXEL_ENCODING_BAYER_BGGR16

VOCAB_PIXEL_ENCODING_BAYER_GBRG8 = _yarp.VOCAB_PIXEL_ENCODING_BAYER_GBRG8

VOCAB_PIXEL_ENCODING_BAYER_GBRG16 = _yarp.VOCAB_PIXEL_ENCODING_BAYER_GBRG16

VOCAB_PIXEL_ENCODING_BAYER_RGGB8 = _yarp.VOCAB_PIXEL_ENCODING_BAYER_RGGB8

VOCAB_PIXEL_ENCODING_BAYER_RGGB16 = _yarp.VOCAB_PIXEL_ENCODING_BAYER_RGGB16

VOCAB_PIXEL_YUV_420 = _yarp.VOCAB_PIXEL_YUV_420

VOCAB_PIXEL_YUV_444 = _yarp.VOCAB_PIXEL_YUV_444

VOCAB_PIXEL_YUV_422 = _yarp.VOCAB_PIXEL_YUV_422

VOCAB_PIXEL_YUV_411 = _yarp.VOCAB_PIXEL_YUV_411

class Image(Portable):
    r"""Proxy of C++ yarp::sig::Image class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        __init__(Image self) -> Image
        __init__(Image self, Image alt) -> Image
        __init__(Image self, Image other) -> Image
        """
        _yarp.Image_swiginit(self, _yarp.new_Image(*args))
    __swig_destroy__ = _yarp.delete_Image

    def copy(self, *args):
        r"""
        copy(Image self, Image alt) -> bool
        copy(Image self, Image alt, size_t w, size_t h) -> bool
        """
        return _yarp.Image_copy(self, *args)

    def move(self, alt):
        r"""move(Image self, Image alt) -> bool"""
        return _yarp.Image_move(self, alt)

    def swap(self, alt):
        r"""swap(Image self, Image alt) -> bool"""
        return _yarp.Image_swap(self, alt)

    def width(self):
        r"""width(Image self) -> size_t"""
        return _yarp.Image_width(self)

    def height(self):
        r"""height(Image self) -> size_t"""
        return _yarp.Image_height(self)

    def getPixelSize(self):
        r"""getPixelSize(Image self) -> size_t"""
        return _yarp.Image_getPixelSize(self)

    def getPixelCode(self):
        r"""getPixelCode(Image self) -> int"""
        return _yarp.Image_getPixelCode(self)

    def getRowSize(self):
        r"""getRowSize(Image self) -> size_t"""
        return _yarp.Image_getRowSize(self)

    def getQuantum(self):
        r"""getQuantum(Image self) -> size_t"""
        return _yarp.Image_getQuantum(self)

    def getPadding(self):
        r"""getPadding(Image self) -> size_t"""
        return _yarp.Image_getPadding(self)

    def getRow(self, *args):
        r"""
        getRow(Image self, size_t r) -> unsigned char
        getRow(Image self, size_t r) -> unsigned char const *
        """
        return _yarp.Image_getRow(self, *args)

    def getPixelAddress(self, x, y):
        r"""getPixelAddress(Image self, size_t x, size_t y) -> unsigned char *"""
        return _yarp.Image_getPixelAddress(self, x, y)

    def isPixel(self, x, y):
        r"""isPixel(Image self, size_t x, size_t y) -> bool"""
        return _yarp.Image_isPixel(self, x, y)

    def zero(self):
        r"""zero(Image self)"""
        return _yarp.Image_zero(self)

    def resize(self, *args):
        r"""
        resize(Image self, size_t imgWidth, size_t imgHeight)
        resize(Image self, Image alt)
        """
        return _yarp.Image_resize(self, *args)

    def getRawImage(self):
        r"""getRawImage(Image self) -> unsigned char *"""
        return _yarp.Image_getRawImage(self)

    def getRawImageSize(self):
        r"""getRawImageSize(Image self) -> size_t"""
        return _yarp.Image_getRawImageSize(self)

    def getIplImage(self):
        r"""getIplImage(Image self) -> void *"""
        return _yarp.Image_getIplImage(self)

    def wrapIplImage(self, iplImage):
        r"""wrapIplImage(Image self, void * iplImage)"""
        return _yarp.Image_wrapIplImage(self, iplImage)

    def read(self, connection):
        r"""read(Image self, ConnectionReader connection) -> bool"""
        return _yarp.Image_read(self, connection)

    def write(self, connection):
        r"""write(Image self, ConnectionWriter connection) -> bool"""
        return _yarp.Image_write(self, connection)

    def setQuantum(self, imgQuantum):
        r"""setQuantum(Image self, size_t imgQuantum)"""
        return _yarp.Image_setQuantum(self, imgQuantum)

    def topIsLowIndex(self):
        r"""topIsLowIndex(Image self) -> bool"""
        return _yarp.Image_topIsLowIndex(self)

    def setTopIsLowIndex(self, flag):
        r"""setTopIsLowIndex(Image self, bool flag)"""
        return _yarp.Image_setTopIsLowIndex(self, flag)

    def getRowArray(self):
        r"""getRowArray(Image self) -> char **"""
        return _yarp.Image_getRowArray(self)

    def setExternal(self, *args):
        r"""
        setExternal(Image self, void const * data, size_t imgWidth, size_t imgHeight)
        setExternal(Image self, PyObject * mem, int w, int h)
        """
        return _yarp.Image_setExternal(self, *args)

    def setExternal2(self, mem, w, h):
        r"""setExternal2(Image self, PyObject * mem, int w, int h)"""
        return _yarp.Image_setExternal2(self, mem, w, h)

    def tostring(self):
        r"""tostring(Image self) -> std::string"""
        return _yarp.Image_tostring(self)

    def fromstring(self, str, w, h):
        r"""fromstring(Image self, std::string const & str, int w, int h)"""
        return _yarp.Image_fromstring(self, str, w, h)

# Register Image in _yarp:
_yarp.Image_swigregister(Image)

class FlexImage(Image):
    r"""Proxy of C++ yarp::sig::FlexImage class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def setPixelCode(self, imgPixelCode):
        r"""setPixelCode(FlexImage self, int imgPixelCode)"""
        return _yarp.FlexImage_setPixelCode(self, imgPixelCode)

    def setPixelSize(self, imgPixelSize):
        r"""setPixelSize(FlexImage self, size_t imgPixelSize)"""
        return _yarp.FlexImage_setPixelSize(self, imgPixelSize)

    def setQuantum(self, imgQuantum):
        r"""setQuantum(FlexImage self, size_t imgQuantum)"""
        return _yarp.FlexImage_setQuantum(self, imgQuantum)

    def __init__(self):
        r"""__init__(FlexImage self) -> FlexImage"""
        _yarp.FlexImage_swiginit(self, _yarp.new_FlexImage())
    __swig_destroy__ = _yarp.delete_FlexImage

# Register FlexImage in _yarp:
_yarp.FlexImage_swigregister(FlexImage)

class PixelRgb(object):
    r"""Proxy of C++ yarp::sig::PixelRgb class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    r = property(_yarp.PixelRgb_r_get, _yarp.PixelRgb_r_set, doc=r"""r : unsigned char""")
    g = property(_yarp.PixelRgb_g_get, _yarp.PixelRgb_g_set, doc=r"""g : unsigned char""")
    b = property(_yarp.PixelRgb_b_get, _yarp.PixelRgb_b_set, doc=r"""b : unsigned char""")

    def __init__(self, *args):
        r"""
        __init__(PixelRgb self) -> PixelRgb
        __init__(PixelRgb self, unsigned char n_r, unsigned char n_g, unsigned char n_b) -> PixelRgb
        """
        _yarp.PixelRgb_swiginit(self, _yarp.new_PixelRgb(*args))
    __swig_destroy__ = _yarp.delete_PixelRgb

# Register PixelRgb in _yarp:
_yarp.PixelRgb_swigregister(PixelRgb)

class PixelRgba(object):
    r"""Proxy of C++ yarp::sig::PixelRgba class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        __init__(PixelRgba self) -> PixelRgba
        __init__(PixelRgba self, unsigned char n_r, unsigned char n_g, unsigned char n_b, unsigned char n_a) -> PixelRgba
        """
        _yarp.PixelRgba_swiginit(self, _yarp.new_PixelRgba(*args))
    r = property(_yarp.PixelRgba_r_get, _yarp.PixelRgba_r_set, doc=r"""r : unsigned char""")
    g = property(_yarp.PixelRgba_g_get, _yarp.PixelRgba_g_set, doc=r"""g : unsigned char""")
    b = property(_yarp.PixelRgba_b_get, _yarp.PixelRgba_b_set, doc=r"""b : unsigned char""")
    a = property(_yarp.PixelRgba_a_get, _yarp.PixelRgba_a_set, doc=r"""a : unsigned char""")
    __swig_destroy__ = _yarp.delete_PixelRgba

# Register PixelRgba in _yarp:
_yarp.PixelRgba_swigregister(PixelRgba)

class PixelBgra(object):
    r"""Proxy of C++ yarp::sig::PixelBgra class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    b = property(_yarp.PixelBgra_b_get, _yarp.PixelBgra_b_set, doc=r"""b : unsigned char""")
    g = property(_yarp.PixelBgra_g_get, _yarp.PixelBgra_g_set, doc=r"""g : unsigned char""")
    r = property(_yarp.PixelBgra_r_get, _yarp.PixelBgra_r_set, doc=r"""r : unsigned char""")
    a = property(_yarp.PixelBgra_a_get, _yarp.PixelBgra_a_set, doc=r"""a : unsigned char""")

    def __init__(self, *args):
        r"""
        __init__(PixelBgra self) -> PixelBgra
        __init__(PixelBgra self, unsigned char n_r, unsigned char n_g, unsigned char n_b, unsigned char n_a) -> PixelBgra
        """
        _yarp.PixelBgra_swiginit(self, _yarp.new_PixelBgra(*args))
    __swig_destroy__ = _yarp.delete_PixelBgra

# Register PixelBgra in _yarp:
_yarp.PixelBgra_swigregister(PixelBgra)

class PixelBgr(object):
    r"""Proxy of C++ yarp::sig::PixelBgr class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    b = property(_yarp.PixelBgr_b_get, _yarp.PixelBgr_b_set, doc=r"""b : unsigned char""")
    g = property(_yarp.PixelBgr_g_get, _yarp.PixelBgr_g_set, doc=r"""g : unsigned char""")
    r = property(_yarp.PixelBgr_r_get, _yarp.PixelBgr_r_set, doc=r"""r : unsigned char""")

    def __init__(self, *args):
        r"""
        __init__(PixelBgr self) -> PixelBgr
        __init__(PixelBgr self, unsigned char n_r, unsigned char n_g, unsigned char n_b) -> PixelBgr
        """
        _yarp.PixelBgr_swiginit(self, _yarp.new_PixelBgr(*args))
    __swig_destroy__ = _yarp.delete_PixelBgr

# Register PixelBgr in _yarp:
_yarp.PixelBgr_swigregister(PixelBgr)

class PixelHsv(object):
    r"""Proxy of C++ yarp::sig::PixelHsv class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    h = property(_yarp.PixelHsv_h_get, _yarp.PixelHsv_h_set, doc=r"""h : unsigned char""")
    s = property(_yarp.PixelHsv_s_get, _yarp.PixelHsv_s_set, doc=r"""s : unsigned char""")
    v = property(_yarp.PixelHsv_v_get, _yarp.PixelHsv_v_set, doc=r"""v : unsigned char""")

    def __init__(self):
        r"""__init__(PixelHsv self) -> PixelHsv"""
        _yarp.PixelHsv_swiginit(self, _yarp.new_PixelHsv())
    __swig_destroy__ = _yarp.delete_PixelHsv

# Register PixelHsv in _yarp:
_yarp.PixelHsv_swigregister(PixelHsv)

class PixelRgbSigned(object):
    r"""Proxy of C++ yarp::sig::PixelRgbSigned class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    r = property(_yarp.PixelRgbSigned_r_get, _yarp.PixelRgbSigned_r_set, doc=r"""r : char""")
    g = property(_yarp.PixelRgbSigned_g_get, _yarp.PixelRgbSigned_g_set, doc=r"""g : char""")
    b = property(_yarp.PixelRgbSigned_b_get, _yarp.PixelRgbSigned_b_set, doc=r"""b : char""")

    def __init__(self):
        r"""__init__(PixelRgbSigned self) -> PixelRgbSigned"""
        _yarp.PixelRgbSigned_swiginit(self, _yarp.new_PixelRgbSigned())
    __swig_destroy__ = _yarp.delete_PixelRgbSigned

# Register PixelRgbSigned in _yarp:
_yarp.PixelRgbSigned_swigregister(PixelRgbSigned)

class PixelRgbFloat(object):
    r"""Proxy of C++ yarp::sig::PixelRgbFloat class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    r = property(_yarp.PixelRgbFloat_r_get, _yarp.PixelRgbFloat_r_set, doc=r"""r : float""")
    g = property(_yarp.PixelRgbFloat_g_get, _yarp.PixelRgbFloat_g_set, doc=r"""g : float""")
    b = property(_yarp.PixelRgbFloat_b_get, _yarp.PixelRgbFloat_b_set, doc=r"""b : float""")

    def __init__(self, *args):
        r"""
        __init__(PixelRgbFloat self) -> PixelRgbFloat
        __init__(PixelRgbFloat self, float n_r, float n_g, float n_b) -> PixelRgbFloat
        """
        _yarp.PixelRgbFloat_swiginit(self, _yarp.new_PixelRgbFloat(*args))
    __swig_destroy__ = _yarp.delete_PixelRgbFloat

# Register PixelRgbFloat in _yarp:
_yarp.PixelRgbFloat_swigregister(PixelRgbFloat)

class PixelRgbInt(object):
    r"""Proxy of C++ yarp::sig::PixelRgbInt class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    r = property(_yarp.PixelRgbInt_r_get, _yarp.PixelRgbInt_r_set, doc=r"""r : yarp::os::NetInt32""")
    g = property(_yarp.PixelRgbInt_g_get, _yarp.PixelRgbInt_g_set, doc=r"""g : yarp::os::NetInt32""")
    b = property(_yarp.PixelRgbInt_b_get, _yarp.PixelRgbInt_b_set, doc=r"""b : yarp::os::NetInt32""")

    def __init__(self, *args):
        r"""
        __init__(PixelRgbInt self) -> PixelRgbInt
        __init__(PixelRgbInt self, int n_r, int n_g, int n_b) -> PixelRgbInt
        """
        _yarp.PixelRgbInt_swiginit(self, _yarp.new_PixelRgbInt(*args))
    __swig_destroy__ = _yarp.delete_PixelRgbInt

# Register PixelRgbInt in _yarp:
_yarp.PixelRgbInt_swigregister(PixelRgbInt)

class PixelHsvFloat(object):
    r"""Proxy of C++ yarp::sig::PixelHsvFloat class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    h = property(_yarp.PixelHsvFloat_h_get, _yarp.PixelHsvFloat_h_set, doc=r"""h : float""")
    s = property(_yarp.PixelHsvFloat_s_get, _yarp.PixelHsvFloat_s_set, doc=r"""s : float""")
    v = property(_yarp.PixelHsvFloat_v_get, _yarp.PixelHsvFloat_v_set, doc=r"""v : float""")

    def __init__(self):
        r"""__init__(PixelHsvFloat self) -> PixelHsvFloat"""
        _yarp.PixelHsvFloat_swiginit(self, _yarp.new_PixelHsvFloat())
    __swig_destroy__ = _yarp.delete_PixelHsvFloat

# Register PixelHsvFloat in _yarp:
_yarp.PixelHsvFloat_swigregister(PixelHsvFloat)

FORMAT_NULL = _yarp.FORMAT_NULL

FORMAT_ANY = _yarp.FORMAT_ANY

FORMAT_PGM = _yarp.FORMAT_PGM

FORMAT_PPM = _yarp.FORMAT_PPM

FORMAT_JPG = _yarp.FORMAT_JPG

FORMAT_NUMERIC = _yarp.FORMAT_NUMERIC

FORMAT_NUMERIC_COMPRESSED = _yarp.FORMAT_NUMERIC_COMPRESSED

FORMAT_PNG = _yarp.FORMAT_PNG


def read(*args):
    r"""
    read(ImageRgb dest, std::string const & src, yarp::sig::file::image_fileformat format=FORMAT_ANY) -> bool
    read(yarp::sig::ImageOf< yarp::sig::PixelBgr > & dest, std::string const & src, yarp::sig::file::image_fileformat format=FORMAT_ANY) -> bool
    read(ImageRgba dest, std::string const & src, yarp::sig::file::image_fileformat format=FORMAT_ANY) -> bool
    read(ImageMono dest, std::string const & src, yarp::sig::file::image_fileformat format=FORMAT_ANY) -> bool
    read(ImageFloat dest, std::string const & src, yarp::sig::file::image_fileformat format=FORMAT_ANY) -> bool
    """
    return _yarp.read(*args)

def write(*args):
    r"""
    write(ImageRgb src, std::string const & dest, yarp::sig::file::image_fileformat format=FORMAT_PPM) -> bool
    write(yarp::sig::ImageOf< yarp::sig::PixelBgr > const & src, std::string const & dest, yarp::sig::file::image_fileformat format=FORMAT_PPM) -> bool
    write(ImageRgba src, std::string const & dest, yarp::sig::file::image_fileformat format=FORMAT_PPM) -> bool
    write(ImageMono src, std::string const & dest, yarp::sig::file::image_fileformat format=FORMAT_PGM) -> bool
    write(ImageFloat src, std::string const & dest, yarp::sig::file::image_fileformat format=FORMAT_NUMERIC) -> bool
    write(Image src, std::string const & dest, yarp::sig::file::image_fileformat format=FORMAT_PPM) -> bool
    """
    return _yarp.write(*args)
class Sound(Portable):
    r"""Proxy of C++ yarp::sig::Sound class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        __init__(Sound self, size_t bytesPerSample=2) -> Sound
        __init__(Sound self, Sound alt) -> Sound
        """
        _yarp.Sound_swiginit(self, _yarp.new_Sound(*args))
    __swig_destroy__ = _yarp.delete_Sound

    def isEqual(self, alt):
        r"""isEqual(Sound self, Sound alt) -> bool"""
        return _yarp.Sound_isEqual(self, alt)

    def __iadd__(self, alt):
        r"""__iadd__(Sound self, Sound alt) -> Sound"""
        return _yarp.Sound___iadd__(self, alt)

    def subSound(self, first_sample, last_sample):
        r"""subSound(Sound self, size_t first_sample, size_t last_sample) -> Sound"""
        return _yarp.Sound_subSound(self, first_sample, last_sample)

    def resize(self, samples, channels=1):
        r"""resize(Sound self, size_t samples, size_t channels=1)"""
        return _yarp.Sound_resize(self, samples, channels)

    def get(self, sample, channel=0):
        r"""get(Sound self, size_t sample, size_t channel=0) -> yarp::sig::Sound::audio_sample"""
        return _yarp.Sound_get(self, sample, channel)

    def set(self, value, sample, channel=0):
        r"""set(Sound self, yarp::sig::Sound::audio_sample value, size_t sample, size_t channel=0)"""
        return _yarp.Sound_set(self, value, sample, channel)

    def getSafe(self, sample, channel=0):
        r"""getSafe(Sound self, size_t sample, size_t channel=0) -> yarp::sig::Sound::audio_sample"""
        return _yarp.Sound_getSafe(self, sample, channel)

    def setSafe(self, value, sample, channel=0):
        r"""setSafe(Sound self, yarp::sig::Sound::audio_sample value, size_t sample, size_t channel=0)"""
        return _yarp.Sound_setSafe(self, value, sample, channel)

    def isSample(self, sample, channel=0):
        r"""isSample(Sound self, size_t sample, size_t channel=0) -> bool"""
        return _yarp.Sound_isSample(self, sample, channel)

    def clear(self):
        r"""clear(Sound self)"""
        return _yarp.Sound_clear(self)

    def normalizeChannel(self, channel):
        r"""normalizeChannel(Sound self, size_t channel)"""
        return _yarp.Sound_normalizeChannel(self, channel)

    def normalize(self):
        r"""normalize(Sound self)"""
        return _yarp.Sound_normalize(self)

    def amplifyChannel(self, channel, gain):
        r"""amplifyChannel(Sound self, size_t channel, double gain)"""
        return _yarp.Sound_amplifyChannel(self, channel, gain)

    def amplify(self, gain):
        r"""amplify(Sound self, double gain)"""
        return _yarp.Sound_amplify(self, gain)

    def findPeakInChannel(self, channelId, sampleId, sampleValue):
        r"""findPeakInChannel(Sound self, size_t channelId, size_t & sampleId, yarp::sig::Sound::audio_sample & sampleValue)"""
        return _yarp.Sound_findPeakInChannel(self, channelId, sampleId, sampleValue)

    def findPeak(self, channelId, sampleId, sampleValue):
        r"""findPeak(Sound self, size_t & channelId, size_t & sampleId, yarp::sig::Sound::audio_sample & sampleValue)"""
        return _yarp.Sound_findPeak(self, channelId, sampleId, sampleValue)

    def sample2timestamp(self, sampleid):
        r"""sample2timestamp(Sound self, size_t sampleid) -> double"""
        return _yarp.Sound_sample2timestamp(self, sampleid)

    def timestamp2sample(self, time):
        r"""timestamp2sample(Sound self, double time) -> size_t"""
        return _yarp.Sound_timestamp2sample(self, time)

    def clearChannel(self, channel):
        r"""clearChannel(Sound self, size_t channel) -> bool"""
        return _yarp.Sound_clearChannel(self, channel)

    def getFrequency(self):
        r"""getFrequency(Sound self) -> int"""
        return _yarp.Sound_getFrequency(self)

    def setFrequency(self, freq):
        r"""setFrequency(Sound self, int freq)"""
        return _yarp.Sound_setFrequency(self, freq)

    def getBytesPerSample(self):
        r"""getBytesPerSample(Sound self) -> size_t"""
        return _yarp.Sound_getBytesPerSample(self)

    def getSamples(self):
        r"""getSamples(Sound self) -> size_t"""
        return _yarp.Sound_getSamples(self)

    def getDuration(self):
        r"""getDuration(Sound self) -> double"""
        return _yarp.Sound_getDuration(self)

    def getChannels(self):
        r"""getChannels(Sound self) -> size_t"""
        return _yarp.Sound_getChannels(self)

    def extractChannelAsSound(self, channel_id):
        r"""extractChannelAsSound(Sound self, size_t channel_id) -> Sound"""
        return _yarp.Sound_extractChannelAsSound(self, channel_id)

    def getChannel(self, channel_id):
        r"""getChannel(Sound self, size_t channel_id) -> std::vector< std::reference_wrapper< yarp::sig::Sound::audio_sample >,std::allocator< std::reference_wrapper< yarp::sig::Sound::audio_sample > > >"""
        return _yarp.Sound_getChannel(self, channel_id)

    def replaceChannel(self, id, channel):
        r"""replaceChannel(Sound self, size_t id, Sound channel) -> bool"""
        return _yarp.Sound_replaceChannel(self, id, channel)

    def getInterleavedAudioRawData(self):
        r"""getInterleavedAudioRawData(Sound self) -> std::vector< std::reference_wrapper< yarp::sig::Sound::audio_sample >,std::allocator< std::reference_wrapper< yarp::sig::Sound::audio_sample > > >"""
        return _yarp.Sound_getInterleavedAudioRawData(self)

    def getNonInterleavedAudioRawData(self):
        r"""getNonInterleavedAudioRawData(Sound self) -> std::vector< std::reference_wrapper< yarp::sig::Sound::audio_sample >,std::allocator< std::reference_wrapper< yarp::sig::Sound::audio_sample > > >"""
        return _yarp.Sound_getNonInterleavedAudioRawData(self)

    def toString_c(self):
        r"""toString_c(Sound self) -> std::string"""
        return _yarp.Sound_toString_c(self)

    def read(self, connection):
        r"""read(Sound self, ConnectionReader connection) -> bool"""
        return _yarp.Sound_read(self, connection)

    def write(self, connection):
        r"""write(Sound self, ConnectionWriter connection) -> bool"""
        return _yarp.Sound_write(self, connection)

    def sound2VecNonInterleaved(self):
        r"""sound2VecNonInterleaved(Sound self) -> ShortVector"""
        return _yarp.Sound_sound2VecNonInterleaved(self)

    def vecNonInterleaved2Sound(self, vec, samples, channels):
        r"""vecNonInterleaved2Sound(Sound self, ShortVector vec, int samples, int channels)"""
        return _yarp.Sound_vecNonInterleaved2Sound(self, vec, samples, channels)

    def sound2VecInterleaved(self):
        r"""sound2VecInterleaved(Sound self) -> ShortVector"""
        return _yarp.Sound_sound2VecInterleaved(self)

    def vecInterleaved2Sound(self, vec, samples, channels):
        r"""vecInterleaved2Sound(Sound self, ShortVector vec, int samples, int channels)"""
        return _yarp.Sound_vecInterleaved2Sound(self, vec, samples, channels)

# Register Sound in _yarp:
_yarp.Sound_swigregister(Sound)


def submatrix(_in, out, r1, r2, c1, c2):
    r"""submatrix(Matrix _in, Matrix out, size_t r1, size_t r2, size_t c1, size_t c2) -> bool"""
    return _yarp.submatrix(_in, out, r1, r2, c1, c2)

def removeCols(_in, out, first_col, how_many):
    r"""removeCols(Matrix _in, Matrix out, size_t first_col, size_t how_many) -> bool"""
    return _yarp.removeCols(_in, out, first_col, how_many)

def removeRows(_in, out, first_row, how_many):
    r"""removeRows(Matrix _in, Matrix out, size_t first_row, size_t how_many) -> bool"""
    return _yarp.removeRows(_in, out, first_row, how_many)
class Matrix(Portable):
    r"""Proxy of C++ yarp::sig::Matrix class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        __init__(Matrix self) -> Matrix
        __init__(Matrix self, size_t r, size_t c) -> Matrix
        __init__(Matrix self, Matrix m) -> Matrix
        """
        _yarp.Matrix_swiginit(self, _yarp.new_Matrix(*args))
    __swig_destroy__ = _yarp.delete_Matrix

    def rows(self):
        r"""rows(Matrix self) -> size_t"""
        return _yarp.Matrix_rows(self)

    def cols(self):
        r"""cols(Matrix self) -> size_t"""
        return _yarp.Matrix_cols(self)

    def resize(self, r, c):
        r"""resize(Matrix self, size_t r, size_t c)"""
        return _yarp.Matrix_resize(self, r, c)

    def access(self, *args):
        r"""
        access(Matrix self, size_t r, size_t c) -> double const
        access(Matrix self, size_t r, size_t c) -> double &
        """
        return _yarp.Matrix_access(self, *args)

    def zero(self):
        r"""zero(Matrix self)"""
        return _yarp.Matrix_zero(self)

    def setRow(self, row, r):
        r"""setRow(Matrix self, size_t row, Vector r) -> bool"""
        return _yarp.Matrix_setRow(self, row, r)

    def setCol(self, col, c):
        r"""setCol(Matrix self, size_t col, Vector c) -> bool"""
        return _yarp.Matrix_setCol(self, col, c)

    def transposed(self):
        r"""transposed(Matrix self) -> Matrix"""
        return _yarp.Matrix_transposed(self)

    def eye(self):
        r"""eye(Matrix self) -> Matrix"""
        return _yarp.Matrix_eye(self)

    def diagonal(self, d):
        r"""diagonal(Matrix self, Vector d) -> Matrix"""
        return _yarp.Matrix_diagonal(self, d)

    def submatrix(self, r1, r2, c1, c2):
        r"""submatrix(Matrix self, size_t r1, size_t r2, size_t c1, size_t c2) -> Matrix"""
        return _yarp.Matrix_submatrix(self, r1, r2, c1, c2)

    def setSubmatrix(self, m, r, c):
        r"""setSubmatrix(Matrix self, Matrix m, size_t r, size_t c) -> bool"""
        return _yarp.Matrix_setSubmatrix(self, m, r, c)

    def setSubrow(self, v, r, c):
        r"""setSubrow(Matrix self, Vector v, size_t r, size_t c) -> bool"""
        return _yarp.Matrix_setSubrow(self, v, r, c)

    def setSubcol(self, v, r, c):
        r"""setSubcol(Matrix self, Vector v, size_t r, size_t c) -> bool"""
        return _yarp.Matrix_setSubcol(self, v, r, c)

    def getRow(self, r):
        r"""getRow(Matrix self, size_t r) -> Vector"""
        return _yarp.Matrix_getRow(self, r)

    def getCol(self, c):
        r"""getCol(Matrix self, size_t c) -> Vector"""
        return _yarp.Matrix_getCol(self, c)

    def removeCols(self, first_col, how_many):
        r"""removeCols(Matrix self, size_t first_col, size_t how_many) -> Matrix"""
        return _yarp.Matrix_removeCols(self, first_col, how_many)

    def removeRows(self, first_row, how_many):
        r"""removeRows(Matrix self, size_t first_row, size_t how_many) -> Matrix"""
        return _yarp.Matrix_removeRows(self, first_row, how_many)

    def subrow(self, r, c, size):
        r"""subrow(Matrix self, size_t r, size_t c, size_t size) -> Vector"""
        return _yarp.Matrix_subrow(self, r, c, size)

    def subcol(self, r, c, size):
        r"""subcol(Matrix self, size_t r, size_t c, size_t size) -> Vector"""
        return _yarp.Matrix_subcol(self, r, c, size)

    def toString(self, *args):
        r"""toString(Matrix self, int precision=-1, int width=-1, char const * endRowStr="\n") -> std::string"""
        return _yarp.Matrix_toString(self, *args)

    def toString_c(self, *args):
        
        return _yarp.Matrix_toString_c(self, *args)

    def data(self, *args):
        r"""
        data(Matrix self) -> double
        data(Matrix self) -> double const *
        """
        return _yarp.Matrix_data(self, *args)

    def isEqual(self, r):
        r"""isEqual(Matrix self, Matrix r) -> bool"""
        return _yarp.Matrix_isEqual(self, r)

    def read(self, connection):
        r"""read(Matrix self, ConnectionReader connection) -> bool"""
        return _yarp.Matrix_read(self, connection)

    def write(self, connection):
        r"""write(Matrix self, ConnectionWriter connection) -> bool"""
        return _yarp.Matrix_write(self, connection)

    def get(self, i, j):
        r"""get(Matrix self, int i, int j) -> double"""
        return _yarp.Matrix_get(self, i, j)

    def set(self, i, j, v):
        r"""set(Matrix self, int i, int j, double v)"""
        return _yarp.Matrix_set(self, i, j, v)

    def __setitem__(self, matrix_i_row, value):
        r"""__setitem__(Matrix self, int matrix_i_row, double value)"""
        return _yarp.Matrix___setitem__(self, matrix_i_row, value)

    def __getitem__(self, matrix_i_row):
        r"""__getitem__(Matrix self, int matrix_i_row) -> double"""
        return _yarp.Matrix___getitem__(self, matrix_i_row)

# Register Matrix in _yarp:
_yarp.Matrix_swigregister(Matrix)

class VectorBase(Portable):
    r"""Proxy of C++ yarp::sig::VectorBase class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def getElementSize(self):
        r"""getElementSize(VectorBase self) -> size_t"""
        return _yarp.VectorBase_getElementSize(self)

    def getBottleTag(self):
        r"""getBottleTag(VectorBase self) -> int"""
        return _yarp.VectorBase_getBottleTag(self)

    def getListSize(self):
        r"""getListSize(VectorBase self) -> size_t"""
        return _yarp.VectorBase_getListSize(self)

    def getMemoryBlock(self, *args):
        r"""
        getMemoryBlock(VectorBase self) -> char const
        getMemoryBlock(VectorBase self) -> char *
        """
        return _yarp.VectorBase_getMemoryBlock(self, *args)

    def resize(self, size):
        r"""resize(VectorBase self, size_t size)"""
        return _yarp.VectorBase_resize(self, size)

    def read(self, connection):
        r"""read(VectorBase self, ConnectionReader connection) -> bool"""
        return _yarp.VectorBase_read(self, connection)

    def write(self, connection):
        r"""write(VectorBase self, ConnectionWriter connection) -> bool"""
        return _yarp.VectorBase_write(self, connection)
    __swig_destroy__ = _yarp.delete_VectorBase

# Register VectorBase in _yarp:
_yarp.VectorBase_swigregister(VectorBase)

class IConfig(object):
    r"""Proxy of C++ yarp::os::IConfig class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _yarp.delete_IConfig

    def open(self, config):
        r"""open(IConfig self, Searchable config) -> bool"""
        return _yarp.IConfig_open(self, config)

    def close(self):
        r"""close(IConfig self) -> bool"""
        return _yarp.IConfig_close(self)

    def configure(self, config):
        r"""configure(IConfig self, Searchable config) -> bool"""
        return _yarp.IConfig_configure(self, config)

    def __init__(self):
        r"""__init__(IConfig self) -> IConfig"""
        _yarp.IConfig_swiginit(self, _yarp.new_IConfig())

# Register IConfig in _yarp:
_yarp.IConfig_swigregister(IConfig)

class DeviceDriver(IConfig):
    r"""Proxy of C++ yarp::dev::DeviceDriver class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _yarp.delete_DeviceDriver

    def open(self, config):
        r"""open(DeviceDriver self, Searchable config) -> bool"""
        return _yarp.DeviceDriver_open(self, config)

    def close(self):
        r"""close(DeviceDriver self) -> bool"""
        return _yarp.DeviceDriver_close(self)

    def getImplementation(self):
        r"""getImplementation(DeviceDriver self) -> DeviceDriver"""
        return _yarp.DeviceDriver_getImplementation(self)

    def __init__(self):
        r"""__init__(DeviceDriver self) -> DeviceDriver"""
        _yarp.DeviceDriver_swiginit(self, _yarp.new_DeviceDriver())

# Register DeviceDriver in _yarp:
_yarp.DeviceDriver_swigregister(DeviceDriver)

class DeprecatedDeviceDriver(DeviceDriver):
    r"""Proxy of C++ yarp::dev::DeprecatedDeviceDriver class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        r"""__init__(DeprecatedDeviceDriver self) -> DeprecatedDeviceDriver"""
        _yarp.DeprecatedDeviceDriver_swiginit(self, _yarp.new_DeprecatedDeviceDriver())
    __swig_destroy__ = _yarp.delete_DeprecatedDeviceDriver

# Register DeprecatedDeviceDriver in _yarp:
_yarp.DeprecatedDeviceDriver_swigregister(DeprecatedDeviceDriver)

class DeviceResponder(PortReader, BottleCallback):
    r"""Proxy of C++ yarp::dev::DeviceResponder class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        r"""__init__(DeviceResponder self) -> DeviceResponder"""
        _yarp.DeviceResponder_swiginit(self, _yarp.new_DeviceResponder())

    def addUsage(self, *args):
        r"""
        addUsage(DeviceResponder self, char const * txt, char const * explain=None)
        addUsage(DeviceResponder self, Bottle bot, char const * explain=None)
        """
        return _yarp.DeviceResponder_addUsage(self, *args)

    def respond(self, command, reply):
        r"""respond(DeviceResponder self, Bottle command, Bottle reply) -> bool"""
        return _yarp.DeviceResponder_respond(self, command, reply)

    def read(self, connection):
        r"""read(DeviceResponder self, ConnectionReader connection) -> bool"""
        return _yarp.DeviceResponder_read(self, connection)

    def onRead(self, *args):
        r"""
        onRead(DeviceResponder self, Bottle datum, TypedReaderBottle reader)
        onRead(DeviceResponder self, Bottle v)
        """
        return _yarp.DeviceResponder_onRead(self, *args)

    def makeUsage(self):
        r"""makeUsage(DeviceResponder self)"""
        return _yarp.DeviceResponder_makeUsage(self)

    def attach(self, source):
        r"""attach(DeviceResponder self, TypedReaderBottle source)"""
        return _yarp.DeviceResponder_attach(self, source)
    __swig_destroy__ = _yarp.delete_DeviceResponder

# Register DeviceResponder in _yarp:
_yarp.DeviceResponder_swigregister(DeviceResponder)

class PolyDriver(DeviceDriver):
    r"""Proxy of C++ yarp::dev::PolyDriver class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        __init__(PolyDriver self) -> PolyDriver
        __init__(PolyDriver self, std::string const & txt) -> PolyDriver
        __init__(PolyDriver self, Searchable config) -> PolyDriver
        """
        _yarp.PolyDriver_swiginit(self, _yarp.new_PolyDriver(*args))
    __swig_destroy__ = _yarp.delete_PolyDriver

    def open_str(self, txt):
        r"""open_str(PolyDriver self, std::string const & txt) -> bool"""
        return _yarp.PolyDriver_open_str(self, txt)

    def open(self, config):
        r"""open(PolyDriver self, Searchable config) -> bool"""
        return _yarp.PolyDriver_open(self, config)

    def link(self, alt):
        r"""link(PolyDriver self, PolyDriver alt) -> bool"""
        return _yarp.PolyDriver_link(self, alt)

    def take(self):
        r"""take(PolyDriver self) -> DeviceDriver"""
        return _yarp.PolyDriver_take(self)

    def give(self, dd, own):
        r"""give(PolyDriver self, DeviceDriver dd, bool own) -> bool"""
        return _yarp.PolyDriver_give(self, dd, own)

    def close(self):
        r"""close(PolyDriver self) -> bool"""
        return _yarp.PolyDriver_close(self)

    def isValid(self):
        r"""isValid(PolyDriver self) -> bool"""
        return _yarp.PolyDriver_isValid(self)

    def getOptions(self):
        r"""getOptions(PolyDriver self) -> Bottle"""
        return _yarp.PolyDriver_getOptions(self)

    def getComment(self, option):
        r"""getComment(PolyDriver self, char const * option) -> std::string"""
        return _yarp.PolyDriver_getComment(self, option)

    def getDefaultValue(self, option):
        r"""getDefaultValue(PolyDriver self, char const * option) -> Value"""
        return _yarp.PolyDriver_getDefaultValue(self, option)

    def getValue(self, option):
        r"""getValue(PolyDriver self, char const * option) -> Value"""
        return _yarp.PolyDriver_getValue(self, option)

    def getImplementation(self):
        r"""getImplementation(PolyDriver self) -> DeviceDriver"""
        return _yarp.PolyDriver_getImplementation(self)

    def viewIFrameGrabberImage(self):
        r"""viewIFrameGrabberImage(PolyDriver self) -> yarp::dev::IFrameGrabberImage *"""
        return _yarp.PolyDriver_viewIFrameGrabberImage(self)

    def viewIPositionControl(self):
        r"""viewIPositionControl(PolyDriver self) -> IPositionControl"""
        return _yarp.PolyDriver_viewIPositionControl(self)

    def viewIVelocityControl(self):
        r"""viewIVelocityControl(PolyDriver self) -> IVelocityControl"""
        return _yarp.PolyDriver_viewIVelocityControl(self)

    def viewIEncoders(self):
        r"""viewIEncoders(PolyDriver self) -> IEncoders"""
        return _yarp.PolyDriver_viewIEncoders(self)

    def viewIEncodersTimed(self):
        r"""viewIEncodersTimed(PolyDriver self) -> IEncodersTimed"""
        return _yarp.PolyDriver_viewIEncodersTimed(self)

    def viewIMotor(self):
        r"""viewIMotor(PolyDriver self) -> IMotor"""
        return _yarp.PolyDriver_viewIMotor(self)

    def viewIMotorEncoders(self):
        r"""viewIMotorEncoders(PolyDriver self) -> IMotorEncoders"""
        return _yarp.PolyDriver_viewIMotorEncoders(self)

    def viewIPidControl(self):
        r"""viewIPidControl(PolyDriver self) -> IPidControl"""
        return _yarp.PolyDriver_viewIPidControl(self)

    def viewIAmplifierControl(self):
        r"""viewIAmplifierControl(PolyDriver self) -> IAmplifierControl"""
        return _yarp.PolyDriver_viewIAmplifierControl(self)

    def viewIControlLimits(self):
        r"""viewIControlLimits(PolyDriver self) -> IControlLimits"""
        return _yarp.PolyDriver_viewIControlLimits(self)

    def viewICartesianControl(self):
        r"""viewICartesianControl(PolyDriver self) -> ICartesianControl"""
        return _yarp.PolyDriver_viewICartesianControl(self)

    def viewIGazeControl(self):
        r"""viewIGazeControl(PolyDriver self) -> IGazeControl"""
        return _yarp.PolyDriver_viewIGazeControl(self)

    def viewIImpedanceControl(self):
        r"""viewIImpedanceControl(PolyDriver self) -> IImpedanceControl"""
        return _yarp.PolyDriver_viewIImpedanceControl(self)

    def viewITorqueControl(self):
        r"""viewITorqueControl(PolyDriver self) -> ITorqueControl"""
        return _yarp.PolyDriver_viewITorqueControl(self)

    def viewIControlMode(self):
        r"""viewIControlMode(PolyDriver self) -> IControlMode"""
        return _yarp.PolyDriver_viewIControlMode(self)

    def viewIControlMode2(self):
        r"""viewIControlMode2(PolyDriver self) -> IControlMode"""
        return _yarp.PolyDriver_viewIControlMode2(self)

    def viewIInteractionMode(self):
        r"""viewIInteractionMode(PolyDriver self) -> IInteractionMode"""
        return _yarp.PolyDriver_viewIInteractionMode(self)

    def viewIPWMControl(self):
        r"""viewIPWMControl(PolyDriver self) -> IPWMControl"""
        return _yarp.PolyDriver_viewIPWMControl(self)

    def viewICurrentControl(self):
        r"""viewICurrentControl(PolyDriver self) -> ICurrentControl"""
        return _yarp.PolyDriver_viewICurrentControl(self)

    def viewIAnalogSensor(self):
        r"""viewIAnalogSensor(PolyDriver self) -> IAnalogSensor"""
        return _yarp.PolyDriver_viewIAnalogSensor(self)

    def viewIFrameGrabberControls2(self):
        r"""viewIFrameGrabberControls2(PolyDriver self) -> IFrameGrabberControls"""
        return _yarp.PolyDriver_viewIFrameGrabberControls2(self)

    def viewIFrameGrabberControls(self):
        r"""viewIFrameGrabberControls(PolyDriver self) -> IFrameGrabberControls"""
        return _yarp.PolyDriver_viewIFrameGrabberControls(self)

    def viewIPositionDirect(self):
        r"""viewIPositionDirect(PolyDriver self) -> IPositionDirect"""
        return _yarp.PolyDriver_viewIPositionDirect(self)

    def viewIRemoteVariables(self):
        r"""viewIRemoteVariables(PolyDriver self) -> IRemoteVariables"""
        return _yarp.PolyDriver_viewIRemoteVariables(self)

    def viewIAxisInfo(self):
        r"""viewIAxisInfo(PolyDriver self) -> IAxisInfo"""
        return _yarp.PolyDriver_viewIAxisInfo(self)

    def viewIThreeAxisGyroscopes(self):
        r"""viewIThreeAxisGyroscopes(PolyDriver self) -> IThreeAxisGyroscopes"""
        return _yarp.PolyDriver_viewIThreeAxisGyroscopes(self)

    def viewIThreeAxisLinearAccelerometers(self):
        r"""viewIThreeAxisLinearAccelerometers(PolyDriver self) -> IThreeAxisLinearAccelerometers"""
        return _yarp.PolyDriver_viewIThreeAxisLinearAccelerometers(self)

    def viewIThreeAxisMagnetometers(self):
        r"""viewIThreeAxisMagnetometers(PolyDriver self) -> IThreeAxisMagnetometers"""
        return _yarp.PolyDriver_viewIThreeAxisMagnetometers(self)

    def viewIOrientationSensors(self):
        r"""viewIOrientationSensors(PolyDriver self) -> IOrientationSensors"""
        return _yarp.PolyDriver_viewIOrientationSensors(self)

    def viewITemperatureSensors(self):
        r"""viewITemperatureSensors(PolyDriver self) -> ITemperatureSensors"""
        return _yarp.PolyDriver_viewITemperatureSensors(self)

    def viewISixAxisForceTorqueSensors(self):
        r"""viewISixAxisForceTorqueSensors(PolyDriver self) -> ISixAxisForceTorqueSensors"""
        return _yarp.PolyDriver_viewISixAxisForceTorqueSensors(self)

    def viewIContactLoadCellArrays(self):
        r"""viewIContactLoadCellArrays(PolyDriver self) -> IContactLoadCellArrays"""
        return _yarp.PolyDriver_viewIContactLoadCellArrays(self)

    def viewIEncoderArrays(self):
        r"""viewIEncoderArrays(PolyDriver self) -> IEncoderArrays"""
        return _yarp.PolyDriver_viewIEncoderArrays(self)

    def viewISkinPatches(self):
        r"""viewISkinPatches(PolyDriver self) -> ISkinPatches"""
        return _yarp.PolyDriver_viewISkinPatches(self)

# Register PolyDriver in _yarp:
_yarp.PolyDriver_swigregister(PolyDriver)

class DriverCreator(object):
    r"""Proxy of C++ yarp::dev::DriverCreator class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _yarp.delete_DriverCreator

    def toString_c(self):
        r"""toString_c(DriverCreator self) -> std::string"""
        return _yarp.DriverCreator_toString_c(self)

    def create(self):
        r"""create(DriverCreator self) -> DeviceDriver"""
        return _yarp.DriverCreator_create(self)

    def getName(self):
        r"""getName(DriverCreator self) -> std::string"""
        return _yarp.DriverCreator_getName(self)

    def getWrapper(self):
        r"""getWrapper(DriverCreator self) -> std::string"""
        return _yarp.DriverCreator_getWrapper(self)

    def getCode(self):
        r"""getCode(DriverCreator self) -> std::string"""
        return _yarp.DriverCreator_getCode(self)

    def owner(self):
        r"""owner(DriverCreator self) -> PolyDriver"""
        return _yarp.DriverCreator_owner(self)

# Register DriverCreator in _yarp:
_yarp.DriverCreator_swigregister(DriverCreator)

class StubDriverCreator(DriverCreator):
    r"""Proxy of C++ yarp::dev::StubDriverCreator class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, name, wrap, code, libname, fnname):
        r"""__init__(StubDriverCreator self, char const * name, char const * wrap, char const * code, char const * libname, char const * fnname) -> StubDriverCreator"""
        _yarp.StubDriverCreator_swiginit(self, _yarp.new_StubDriverCreator(name, wrap, code, libname, fnname))

    def toString_c(self):
        r"""toString_c(StubDriverCreator self) -> std::string"""
        return _yarp.StubDriverCreator_toString_c(self)

    def getName(self):
        r"""getName(StubDriverCreator self) -> std::string"""
        return _yarp.StubDriverCreator_getName(self)

    def getWrapper(self):
        r"""getWrapper(StubDriverCreator self) -> std::string"""
        return _yarp.StubDriverCreator_getWrapper(self)

    def getCode(self):
        r"""getCode(StubDriverCreator self) -> std::string"""
        return _yarp.StubDriverCreator_getCode(self)

    def create(self):
        r"""create(StubDriverCreator self) -> DeviceDriver"""
        return _yarp.StubDriverCreator_create(self)
    __swig_destroy__ = _yarp.delete_StubDriverCreator

# Register StubDriverCreator in _yarp:
_yarp.StubDriverCreator_swigregister(StubDriverCreator)

class Drivers(object):
    r"""Proxy of C++ yarp::dev::Drivers class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @staticmethod
    def factory():
        r"""factory() -> Drivers"""
        return _yarp.Drivers_factory()

    def open(self, *args):
        r"""
        open(Drivers self, char const * device) -> DeviceDriver
        open(Drivers self, Searchable config) -> DeviceDriver
        """
        return _yarp.Drivers_open(self, *args)

    def toString_c(self):
        r"""toString_c(Drivers self) -> std::string"""
        return _yarp.Drivers_toString_c(self)
    __swig_destroy__ = _yarp.delete_Drivers

    def add(self, creator):
        r"""add(Drivers self, DriverCreator creator)"""
        return _yarp.Drivers_add(self, creator)

    def find(self, name):
        r"""find(Drivers self, char const * name) -> DriverCreator"""
        return _yarp.Drivers_find(self, name)

    def remove(self, name):
        r"""remove(Drivers self, char const * name) -> bool"""
        return _yarp.Drivers_remove(self, name)

    @staticmethod
    def yarpdev(argc):
        r"""yarpdev(int argc) -> int"""
        return _yarp.Drivers_yarpdev(argc)

# Register Drivers in _yarp:
_yarp.Drivers_swigregister(Drivers)

def Drivers_factory():
    r"""Drivers_factory() -> Drivers"""
    return _yarp.Drivers_factory()

def Drivers_yarpdev(argc):
    r"""Drivers_yarpdev(int argc) -> int"""
    return _yarp.Drivers_yarpdev(argc)

YARP_CROP_RECT = _yarp.YARP_CROP_RECT

YARP_CROP_LIST = _yarp.YARP_CROP_LIST

class IFrameGrabberImageBase(object):
    r"""Proxy of C++ yarp::dev::IFrameGrabberImageBase class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _yarp.delete_IFrameGrabberImageBase

    def height(self):
        r"""height(IFrameGrabberImageBase self) -> int"""
        return _yarp.IFrameGrabberImageBase_height(self)

    def width(self):
        r"""width(IFrameGrabberImageBase self) -> int"""
        return _yarp.IFrameGrabberImageBase_width(self)

# Register IFrameGrabberImageBase in _yarp:
_yarp.IFrameGrabberImageBase_swigregister(IFrameGrabberImageBase)

BUS_UNKNOWN = _yarp.BUS_UNKNOWN

BUS_FIREWIRE = _yarp.BUS_FIREWIRE

BUS_USB = _yarp.BUS_USB

MODE_UNKNOWN = _yarp.MODE_UNKNOWN

MODE_MANUAL = _yarp.MODE_MANUAL

MODE_AUTO = _yarp.MODE_AUTO

class CameraDescriptor(object):
    r"""Proxy of C++ CameraDescriptor class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    busType = property(_yarp.CameraDescriptor_busType_get, _yarp.CameraDescriptor_busType_set, doc=r"""busType : BusType""")
    deviceDescription = property(_yarp.CameraDescriptor_deviceDescription_get, _yarp.CameraDescriptor_deviceDescription_set, doc=r"""deviceDescription : std::string""")

    def __init__(self):
        r"""__init__(CameraDescriptor self) -> CameraDescriptor"""
        _yarp.CameraDescriptor_swiginit(self, _yarp.new_CameraDescriptor())
    __swig_destroy__ = _yarp.delete_CameraDescriptor

# Register CameraDescriptor in _yarp:
_yarp.CameraDescriptor_swigregister(CameraDescriptor)

YARP_FEATURE_INVALID = _yarp.YARP_FEATURE_INVALID

YARP_FEATURE_BRIGHTNESS = _yarp.YARP_FEATURE_BRIGHTNESS

YARP_FEATURE_EXPOSURE = _yarp.YARP_FEATURE_EXPOSURE

YARP_FEATURE_SHARPNESS = _yarp.YARP_FEATURE_SHARPNESS

YARP_FEATURE_WHITE_BALANCE = _yarp.YARP_FEATURE_WHITE_BALANCE

YARP_FEATURE_HUE = _yarp.YARP_FEATURE_HUE

YARP_FEATURE_SATURATION = _yarp.YARP_FEATURE_SATURATION

YARP_FEATURE_GAMMA = _yarp.YARP_FEATURE_GAMMA

YARP_FEATURE_SHUTTER = _yarp.YARP_FEATURE_SHUTTER

YARP_FEATURE_GAIN = _yarp.YARP_FEATURE_GAIN

YARP_FEATURE_IRIS = _yarp.YARP_FEATURE_IRIS

YARP_FEATURE_FOCUS = _yarp.YARP_FEATURE_FOCUS

YARP_FEATURE_TEMPERATURE = _yarp.YARP_FEATURE_TEMPERATURE

YARP_FEATURE_TRIGGER = _yarp.YARP_FEATURE_TRIGGER

YARP_FEATURE_TRIGGER_DELAY = _yarp.YARP_FEATURE_TRIGGER_DELAY

YARP_FEATURE_WHITE_SHADING = _yarp.YARP_FEATURE_WHITE_SHADING

YARP_FEATURE_FRAME_RATE = _yarp.YARP_FEATURE_FRAME_RATE

YARP_FEATURE_ZOOM = _yarp.YARP_FEATURE_ZOOM

YARP_FEATURE_PAN = _yarp.YARP_FEATURE_PAN

YARP_FEATURE_TILT = _yarp.YARP_FEATURE_TILT

YARP_FEATURE_OPTICAL_FILTER = _yarp.YARP_FEATURE_OPTICAL_FILTER

YARP_FEATURE_CAPTURE_SIZE = _yarp.YARP_FEATURE_CAPTURE_SIZE

YARP_FEATURE_CAPTURE_QUALITY = _yarp.YARP_FEATURE_CAPTURE_QUALITY

YARP_FEATURE_MIRROR = _yarp.YARP_FEATURE_MIRROR

YARP_FEATURE_NUMBER_OF = _yarp.YARP_FEATURE_NUMBER_OF

class IFrameGrabberControls(object):
    r"""Proxy of C++ yarp::dev::IFrameGrabberControls class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _yarp.delete_IFrameGrabberControls

    def setBrightness(self, v):
        r"""setBrightness(IFrameGrabberControls self, double v) -> bool"""
        return _yarp.IFrameGrabberControls_setBrightness(self, v)

    def setExposure(self, v):
        r"""setExposure(IFrameGrabberControls self, double v) -> bool"""
        return _yarp.IFrameGrabberControls_setExposure(self, v)

    def setSharpness(self, v):
        r"""setSharpness(IFrameGrabberControls self, double v) -> bool"""
        return _yarp.IFrameGrabberControls_setSharpness(self, v)

    def setWhiteBalance(self, blue, red):
        r"""setWhiteBalance(IFrameGrabberControls self, double blue, double red) -> bool"""
        return _yarp.IFrameGrabberControls_setWhiteBalance(self, blue, red)

    def setHue(self, v):
        r"""setHue(IFrameGrabberControls self, double v) -> bool"""
        return _yarp.IFrameGrabberControls_setHue(self, v)

    def setSaturation(self, v):
        r"""setSaturation(IFrameGrabberControls self, double v) -> bool"""
        return _yarp.IFrameGrabberControls_setSaturation(self, v)

    def setGamma(self, v):
        r"""setGamma(IFrameGrabberControls self, double v) -> bool"""
        return _yarp.IFrameGrabberControls_setGamma(self, v)

    def setShutter(self, v):
        r"""setShutter(IFrameGrabberControls self, double v) -> bool"""
        return _yarp.IFrameGrabberControls_setShutter(self, v)

    def setGain(self, v):
        r"""setGain(IFrameGrabberControls self, double v) -> bool"""
        return _yarp.IFrameGrabberControls_setGain(self, v)

    def setIris(self, v):
        r"""setIris(IFrameGrabberControls self, double v) -> bool"""
        return _yarp.IFrameGrabberControls_setIris(self, v)

    def getBrightness(self):
        r"""getBrightness(IFrameGrabberControls self) -> double"""
        return _yarp.IFrameGrabberControls_getBrightness(self)

    def getExposure(self):
        r"""getExposure(IFrameGrabberControls self) -> double"""
        return _yarp.IFrameGrabberControls_getExposure(self)

    def getSharpness(self):
        r"""getSharpness(IFrameGrabberControls self) -> double"""
        return _yarp.IFrameGrabberControls_getSharpness(self)

    def getWhiteBalance(self, blue, red):
        r"""getWhiteBalance(IFrameGrabberControls self, double & blue, double & red) -> bool"""
        return _yarp.IFrameGrabberControls_getWhiteBalance(self, blue, red)

    def getHue(self):
        r"""getHue(IFrameGrabberControls self) -> double"""
        return _yarp.IFrameGrabberControls_getHue(self)

    def getSaturation(self):
        r"""getSaturation(IFrameGrabberControls self) -> double"""
        return _yarp.IFrameGrabberControls_getSaturation(self)

    def getGamma(self):
        r"""getGamma(IFrameGrabberControls self) -> double"""
        return _yarp.IFrameGrabberControls_getGamma(self)

    def getShutter(self):
        r"""getShutter(IFrameGrabberControls self) -> double"""
        return _yarp.IFrameGrabberControls_getShutter(self)

    def getGain(self):
        r"""getGain(IFrameGrabberControls self) -> double"""
        return _yarp.IFrameGrabberControls_getGain(self)

    def getIris(self):
        r"""getIris(IFrameGrabberControls self) -> double"""
        return _yarp.IFrameGrabberControls_getIris(self)

    def busType2String(self, type):
        r"""busType2String(IFrameGrabberControls self, BusType type) -> std::string"""
        return _yarp.IFrameGrabberControls_busType2String(self, type)

    def toFeatureMode(self, _auto):
        r"""toFeatureMode(IFrameGrabberControls self, bool _auto) -> FeatureMode"""
        return _yarp.IFrameGrabberControls_toFeatureMode(self, _auto)

    def setFeature(self, *args):
        r"""
        setFeature(IFrameGrabberControls self, int feature, double value) -> bool
        setFeature(IFrameGrabberControls self, int feature, double value1, double value2) -> bool
        """
        return _yarp.IFrameGrabberControls_setFeature(self, *args)

    def setActive(self, feature, onoff):
        r"""setActive(IFrameGrabberControls self, int feature, bool onoff) -> bool"""
        return _yarp.IFrameGrabberControls_setActive(self, feature, onoff)

    def setMode(self, feature, mode):
        r"""setMode(IFrameGrabberControls self, int feature, FeatureMode mode) -> bool"""
        return _yarp.IFrameGrabberControls_setMode(self, feature, mode)

    def setOnePush(self, feature):
        r"""setOnePush(IFrameGrabberControls self, int feature) -> bool"""
        return _yarp.IFrameGrabberControls_setOnePush(self, feature)

    def getCameraDescription(self, *args):
        r"""
        getCameraDescription(IFrameGrabberControls self, CameraDescriptor camera) -> bool
        getCameraDescription(IFrameGrabberControls self) -> CameraDescriptor
        """
        return _yarp.IFrameGrabberControls_getCameraDescription(self, *args)

    def hasFeature(self, *args):
        r"""
        hasFeature(IFrameGrabberControls self, int feature, bool * hasFeature) -> bool
        hasFeature(IFrameGrabberControls self, int feature) -> bool
        """
        return _yarp.IFrameGrabberControls_hasFeature(self, *args)

    def getFeature(self, *args):
        r"""
        getFeature(IFrameGrabberControls self, int feature, double * value) -> bool
        getFeature(IFrameGrabberControls self, int feature, double * value1, double * value2) -> bool
        getFeature(IFrameGrabberControls self, int feature) -> double
        """
        return _yarp.IFrameGrabberControls_getFeature(self, *args)

    def hasOnOff(self, *args):
        r"""
        hasOnOff(IFrameGrabberControls self, int feature, bool * HasOnOff) -> bool
        hasOnOff(IFrameGrabberControls self, int feature) -> bool
        """
        return _yarp.IFrameGrabberControls_hasOnOff(self, *args)

    def getActive(self, *args):
        r"""
        getActive(IFrameGrabberControls self, int feature, bool * isActive) -> bool
        getActive(IFrameGrabberControls self, int feature) -> bool
        """
        return _yarp.IFrameGrabberControls_getActive(self, *args)

    def hasAuto(self, *args):
        r"""
        hasAuto(IFrameGrabberControls self, int feature, bool * hasAuto) -> bool
        hasAuto(IFrameGrabberControls self, int feature) -> bool
        """
        return _yarp.IFrameGrabberControls_hasAuto(self, *args)

    def hasManual(self, *args):
        r"""
        hasManual(IFrameGrabberControls self, int feature, bool * hasManual) -> bool
        hasManual(IFrameGrabberControls self, int feature) -> bool
        """
        return _yarp.IFrameGrabberControls_hasManual(self, *args)

    def hasOnePush(self, *args):
        r"""
        hasOnePush(IFrameGrabberControls self, int feature, bool * hasOnePush) -> bool
        hasOnePush(IFrameGrabberControls self, int feature) -> bool
        """
        return _yarp.IFrameGrabberControls_hasOnePush(self, *args)

    def getMode(self, *args):
        r"""
        getMode(IFrameGrabberControls self, int feature, FeatureMode * mode) -> bool
        getMode(IFrameGrabberControls self, int feature) -> FeatureMode
        """
        return _yarp.IFrameGrabberControls_getMode(self, *args)

# Register IFrameGrabberControls in _yarp:
_yarp.IFrameGrabberControls_swigregister(IFrameGrabberControls)

class IFrameGrabberControlsDC1394(object):
    r"""Proxy of C++ yarp::dev::IFrameGrabberControlsDC1394 class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _yarp.delete_IFrameGrabberControlsDC1394

    def getVideoModeMaskDC1394(self):
        r"""getVideoModeMaskDC1394(IFrameGrabberControlsDC1394 self) -> unsigned int"""
        return _yarp.IFrameGrabberControlsDC1394_getVideoModeMaskDC1394(self)

    def getVideoModeDC1394(self):
        r"""getVideoModeDC1394(IFrameGrabberControlsDC1394 self) -> unsigned int"""
        return _yarp.IFrameGrabberControlsDC1394_getVideoModeDC1394(self)

    def setVideoModeDC1394(self, video_mode):
        r"""setVideoModeDC1394(IFrameGrabberControlsDC1394 self, int video_mode) -> bool"""
        return _yarp.IFrameGrabberControlsDC1394_setVideoModeDC1394(self, video_mode)

    def getFPSMaskDC1394(self):
        r"""getFPSMaskDC1394(IFrameGrabberControlsDC1394 self) -> unsigned int"""
        return _yarp.IFrameGrabberControlsDC1394_getFPSMaskDC1394(self)

    def getFPSDC1394(self):
        r"""getFPSDC1394(IFrameGrabberControlsDC1394 self) -> unsigned int"""
        return _yarp.IFrameGrabberControlsDC1394_getFPSDC1394(self)

    def setFPSDC1394(self, fps):
        r"""setFPSDC1394(IFrameGrabberControlsDC1394 self, int fps) -> bool"""
        return _yarp.IFrameGrabberControlsDC1394_setFPSDC1394(self, fps)

    def getISOSpeedDC1394(self):
        r"""getISOSpeedDC1394(IFrameGrabberControlsDC1394 self) -> unsigned int"""
        return _yarp.IFrameGrabberControlsDC1394_getISOSpeedDC1394(self)

    def setISOSpeedDC1394(self, speed):
        r"""setISOSpeedDC1394(IFrameGrabberControlsDC1394 self, int speed) -> bool"""
        return _yarp.IFrameGrabberControlsDC1394_setISOSpeedDC1394(self, speed)

    def getColorCodingMaskDC1394(self, video_mode):
        r"""getColorCodingMaskDC1394(IFrameGrabberControlsDC1394 self, unsigned int video_mode) -> unsigned int"""
        return _yarp.IFrameGrabberControlsDC1394_getColorCodingMaskDC1394(self, video_mode)

    def getColorCodingDC1394(self):
        r"""getColorCodingDC1394(IFrameGrabberControlsDC1394 self) -> unsigned int"""
        return _yarp.IFrameGrabberControlsDC1394_getColorCodingDC1394(self)

    def setColorCodingDC1394(self, coding):
        r"""setColorCodingDC1394(IFrameGrabberControlsDC1394 self, int coding) -> bool"""
        return _yarp.IFrameGrabberControlsDC1394_setColorCodingDC1394(self, coding)

    def getFormat7MaxWindowDC1394(self, xdim, ydim, xstep, ystep, xoffstep, yoffstep):
        r"""getFormat7MaxWindowDC1394(IFrameGrabberControlsDC1394 self, unsigned int & xdim, unsigned int & ydim, unsigned int & xstep, unsigned int & ystep, unsigned int & xoffstep, unsigned int & yoffstep) -> bool"""
        return _yarp.IFrameGrabberControlsDC1394_getFormat7MaxWindowDC1394(self, xdim, ydim, xstep, ystep, xoffstep, yoffstep)

    def getFormat7WindowDC1394(self, xdim, ydim, x0, y0):
        r"""getFormat7WindowDC1394(IFrameGrabberControlsDC1394 self, unsigned int & xdim, unsigned int & ydim, int & x0, int & y0) -> bool"""
        return _yarp.IFrameGrabberControlsDC1394_getFormat7WindowDC1394(self, xdim, ydim, x0, y0)

    def setFormat7WindowDC1394(self, xdim, ydim, x0, y0):
        r"""setFormat7WindowDC1394(IFrameGrabberControlsDC1394 self, unsigned int xdim, unsigned int ydim, int x0, int y0) -> bool"""
        return _yarp.IFrameGrabberControlsDC1394_setFormat7WindowDC1394(self, xdim, ydim, x0, y0)

    def setOperationModeDC1394(self, b1394b):
        r"""setOperationModeDC1394(IFrameGrabberControlsDC1394 self, bool b1394b) -> bool"""
        return _yarp.IFrameGrabberControlsDC1394_setOperationModeDC1394(self, b1394b)

    def getOperationModeDC1394(self):
        r"""getOperationModeDC1394(IFrameGrabberControlsDC1394 self) -> bool"""
        return _yarp.IFrameGrabberControlsDC1394_getOperationModeDC1394(self)

    def setTransmissionDC1394(self, bTxON):
        r"""setTransmissionDC1394(IFrameGrabberControlsDC1394 self, bool bTxON) -> bool"""
        return _yarp.IFrameGrabberControlsDC1394_setTransmissionDC1394(self, bTxON)

    def getTransmissionDC1394(self):
        r"""getTransmissionDC1394(IFrameGrabberControlsDC1394 self) -> bool"""
        return _yarp.IFrameGrabberControlsDC1394_getTransmissionDC1394(self)

    def setBroadcastDC1394(self, onoff):
        r"""setBroadcastDC1394(IFrameGrabberControlsDC1394 self, bool onoff) -> bool"""
        return _yarp.IFrameGrabberControlsDC1394_setBroadcastDC1394(self, onoff)

    def setDefaultsDC1394(self):
        r"""setDefaultsDC1394(IFrameGrabberControlsDC1394 self) -> bool"""
        return _yarp.IFrameGrabberControlsDC1394_setDefaultsDC1394(self)

    def setResetDC1394(self):
        r"""setResetDC1394(IFrameGrabberControlsDC1394 self) -> bool"""
        return _yarp.IFrameGrabberControlsDC1394_setResetDC1394(self)

    def setPowerDC1394(self, onoff):
        r"""setPowerDC1394(IFrameGrabberControlsDC1394 self, bool onoff) -> bool"""
        return _yarp.IFrameGrabberControlsDC1394_setPowerDC1394(self, onoff)

    def setCaptureDC1394(self, bON):
        r"""setCaptureDC1394(IFrameGrabberControlsDC1394 self, bool bON) -> bool"""
        return _yarp.IFrameGrabberControlsDC1394_setCaptureDC1394(self, bON)

    def getBytesPerPacketDC1394(self):
        r"""getBytesPerPacketDC1394(IFrameGrabberControlsDC1394 self) -> unsigned int"""
        return _yarp.IFrameGrabberControlsDC1394_getBytesPerPacketDC1394(self)

    def setBytesPerPacketDC1394(self, bpp):
        r"""setBytesPerPacketDC1394(IFrameGrabberControlsDC1394 self, unsigned int bpp) -> bool"""
        return _yarp.IFrameGrabberControlsDC1394_setBytesPerPacketDC1394(self, bpp)

# Register IFrameGrabberControlsDC1394 in _yarp:
_yarp.IFrameGrabberControlsDC1394_swigregister(IFrameGrabberControlsDC1394)

class IFrameWriterImage(object):
    r"""Proxy of C++ yarp::dev::IFrameWriterImage class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _yarp.delete_IFrameWriterImage

    def putImage(self, image):
        r"""putImage(IFrameWriterImage self, ImageRgb image) -> bool"""
        return _yarp.IFrameWriterImage_putImage(self, image)

# Register IFrameWriterImage in _yarp:
_yarp.IFrameWriterImage_swigregister(IFrameWriterImage)

VOCAB_JOINTTYPE_REVOLUTE = _yarp.VOCAB_JOINTTYPE_REVOLUTE

VOCAB_JOINTTYPE_PRISMATIC = _yarp.VOCAB_JOINTTYPE_PRISMATIC

VOCAB_JOINTTYPE_UNKNOWN = _yarp.VOCAB_JOINTTYPE_UNKNOWN

class IAxisInfo(object):
    r"""Proxy of C++ yarp::dev::IAxisInfo class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _yarp.delete_IAxisInfo

    def getAxisName(self, *args):
        r"""
        getAxisName(IAxisInfo self, int axis, std::string & name) -> bool
        getAxisName(IAxisInfo self, int axis) -> std::string
        """
        return _yarp.IAxisInfo_getAxisName(self, *args)

    def getJointType(self, *args):
        r"""
        getJointType(IAxisInfo self, int axis, yarp::dev::JointTypeEnum & type) -> bool
        getJointType(IAxisInfo self, int axis) -> yarp::dev::JointTypeEnum
        """
        return _yarp.IAxisInfo_getJointType(self, *args)

# Register IAxisInfo in _yarp:
_yarp.IAxisInfo_swigregister(IAxisInfo)

class IAxisInfoRaw(object):
    r"""Proxy of C++ yarp::dev::IAxisInfoRaw class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _yarp.delete_IAxisInfoRaw

    def getAxisNameRaw(self, axis, name):
        r"""getAxisNameRaw(IAxisInfoRaw self, int axis, std::string & name) -> bool"""
        return _yarp.IAxisInfoRaw_getAxisNameRaw(self, axis, name)

    def getJointTypeRaw(self, axis, type):
        r"""getJointTypeRaw(IAxisInfoRaw self, int axis, yarp::dev::JointTypeEnum & type) -> bool"""
        return _yarp.IAxisInfoRaw_getJointTypeRaw(self, axis, type)

# Register IAxisInfoRaw in _yarp:
_yarp.IAxisInfoRaw_swigregister(IAxisInfoRaw)

class IAmplifierControl(object):
    r"""Proxy of C++ yarp::dev::IAmplifierControl class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _yarp.delete_IAmplifierControl

    def enableAmp(self, j):
        r"""enableAmp(IAmplifierControl self, int j) -> bool"""
        return _yarp.IAmplifierControl_enableAmp(self, j)

    def disableAmp(self, j):
        r"""disableAmp(IAmplifierControl self, int j) -> bool"""
        return _yarp.IAmplifierControl_disableAmp(self, j)

    def setMaxCurrent(self, j, v):
        r"""setMaxCurrent(IAmplifierControl self, int j, double v) -> bool"""
        return _yarp.IAmplifierControl_setMaxCurrent(self, j, v)

    def setNominalCurrent(self, m, val):
        r"""setNominalCurrent(IAmplifierControl self, int m, double const val) -> bool"""
        return _yarp.IAmplifierControl_setNominalCurrent(self, m, val)

    def setPeakCurrent(self, m, val):
        r"""setPeakCurrent(IAmplifierControl self, int m, double const val) -> bool"""
        return _yarp.IAmplifierControl_setPeakCurrent(self, m, val)

    def setPWMLimit(self, j, val):
        r"""setPWMLimit(IAmplifierControl self, int j, double const val) -> bool"""
        return _yarp.IAmplifierControl_setPWMLimit(self, j, val)

    def getAmpStatus(self, *args):
        r"""
        getAmpStatus(IAmplifierControl self, int * st) -> bool
        getAmpStatus(IAmplifierControl self, int j, int * v) -> bool
        getAmpStatus(IAmplifierControl self, IVector data) -> bool
        getAmpStatus(IAmplifierControl self, int j, IVector data) -> bool
        """
        return _yarp.IAmplifierControl_getAmpStatus(self, *args)

    def getCurrents(self, *args):
        r"""
        getCurrents(IAmplifierControl self, double * vals) -> bool
        getCurrents(IAmplifierControl self, DVector data) -> bool
        """
        return _yarp.IAmplifierControl_getCurrents(self, *args)

    def getCurrent(self, *args):
        r"""
        getCurrent(IAmplifierControl self, int j, double * val) -> bool
        getCurrent(IAmplifierControl self, int j, DVector data) -> bool
        """
        return _yarp.IAmplifierControl_getCurrent(self, *args)

    def getMaxCurrent(self, *args):
        r"""
        getMaxCurrent(IAmplifierControl self, int j, double * v) -> bool
        getMaxCurrent(IAmplifierControl self, int j, DVector data) -> bool
        """
        return _yarp.IAmplifierControl_getMaxCurrent(self, *args)

    def getNominalCurrent(self, *args):
        r"""
        getNominalCurrent(IAmplifierControl self, int m, double * val) -> bool
        getNominalCurrent(IAmplifierControl self, int j, DVector data) -> bool
        """
        return _yarp.IAmplifierControl_getNominalCurrent(self, *args)

    def getPeakCurrent(self, *args):
        r"""
        getPeakCurrent(IAmplifierControl self, int m, double * val) -> bool
        getPeakCurrent(IAmplifierControl self, int j, DVector data) -> bool
        """
        return _yarp.IAmplifierControl_getPeakCurrent(self, *args)

    def getPWM(self, *args):
        r"""
        getPWM(IAmplifierControl self, int j, double * val) -> bool
        getPWM(IAmplifierControl self, int j, DVector data) -> bool
        """
        return _yarp.IAmplifierControl_getPWM(self, *args)

    def getPWMLimit(self, *args):
        r"""
        getPWMLimit(IAmplifierControl self, int j, double * val) -> bool
        getPWMLimit(IAmplifierControl self, int j, DVector data) -> bool
        """
        return _yarp.IAmplifierControl_getPWMLimit(self, *args)

    def getPowerSupplyVoltage(self, *args):
        r"""
        getPowerSupplyVoltage(IAmplifierControl self, int j, double * val) -> bool
        getPowerSupplyVoltage(IAmplifierControl self, int j, DVector data) -> bool
        """
        return _yarp.IAmplifierControl_getPowerSupplyVoltage(self, *args)

# Register IAmplifierControl in _yarp:
_yarp.IAmplifierControl_swigregister(IAmplifierControl)
VOCAB_INFO_NAME = cvar.VOCAB_INFO_NAME
VOCAB_INFO_TYPE = cvar.VOCAB_INFO_TYPE

class IAmplifierControlRaw(object):
    r"""Proxy of C++ yarp::dev::IAmplifierControlRaw class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _yarp.delete_IAmplifierControlRaw

    def enableAmpRaw(self, j):
        r"""enableAmpRaw(IAmplifierControlRaw self, int j) -> bool"""
        return _yarp.IAmplifierControlRaw_enableAmpRaw(self, j)

    def disableAmpRaw(self, j):
        r"""disableAmpRaw(IAmplifierControlRaw self, int j) -> bool"""
        return _yarp.IAmplifierControlRaw_disableAmpRaw(self, j)

    def getAmpStatusRaw(self, *args):
        r"""
        getAmpStatusRaw(IAmplifierControlRaw self, int * st) -> bool
        getAmpStatusRaw(IAmplifierControlRaw self, int j, int * st) -> bool
        """
        return _yarp.IAmplifierControlRaw_getAmpStatusRaw(self, *args)

    def getCurrentsRaw(self, vals):
        r"""getCurrentsRaw(IAmplifierControlRaw self, double * vals) -> bool"""
        return _yarp.IAmplifierControlRaw_getCurrentsRaw(self, vals)

    def getCurrentRaw(self, j, val):
        r"""getCurrentRaw(IAmplifierControlRaw self, int j, double * val) -> bool"""
        return _yarp.IAmplifierControlRaw_getCurrentRaw(self, j, val)

    def setMaxCurrentRaw(self, j, v):
        r"""setMaxCurrentRaw(IAmplifierControlRaw self, int j, double v) -> bool"""
        return _yarp.IAmplifierControlRaw_setMaxCurrentRaw(self, j, v)

    def getMaxCurrentRaw(self, j, v):
        r"""getMaxCurrentRaw(IAmplifierControlRaw self, int j, double * v) -> bool"""
        return _yarp.IAmplifierControlRaw_getMaxCurrentRaw(self, j, v)

    def getNominalCurrentRaw(self, m, val):
        r"""getNominalCurrentRaw(IAmplifierControlRaw self, int m, double * val) -> bool"""
        return _yarp.IAmplifierControlRaw_getNominalCurrentRaw(self, m, val)

    def setNominalCurrentRaw(self, m, val):
        r"""setNominalCurrentRaw(IAmplifierControlRaw self, int m, double const val) -> bool"""
        return _yarp.IAmplifierControlRaw_setNominalCurrentRaw(self, m, val)

    def getPeakCurrentRaw(self, m, val):
        r"""getPeakCurrentRaw(IAmplifierControlRaw self, int m, double * val) -> bool"""
        return _yarp.IAmplifierControlRaw_getPeakCurrentRaw(self, m, val)

    def setPeakCurrentRaw(self, m, val):
        r"""setPeakCurrentRaw(IAmplifierControlRaw self, int m, double const val) -> bool"""
        return _yarp.IAmplifierControlRaw_setPeakCurrentRaw(self, m, val)

    def getPWMRaw(self, j, val):
        r"""getPWMRaw(IAmplifierControlRaw self, int j, double * val) -> bool"""
        return _yarp.IAmplifierControlRaw_getPWMRaw(self, j, val)

    def getPWMLimitRaw(self, j, val):
        r"""getPWMLimitRaw(IAmplifierControlRaw self, int j, double * val) -> bool"""
        return _yarp.IAmplifierControlRaw_getPWMLimitRaw(self, j, val)

    def setPWMLimitRaw(self, j, val):
        r"""setPWMLimitRaw(IAmplifierControlRaw self, int j, double const val) -> bool"""
        return _yarp.IAmplifierControlRaw_setPWMLimitRaw(self, j, val)

    def getPowerSupplyVoltageRaw(self, j, val):
        r"""getPowerSupplyVoltageRaw(IAmplifierControlRaw self, int j, double * val) -> bool"""
        return _yarp.IAmplifierControlRaw_getPowerSupplyVoltageRaw(self, j, val)

# Register IAmplifierControlRaw in _yarp:
_yarp.IAmplifierControlRaw_swigregister(IAmplifierControlRaw)

class IControlDebug(object):
    r"""Proxy of C++ yarp::dev::IControlDebug class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _yarp.delete_IControlDebug

    def setPrintFunction(self, f):
        r"""setPrintFunction(IControlDebug self, int (*)(char const *,...) f) -> bool"""
        return _yarp.IControlDebug_setPrintFunction(self, f)

    def loadBootMemory(self):
        r"""loadBootMemory(IControlDebug self) -> bool"""
        return _yarp.IControlDebug_loadBootMemory(self)

    def saveBootMemory(self):
        r"""saveBootMemory(IControlDebug self) -> bool"""
        return _yarp.IControlDebug_saveBootMemory(self)

# Register IControlDebug in _yarp:
_yarp.IControlDebug_swigregister(IControlDebug)
VOCAB_AMP_ENABLE = cvar.VOCAB_AMP_ENABLE
VOCAB_AMP_DISABLE = cvar.VOCAB_AMP_DISABLE
VOCAB_AMP_STATUS = cvar.VOCAB_AMP_STATUS
VOCAB_AMP_STATUS_SINGLE = cvar.VOCAB_AMP_STATUS_SINGLE
VOCAB_AMP_CURRENT = cvar.VOCAB_AMP_CURRENT
VOCAB_AMP_CURRENTS = cvar.VOCAB_AMP_CURRENTS
VOCAB_AMP_MAXCURRENT = cvar.VOCAB_AMP_MAXCURRENT
VOCAB_AMP_NOMINAL_CURRENT = cvar.VOCAB_AMP_NOMINAL_CURRENT
VOCAB_AMP_PEAK_CURRENT = cvar.VOCAB_AMP_PEAK_CURRENT
VOCAB_AMP_PWM = cvar.VOCAB_AMP_PWM
VOCAB_AMP_PWM_LIMIT = cvar.VOCAB_AMP_PWM_LIMIT
VOCAB_AMP_VOLTAGE_SUPPLY = cvar.VOCAB_AMP_VOLTAGE_SUPPLY

class IControlLimits(object):
    r"""Proxy of C++ yarp::dev::IControlLimits class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _yarp.delete_IControlLimits

    def setLimits(self, axis, min, max):
        r"""setLimits(IControlLimits self, int axis, double min, double max) -> bool"""
        return _yarp.IControlLimits_setLimits(self, axis, min, max)

    def setVelLimits(self, axis, min, max):
        r"""setVelLimits(IControlLimits self, int axis, double min, double max) -> bool"""
        return _yarp.IControlLimits_setVelLimits(self, axis, min, max)

    def getLimits(self, *args):
        r"""
        getLimits(IControlLimits self, int axis, double * min, double * max) -> bool
        getLimits(IControlLimits self, int axis, DVector min, DVector max) -> bool
        """
        return _yarp.IControlLimits_getLimits(self, *args)

    def getVelLimits(self, *args):
        r"""
        getVelLimits(IControlLimits self, int axis, double * min, double * max) -> bool
        getVelLimits(IControlLimits self, int axis, DVector min, DVector max) -> bool
        """
        return _yarp.IControlLimits_getVelLimits(self, *args)

# Register IControlLimits in _yarp:
_yarp.IControlLimits_swigregister(IControlLimits)

class IControlLimitsRaw(object):
    r"""Proxy of C++ yarp::dev::IControlLimitsRaw class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _yarp.delete_IControlLimitsRaw

    def setLimitsRaw(self, axis, min, max):
        r"""setLimitsRaw(IControlLimitsRaw self, int axis, double min, double max) -> bool"""
        return _yarp.IControlLimitsRaw_setLimitsRaw(self, axis, min, max)

    def getLimitsRaw(self, axis, min, max):
        r"""getLimitsRaw(IControlLimitsRaw self, int axis, double * min, double * max) -> bool"""
        return _yarp.IControlLimitsRaw_getLimitsRaw(self, axis, min, max)

    def setVelLimitsRaw(self, axis, min, max):
        r"""setVelLimitsRaw(IControlLimitsRaw self, int axis, double min, double max) -> bool"""
        return _yarp.IControlLimitsRaw_setVelLimitsRaw(self, axis, min, max)

    def getVelLimitsRaw(self, axis, min, max):
        r"""getVelLimitsRaw(IControlLimitsRaw self, int axis, double * min, double * max) -> bool"""
        return _yarp.IControlLimitsRaw_getVelLimitsRaw(self, axis, min, max)

# Register IControlLimitsRaw in _yarp:
_yarp.IControlLimitsRaw_swigregister(IControlLimitsRaw)

class Pid(object):
    r"""Proxy of C++ yarp::dev::Pid class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    kp = property(_yarp.Pid_kp_get, _yarp.Pid_kp_set, doc=r"""kp : double""")
    kd = property(_yarp.Pid_kd_get, _yarp.Pid_kd_set, doc=r"""kd : double""")
    ki = property(_yarp.Pid_ki_get, _yarp.Pid_ki_set, doc=r"""ki : double""")
    max_int = property(_yarp.Pid_max_int_get, _yarp.Pid_max_int_set, doc=r"""max_int : double""")
    scale = property(_yarp.Pid_scale_get, _yarp.Pid_scale_set, doc=r"""scale : double""")
    max_output = property(_yarp.Pid_max_output_get, _yarp.Pid_max_output_set, doc=r"""max_output : double""")
    offset = property(_yarp.Pid_offset_get, _yarp.Pid_offset_set, doc=r"""offset : double""")
    stiction_up_val = property(_yarp.Pid_stiction_up_val_get, _yarp.Pid_stiction_up_val_set, doc=r"""stiction_up_val : double""")
    stiction_down_val = property(_yarp.Pid_stiction_down_val_get, _yarp.Pid_stiction_down_val_set, doc=r"""stiction_down_val : double""")
    kff = property(_yarp.Pid_kff_get, _yarp.Pid_kff_set, doc=r"""kff : double""")
    __swig_destroy__ = _yarp.delete_Pid

    def __init__(self, *args):
        r"""
        __init__(Pid self) -> Pid
        __init__(Pid self, double kp, double kd, double ki, double int_max, double scale, double out_max) -> Pid
        __init__(Pid self, double kp, double kd, double ki, double int_max, double scale, double out_max, double st_up, double st_down, double kff) -> Pid
        """
        _yarp.Pid_swiginit(self, _yarp.new_Pid(*args))

    def setMaxInt(self, m):
        r"""setMaxInt(Pid self, double m)"""
        return _yarp.Pid_setMaxInt(self, m)

    def setMaxOut(self, m):
        r"""setMaxOut(Pid self, double m)"""
        return _yarp.Pid_setMaxOut(self, m)

    def setStictionValues(self, up_value, down_value):
        r"""setStictionValues(Pid self, double up_value, double down_value)"""
        return _yarp.Pid_setStictionValues(self, up_value, down_value)

    def isEqual(self, p):
        r"""isEqual(Pid self, Pid p) -> bool"""
        return _yarp.Pid_isEqual(self, p)

    def clear(self):
        r"""clear(Pid self)"""
        return _yarp.Pid_clear(self)

# Register Pid in _yarp:
_yarp.Pid_swigregister(Pid)
VOCAB_LIMITS = cvar.VOCAB_LIMITS
VOCAB_VEL_LIMITS = cvar.VOCAB_VEL_LIMITS

class CartesianEventParameters(object):
    r"""Proxy of C++ yarp::dev::CartesianEventParameters class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    type = property(_yarp.CartesianEventParameters_type_get, _yarp.CartesianEventParameters_type_set, doc=r"""type : std::string""")
    motionOngoingCheckPoint = property(_yarp.CartesianEventParameters_motionOngoingCheckPoint_get, _yarp.CartesianEventParameters_motionOngoingCheckPoint_set, doc=r"""motionOngoingCheckPoint : double""")

    def __init__(self):
        r"""__init__(CartesianEventParameters self) -> CartesianEventParameters"""
        _yarp.CartesianEventParameters_swiginit(self, _yarp.new_CartesianEventParameters())
    __swig_destroy__ = _yarp.delete_CartesianEventParameters

# Register CartesianEventParameters in _yarp:
_yarp.CartesianEventParameters_swigregister(CartesianEventParameters)

class CartesianEventVariables(object):
    r"""Proxy of C++ yarp::dev::CartesianEventVariables class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    type = property(_yarp.CartesianEventVariables_type_get, _yarp.CartesianEventVariables_type_set, doc=r"""type : std::string""")
    time = property(_yarp.CartesianEventVariables_time_get, _yarp.CartesianEventVariables_time_set, doc=r"""time : double""")
    motionOngoingCheckPoint = property(_yarp.CartesianEventVariables_motionOngoingCheckPoint_get, _yarp.CartesianEventVariables_motionOngoingCheckPoint_set, doc=r"""motionOngoingCheckPoint : double""")

    def __init__(self):
        r"""__init__(CartesianEventVariables self) -> CartesianEventVariables"""
        _yarp.CartesianEventVariables_swiginit(self, _yarp.new_CartesianEventVariables())
    __swig_destroy__ = _yarp.delete_CartesianEventVariables

# Register CartesianEventVariables in _yarp:
_yarp.CartesianEventVariables_swigregister(CartesianEventVariables)

class CartesianEvent(object):
    r"""Proxy of C++ yarp::dev::CartesianEvent class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _yarp.delete_CartesianEvent
    cartesianEventParameters = property(_yarp.CartesianEvent_cartesianEventParameters_get, _yarp.CartesianEvent_cartesianEventParameters_set, doc=r"""cartesianEventParameters : yarp::dev::CartesianEventParameters""")
    cartesianEventVariables = property(_yarp.CartesianEvent_cartesianEventVariables_get, _yarp.CartesianEvent_cartesianEventVariables_set, doc=r"""cartesianEventVariables : yarp::dev::CartesianEventVariables""")

    def cartesianEventCallback(self):
        r"""cartesianEventCallback(CartesianEvent self)"""
        return _yarp.CartesianEvent_cartesianEventCallback(self)

# Register CartesianEvent in _yarp:
_yarp.CartesianEvent_swigregister(CartesianEvent)

class ICartesianControl(object):
    r"""Proxy of C++ yarp::dev::ICartesianControl class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _yarp.delete_ICartesianControl

    def setTrackingMode(self, f):
        r"""setTrackingMode(ICartesianControl self, bool const f) -> bool"""
        return _yarp.ICartesianControl_setTrackingMode(self, f)

    def getTrackingMode(self, f):
        r"""getTrackingMode(ICartesianControl self, bool * f) -> bool"""
        return _yarp.ICartesianControl_getTrackingMode(self, f)

    def setReferenceMode(self, f):
        r"""setReferenceMode(ICartesianControl self, bool const f) -> bool"""
        return _yarp.ICartesianControl_setReferenceMode(self, f)

    def getReferenceMode(self, f):
        r"""getReferenceMode(ICartesianControl self, bool * f) -> bool"""
        return _yarp.ICartesianControl_getReferenceMode(self, f)

    def setPosePriority(self, p):
        r"""setPosePriority(ICartesianControl self, std::string const & p) -> bool"""
        return _yarp.ICartesianControl_setPosePriority(self, p)

    def getPosePriority(self, p):
        r"""getPosePriority(ICartesianControl self, std::string & p) -> bool"""
        return _yarp.ICartesianControl_getPosePriority(self, p)

    def getPose(self, *args):
        r"""
        getPose(ICartesianControl self, Vector x, Vector o, Stamp stamp=None) -> bool
        getPose(ICartesianControl self, int const axis, Vector x, Vector o, Stamp stamp=None) -> bool
        """
        return _yarp.ICartesianControl_getPose(self, *args)

    def goToPose(self, xd, od, t=0.0):
        r"""goToPose(ICartesianControl self, Vector xd, Vector od, double const t=0.0) -> bool"""
        return _yarp.ICartesianControl_goToPose(self, xd, od, t)

    def goToPosition(self, xd, t=0.0):
        r"""goToPosition(ICartesianControl self, Vector xd, double const t=0.0) -> bool"""
        return _yarp.ICartesianControl_goToPosition(self, xd, t)

    def goToPoseSync(self, xd, od, t=0.0):
        r"""goToPoseSync(ICartesianControl self, Vector xd, Vector od, double const t=0.0) -> bool"""
        return _yarp.ICartesianControl_goToPoseSync(self, xd, od, t)

    def goToPositionSync(self, xd, t=0.0):
        r"""goToPositionSync(ICartesianControl self, Vector xd, double const t=0.0) -> bool"""
        return _yarp.ICartesianControl_goToPositionSync(self, xd, t)

    def getDesired(self, xdhat, odhat, qdhat):
        r"""getDesired(ICartesianControl self, Vector xdhat, Vector odhat, Vector qdhat) -> bool"""
        return _yarp.ICartesianControl_getDesired(self, xdhat, odhat, qdhat)

    def askForPose(self, *args):
        r"""
        askForPose(ICartesianControl self, Vector xd, Vector od, Vector xdhat, Vector odhat, Vector qdhat) -> bool
        askForPose(ICartesianControl self, Vector q0, Vector xd, Vector od, Vector xdhat, Vector odhat, Vector qdhat) -> bool
        """
        return _yarp.ICartesianControl_askForPose(self, *args)

    def askForPosition(self, *args):
        r"""
        askForPosition(ICartesianControl self, Vector xd, Vector xdhat, Vector odhat, Vector qdhat) -> bool
        askForPosition(ICartesianControl self, Vector q0, Vector xd, Vector xdhat, Vector odhat, Vector qdhat) -> bool
        """
        return _yarp.ICartesianControl_askForPosition(self, *args)

    def getDOF(self, curDof):
        r"""getDOF(ICartesianControl self, Vector curDof) -> bool"""
        return _yarp.ICartesianControl_getDOF(self, curDof)

    def setDOF(self, newDof, curDof):
        r"""setDOF(ICartesianControl self, Vector newDof, Vector curDof) -> bool"""
        return _yarp.ICartesianControl_setDOF(self, newDof, curDof)

    def getRestPos(self, curRestPos):
        r"""getRestPos(ICartesianControl self, Vector curRestPos) -> bool"""
        return _yarp.ICartesianControl_getRestPos(self, curRestPos)

    def setRestPos(self, newRestPos, curRestPos):
        r"""setRestPos(ICartesianControl self, Vector newRestPos, Vector curRestPos) -> bool"""
        return _yarp.ICartesianControl_setRestPos(self, newRestPos, curRestPos)

    def getRestWeights(self, curRestWeights):
        r"""getRestWeights(ICartesianControl self, Vector curRestWeights) -> bool"""
        return _yarp.ICartesianControl_getRestWeights(self, curRestWeights)

    def setRestWeights(self, newRestWeights, curRestWeights):
        r"""setRestWeights(ICartesianControl self, Vector newRestWeights, Vector curRestWeights) -> bool"""
        return _yarp.ICartesianControl_setRestWeights(self, newRestWeights, curRestWeights)

    def getLimits(self, axis, min, max):
        r"""getLimits(ICartesianControl self, int const axis, double * min, double * max) -> bool"""
        return _yarp.ICartesianControl_getLimits(self, axis, min, max)

    def setLimits(self, axis, min, max):
        r"""setLimits(ICartesianControl self, int const axis, double const min, double const max) -> bool"""
        return _yarp.ICartesianControl_setLimits(self, axis, min, max)

    def getTrajTime(self, t):
        r"""getTrajTime(ICartesianControl self, double * t) -> bool"""
        return _yarp.ICartesianControl_getTrajTime(self, t)

    def setTrajTime(self, t):
        r"""setTrajTime(ICartesianControl self, double const t) -> bool"""
        return _yarp.ICartesianControl_setTrajTime(self, t)

    def getInTargetTol(self, tol):
        r"""getInTargetTol(ICartesianControl self, double * tol) -> bool"""
        return _yarp.ICartesianControl_getInTargetTol(self, tol)

    def setInTargetTol(self, tol):
        r"""setInTargetTol(ICartesianControl self, double const tol) -> bool"""
        return _yarp.ICartesianControl_setInTargetTol(self, tol)

    def getJointsVelocities(self, qdot):
        r"""getJointsVelocities(ICartesianControl self, Vector qdot) -> bool"""
        return _yarp.ICartesianControl_getJointsVelocities(self, qdot)

    def getTaskVelocities(self, xdot, odot):
        r"""getTaskVelocities(ICartesianControl self, Vector xdot, Vector odot) -> bool"""
        return _yarp.ICartesianControl_getTaskVelocities(self, xdot, odot)

    def setTaskVelocities(self, xdot, odot):
        r"""setTaskVelocities(ICartesianControl self, Vector xdot, Vector odot) -> bool"""
        return _yarp.ICartesianControl_setTaskVelocities(self, xdot, odot)

    def attachTipFrame(self, x, o):
        r"""attachTipFrame(ICartesianControl self, Vector x, Vector o) -> bool"""
        return _yarp.ICartesianControl_attachTipFrame(self, x, o)

    def getTipFrame(self, x, o):
        r"""getTipFrame(ICartesianControl self, Vector x, Vector o) -> bool"""
        return _yarp.ICartesianControl_getTipFrame(self, x, o)

    def removeTipFrame(self):
        r"""removeTipFrame(ICartesianControl self) -> bool"""
        return _yarp.ICartesianControl_removeTipFrame(self)

    def waitMotionDone(self, period=0.1, timeout=0.0):
        r"""waitMotionDone(ICartesianControl self, double const period=0.1, double const timeout=0.0) -> bool"""
        return _yarp.ICartesianControl_waitMotionDone(self, period, timeout)

    def stopControl(self):
        r"""stopControl(ICartesianControl self) -> bool"""
        return _yarp.ICartesianControl_stopControl(self)

    def restoreContext(self, id):
        r"""restoreContext(ICartesianControl self, int const id) -> bool"""
        return _yarp.ICartesianControl_restoreContext(self, id)

    def deleteContext(self, id):
        r"""deleteContext(ICartesianControl self, int const id) -> bool"""
        return _yarp.ICartesianControl_deleteContext(self, id)

    def getInfo(self, info):
        r"""getInfo(ICartesianControl self, Bottle info) -> bool"""
        return _yarp.ICartesianControl_getInfo(self, info)

    def registerEvent(self, event):
        r"""registerEvent(ICartesianControl self, CartesianEvent event) -> bool"""
        return _yarp.ICartesianControl_registerEvent(self, event)

    def unregisterEvent(self, event):
        r"""unregisterEvent(ICartesianControl self, CartesianEvent event) -> bool"""
        return _yarp.ICartesianControl_unregisterEvent(self, event)

    def tweakSet(self, options):
        r"""tweakSet(ICartesianControl self, Bottle options) -> bool"""
        return _yarp.ICartesianControl_tweakSet(self, options)

    def tweakGet(self, options):
        r"""tweakGet(ICartesianControl self, Bottle options) -> bool"""
        return _yarp.ICartesianControl_tweakGet(self, options)

    def checkMotionDone(self, *args):
        r"""
        checkMotionDone(ICartesianControl self, bool * f) -> bool
        checkMotionDone(ICartesianControl self, BVector flag) -> bool
        checkMotionDone(ICartesianControl self) -> bool
        """
        return _yarp.ICartesianControl_checkMotionDone(self, *args)

    def isMotionDone(self):
        r"""isMotionDone(ICartesianControl self) -> bool"""
        return _yarp.ICartesianControl_isMotionDone(self)

    def storeContext(self, *args):
        r"""
        storeContext(ICartesianControl self, int * id) -> bool
        storeContext(ICartesianControl self) -> int
        """
        return _yarp.ICartesianControl_storeContext(self, *args)

# Register ICartesianControl in _yarp:
_yarp.ICartesianControl_swigregister(ICartesianControl)

class GazeEventParameters(object):
    r"""Proxy of C++ yarp::dev::GazeEventParameters class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    type = property(_yarp.GazeEventParameters_type_get, _yarp.GazeEventParameters_type_set, doc=r"""type : std::string""")
    motionOngoingCheckPoint = property(_yarp.GazeEventParameters_motionOngoingCheckPoint_get, _yarp.GazeEventParameters_motionOngoingCheckPoint_set, doc=r"""motionOngoingCheckPoint : double""")

    def __init__(self):
        r"""__init__(GazeEventParameters self) -> GazeEventParameters"""
        _yarp.GazeEventParameters_swiginit(self, _yarp.new_GazeEventParameters())
    __swig_destroy__ = _yarp.delete_GazeEventParameters

# Register GazeEventParameters in _yarp:
_yarp.GazeEventParameters_swigregister(GazeEventParameters)

class GazeEventVariables(object):
    r"""Proxy of C++ yarp::dev::GazeEventVariables class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    type = property(_yarp.GazeEventVariables_type_get, _yarp.GazeEventVariables_type_set, doc=r"""type : std::string""")
    time = property(_yarp.GazeEventVariables_time_get, _yarp.GazeEventVariables_time_set, doc=r"""time : double""")
    motionOngoingCheckPoint = property(_yarp.GazeEventVariables_motionOngoingCheckPoint_get, _yarp.GazeEventVariables_motionOngoingCheckPoint_set, doc=r"""motionOngoingCheckPoint : double""")

    def __init__(self):
        r"""__init__(GazeEventVariables self) -> GazeEventVariables"""
        _yarp.GazeEventVariables_swiginit(self, _yarp.new_GazeEventVariables())
    __swig_destroy__ = _yarp.delete_GazeEventVariables

# Register GazeEventVariables in _yarp:
_yarp.GazeEventVariables_swigregister(GazeEventVariables)

class GazeEvent(object):
    r"""Proxy of C++ yarp::dev::GazeEvent class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _yarp.delete_GazeEvent
    gazeEventParameters = property(_yarp.GazeEvent_gazeEventParameters_get, _yarp.GazeEvent_gazeEventParameters_set, doc=r"""gazeEventParameters : yarp::dev::GazeEventParameters""")
    gazeEventVariables = property(_yarp.GazeEvent_gazeEventVariables_get, _yarp.GazeEvent_gazeEventVariables_set, doc=r"""gazeEventVariables : yarp::dev::GazeEventVariables""")

    def gazeEventCallback(self):
        r"""gazeEventCallback(GazeEvent self)"""
        return _yarp.GazeEvent_gazeEventCallback(self)

# Register GazeEvent in _yarp:
_yarp.GazeEvent_swigregister(GazeEvent)

class IGazeControl(object):
    r"""Proxy of C++ yarp::dev::IGazeControl class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _yarp.delete_IGazeControl

    def setTrackingMode(self, f):
        r"""setTrackingMode(IGazeControl self, bool const f) -> bool"""
        return _yarp.IGazeControl_setTrackingMode(self, f)

    def setStabilizationMode(self, f):
        r"""setStabilizationMode(IGazeControl self, bool const f) -> bool"""
        return _yarp.IGazeControl_setStabilizationMode(self, f)

    def getStabilizationMode(self, f):
        r"""getStabilizationMode(IGazeControl self, bool * f) -> bool"""
        return _yarp.IGazeControl_getStabilizationMode(self, f)

    def getFixationPoint(self, fp, stamp=None):
        r"""getFixationPoint(IGazeControl self, Vector fp, Stamp stamp=None) -> bool"""
        return _yarp.IGazeControl_getFixationPoint(self, fp, stamp)

    def getAngles(self, ang, stamp=None):
        r"""getAngles(IGazeControl self, Vector ang, Stamp stamp=None) -> bool"""
        return _yarp.IGazeControl_getAngles(self, ang, stamp)

    def lookAtFixationPoint(self, fp):
        r"""lookAtFixationPoint(IGazeControl self, Vector fp) -> bool"""
        return _yarp.IGazeControl_lookAtFixationPoint(self, fp)

    def lookAtAbsAngles(self, ang):
        r"""lookAtAbsAngles(IGazeControl self, Vector ang) -> bool"""
        return _yarp.IGazeControl_lookAtAbsAngles(self, ang)

    def lookAtRelAngles(self, ang):
        r"""lookAtRelAngles(IGazeControl self, Vector ang) -> bool"""
        return _yarp.IGazeControl_lookAtRelAngles(self, ang)

    def lookAtMonoPixel(self, camSel, px, z=1.0):
        r"""lookAtMonoPixel(IGazeControl self, int const camSel, Vector px, double const z=1.0) -> bool"""
        return _yarp.IGazeControl_lookAtMonoPixel(self, camSel, px, z)

    def lookAtMonoPixelWithVergence(self, camSel, px, ver):
        r"""lookAtMonoPixelWithVergence(IGazeControl self, int const camSel, Vector px, double const ver) -> bool"""
        return _yarp.IGazeControl_lookAtMonoPixelWithVergence(self, camSel, px, ver)

    def lookAtStereoPixels(self, pxl, pxr):
        r"""lookAtStereoPixels(IGazeControl self, Vector pxl, Vector pxr) -> bool"""
        return _yarp.IGazeControl_lookAtStereoPixels(self, pxl, pxr)

    def lookAtFixationPointSync(self, fp):
        r"""lookAtFixationPointSync(IGazeControl self, Vector fp) -> bool"""
        return _yarp.IGazeControl_lookAtFixationPointSync(self, fp)

    def lookAtAbsAnglesSync(self, ang):
        r"""lookAtAbsAnglesSync(IGazeControl self, Vector ang) -> bool"""
        return _yarp.IGazeControl_lookAtAbsAnglesSync(self, ang)

    def lookAtRelAnglesSync(self, ang):
        r"""lookAtRelAnglesSync(IGazeControl self, Vector ang) -> bool"""
        return _yarp.IGazeControl_lookAtRelAnglesSync(self, ang)

    def lookAtMonoPixelSync(self, camSel, px, z=1.0):
        r"""lookAtMonoPixelSync(IGazeControl self, int const camSel, Vector px, double const z=1.0) -> bool"""
        return _yarp.IGazeControl_lookAtMonoPixelSync(self, camSel, px, z)

    def lookAtMonoPixelWithVergenceSync(self, camSel, px, ver):
        r"""lookAtMonoPixelWithVergenceSync(IGazeControl self, int const camSel, Vector px, double const ver) -> bool"""
        return _yarp.IGazeControl_lookAtMonoPixelWithVergenceSync(self, camSel, px, ver)

    def lookAtStereoPixelsSync(self, pxl, pxr):
        r"""lookAtStereoPixelsSync(IGazeControl self, Vector pxl, Vector pxr) -> bool"""
        return _yarp.IGazeControl_lookAtStereoPixelsSync(self, pxl, pxr)

    def getVORGain(self, gain):
        r"""getVORGain(IGazeControl self, double * gain) -> bool"""
        return _yarp.IGazeControl_getVORGain(self, gain)

    def getOCRGain(self, gain):
        r"""getOCRGain(IGazeControl self, double * gain) -> bool"""
        return _yarp.IGazeControl_getOCRGain(self, gain)

    def getSaccadesMode(self, f):
        r"""getSaccadesMode(IGazeControl self, bool * f) -> bool"""
        return _yarp.IGazeControl_getSaccadesMode(self, f)

    def getSaccadesInhibitionPeriod(self, period):
        r"""getSaccadesInhibitionPeriod(IGazeControl self, double * period) -> bool"""
        return _yarp.IGazeControl_getSaccadesInhibitionPeriod(self, period)

    def getSaccadesActivationAngle(self, angle):
        r"""getSaccadesActivationAngle(IGazeControl self, double * angle) -> bool"""
        return _yarp.IGazeControl_getSaccadesActivationAngle(self, angle)

    def getLeftEyePose(self, x, o, stamp=None):
        r"""getLeftEyePose(IGazeControl self, Vector x, Vector o, Stamp stamp=None) -> bool"""
        return _yarp.IGazeControl_getLeftEyePose(self, x, o, stamp)

    def getRightEyePose(self, x, o, stamp=None):
        r"""getRightEyePose(IGazeControl self, Vector x, Vector o, Stamp stamp=None) -> bool"""
        return _yarp.IGazeControl_getRightEyePose(self, x, o, stamp)

    def getHeadPose(self, x, o, stamp=None):
        r"""getHeadPose(IGazeControl self, Vector x, Vector o, Stamp stamp=None) -> bool"""
        return _yarp.IGazeControl_getHeadPose(self, x, o, stamp)

    def get2DPixel(self, camSel, x, px):
        r"""get2DPixel(IGazeControl self, int const camSel, Vector x, Vector px) -> bool"""
        return _yarp.IGazeControl_get2DPixel(self, camSel, x, px)

    def get3DPoint(self, camSel, px, z, x):
        r"""get3DPoint(IGazeControl self, int const camSel, Vector px, double const z, Vector x) -> bool"""
        return _yarp.IGazeControl_get3DPoint(self, camSel, px, z, x)

    def get3DPointOnPlane(self, camSel, px, plane, x):
        r"""get3DPointOnPlane(IGazeControl self, int const camSel, Vector px, Vector plane, Vector x) -> bool"""
        return _yarp.IGazeControl_get3DPointOnPlane(self, camSel, px, plane, x)

    def get3DPointFromAngles(self, mode, ang, x):
        r"""get3DPointFromAngles(IGazeControl self, int const mode, Vector ang, Vector x) -> bool"""
        return _yarp.IGazeControl_get3DPointFromAngles(self, mode, ang, x)

    def getAnglesFrom3DPoint(self, x, ang):
        r"""getAnglesFrom3DPoint(IGazeControl self, Vector x, Vector ang) -> bool"""
        return _yarp.IGazeControl_getAnglesFrom3DPoint(self, x, ang)

    def triangulate3DPoint(self, pxl, pxr, x):
        r"""triangulate3DPoint(IGazeControl self, Vector pxl, Vector pxr, Vector x) -> bool"""
        return _yarp.IGazeControl_triangulate3DPoint(self, pxl, pxr, x)

    def getJointsDesired(self, qdes):
        r"""getJointsDesired(IGazeControl self, Vector qdes) -> bool"""
        return _yarp.IGazeControl_getJointsDesired(self, qdes)

    def getJointsVelocities(self, qdot):
        r"""getJointsVelocities(IGazeControl self, Vector qdot) -> bool"""
        return _yarp.IGazeControl_getJointsVelocities(self, qdot)

    def getStereoOptions(self, options):
        r"""getStereoOptions(IGazeControl self, Bottle options) -> bool"""
        return _yarp.IGazeControl_getStereoOptions(self, options)

    def setNeckTrajTime(self, t):
        r"""setNeckTrajTime(IGazeControl self, double const t) -> bool"""
        return _yarp.IGazeControl_setNeckTrajTime(self, t)

    def setEyesTrajTime(self, t):
        r"""setEyesTrajTime(IGazeControl self, double const t) -> bool"""
        return _yarp.IGazeControl_setEyesTrajTime(self, t)

    def setVORGain(self, gain):
        r"""setVORGain(IGazeControl self, double const gain) -> bool"""
        return _yarp.IGazeControl_setVORGain(self, gain)

    def setOCRGain(self, gain):
        r"""setOCRGain(IGazeControl self, double const gain) -> bool"""
        return _yarp.IGazeControl_setOCRGain(self, gain)

    def setSaccadesMode(self, f):
        r"""setSaccadesMode(IGazeControl self, bool const f) -> bool"""
        return _yarp.IGazeControl_setSaccadesMode(self, f)

    def setSaccadesInhibitionPeriod(self, period):
        r"""setSaccadesInhibitionPeriod(IGazeControl self, double const period) -> bool"""
        return _yarp.IGazeControl_setSaccadesInhibitionPeriod(self, period)

    def setSaccadesActivationAngle(self, angle):
        r"""setSaccadesActivationAngle(IGazeControl self, double const angle) -> bool"""
        return _yarp.IGazeControl_setSaccadesActivationAngle(self, angle)

    def setStereoOptions(self, options):
        r"""setStereoOptions(IGazeControl self, Bottle options) -> bool"""
        return _yarp.IGazeControl_setStereoOptions(self, options)

    def bindNeckPitch(self, min, max):
        r"""bindNeckPitch(IGazeControl self, double const min, double const max) -> bool"""
        return _yarp.IGazeControl_bindNeckPitch(self, min, max)

    def blockNeckPitch(self, *args):
        r"""
        blockNeckPitch(IGazeControl self, double const val) -> bool
        blockNeckPitch(IGazeControl self) -> bool
        """
        return _yarp.IGazeControl_blockNeckPitch(self, *args)

    def bindNeckRoll(self, min, max):
        r"""bindNeckRoll(IGazeControl self, double const min, double const max) -> bool"""
        return _yarp.IGazeControl_bindNeckRoll(self, min, max)

    def blockNeckRoll(self, *args):
        r"""
        blockNeckRoll(IGazeControl self, double const val) -> bool
        blockNeckRoll(IGazeControl self) -> bool
        """
        return _yarp.IGazeControl_blockNeckRoll(self, *args)

    def bindNeckYaw(self, min, max):
        r"""bindNeckYaw(IGazeControl self, double const min, double const max) -> bool"""
        return _yarp.IGazeControl_bindNeckYaw(self, min, max)

    def blockNeckYaw(self, *args):
        r"""
        blockNeckYaw(IGazeControl self, double const val) -> bool
        blockNeckYaw(IGazeControl self) -> bool
        """
        return _yarp.IGazeControl_blockNeckYaw(self, *args)

    def blockEyes(self, *args):
        r"""
        blockEyes(IGazeControl self, double const ver) -> bool
        blockEyes(IGazeControl self) -> bool
        """
        return _yarp.IGazeControl_blockEyes(self, *args)

    def getNeckPitchRange(self, min, max):
        r"""getNeckPitchRange(IGazeControl self, double * min, double * max) -> bool"""
        return _yarp.IGazeControl_getNeckPitchRange(self, min, max)

    def getNeckRollRange(self, min, max):
        r"""getNeckRollRange(IGazeControl self, double * min, double * max) -> bool"""
        return _yarp.IGazeControl_getNeckRollRange(self, min, max)

    def getNeckYawRange(self, min, max):
        r"""getNeckYawRange(IGazeControl self, double * min, double * max) -> bool"""
        return _yarp.IGazeControl_getNeckYawRange(self, min, max)

    def getBlockedVergence(self, ver):
        r"""getBlockedVergence(IGazeControl self, double * ver) -> bool"""
        return _yarp.IGazeControl_getBlockedVergence(self, ver)

    def clearNeckPitch(self):
        r"""clearNeckPitch(IGazeControl self) -> bool"""
        return _yarp.IGazeControl_clearNeckPitch(self)

    def clearNeckRoll(self):
        r"""clearNeckRoll(IGazeControl self) -> bool"""
        return _yarp.IGazeControl_clearNeckRoll(self)

    def clearNeckYaw(self):
        r"""clearNeckYaw(IGazeControl self) -> bool"""
        return _yarp.IGazeControl_clearNeckYaw(self)

    def clearEyes(self):
        r"""clearEyes(IGazeControl self) -> bool"""
        return _yarp.IGazeControl_clearEyes(self)

    def getNeckAngleUserTolerance(self, angle):
        r"""getNeckAngleUserTolerance(IGazeControl self, double * angle) -> bool"""
        return _yarp.IGazeControl_getNeckAngleUserTolerance(self, angle)

    def setNeckAngleUserTolerance(self, angle):
        r"""setNeckAngleUserTolerance(IGazeControl self, double const angle) -> bool"""
        return _yarp.IGazeControl_setNeckAngleUserTolerance(self, angle)

    def waitMotionDone(self, period=0.1, timeout=0.0):
        r"""waitMotionDone(IGazeControl self, double const period=0.1, double const timeout=0.0) -> bool"""
        return _yarp.IGazeControl_waitMotionDone(self, period, timeout)

    def checkSaccadeDone(self, f):
        r"""checkSaccadeDone(IGazeControl self, bool * f) -> bool"""
        return _yarp.IGazeControl_checkSaccadeDone(self, f)

    def waitSaccadeDone(self, period=0.1, timeout=0.0):
        r"""waitSaccadeDone(IGazeControl self, double const period=0.1, double const timeout=0.0) -> bool"""
        return _yarp.IGazeControl_waitSaccadeDone(self, period, timeout)

    def stopControl(self):
        r"""stopControl(IGazeControl self) -> bool"""
        return _yarp.IGazeControl_stopControl(self)

    def storeContext(self, id):
        r"""storeContext(IGazeControl self, int * id) -> bool"""
        return _yarp.IGazeControl_storeContext(self, id)

    def restoreContext(self, id):
        r"""restoreContext(IGazeControl self, int const id) -> bool"""
        return _yarp.IGazeControl_restoreContext(self, id)

    def deleteContext(self, id):
        r"""deleteContext(IGazeControl self, int const id) -> bool"""
        return _yarp.IGazeControl_deleteContext(self, id)

    def getInfo(self, info):
        r"""getInfo(IGazeControl self, Bottle info) -> bool"""
        return _yarp.IGazeControl_getInfo(self, info)

    def registerEvent(self, event):
        r"""registerEvent(IGazeControl self, GazeEvent event) -> bool"""
        return _yarp.IGazeControl_registerEvent(self, event)

    def unregisterEvent(self, event):
        r"""unregisterEvent(IGazeControl self, GazeEvent event) -> bool"""
        return _yarp.IGazeControl_unregisterEvent(self, event)

    def tweakSet(self, options):
        r"""tweakSet(IGazeControl self, Bottle options) -> bool"""
        return _yarp.IGazeControl_tweakSet(self, options)

    def tweakGet(self, options):
        r"""tweakGet(IGazeControl self, Bottle options) -> bool"""
        return _yarp.IGazeControl_tweakGet(self, options)

    def getTrackingMode(self, *args):
        r"""
        getTrackingMode(IGazeControl self, bool * f) -> bool
        getTrackingMode(IGazeControl self) -> bool
        """
        return _yarp.IGazeControl_getTrackingMode(self, *args)

    def getNeckTrajTime(self, *args):
        r"""
        getNeckTrajTime(IGazeControl self, double * t) -> bool
        getNeckTrajTime(IGazeControl self) -> double
        """
        return _yarp.IGazeControl_getNeckTrajTime(self, *args)

    def getEyesTrajTime(self, *args):
        r"""
        getEyesTrajTime(IGazeControl self, double * t) -> bool
        getEyesTrajTime(IGazeControl self) -> double
        """
        return _yarp.IGazeControl_getEyesTrajTime(self, *args)

    def checkMotionDone(self, *args):
        r"""
        checkMotionDone(IGazeControl self, bool * f) -> bool
        checkMotionDone(IGazeControl self) -> bool
        """
        return _yarp.IGazeControl_checkMotionDone(self, *args)

# Register IGazeControl in _yarp:
_yarp.IGazeControl_swigregister(IGazeControl)

class IPositionControlRaw(object):
    r"""Proxy of C++ yarp::dev::IPositionControlRaw class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _yarp.delete_IPositionControlRaw

    def getAxes(self, ax):
        r"""getAxes(IPositionControlRaw self, int * ax) -> bool"""
        return _yarp.IPositionControlRaw_getAxes(self, ax)

    def setRefSpeedRaw(self, j, sp):
        r"""setRefSpeedRaw(IPositionControlRaw self, int j, double sp) -> bool"""
        return _yarp.IPositionControlRaw_setRefSpeedRaw(self, j, sp)

    def setRefAccelerationRaw(self, j, acc):
        r"""setRefAccelerationRaw(IPositionControlRaw self, int j, double acc) -> bool"""
        return _yarp.IPositionControlRaw_setRefAccelerationRaw(self, j, acc)

    def getRefSpeedRaw(self, j, ref):
        r"""getRefSpeedRaw(IPositionControlRaw self, int j, double * ref) -> bool"""
        return _yarp.IPositionControlRaw_getRefSpeedRaw(self, j, ref)

    def getRefAccelerationRaw(self, j, acc):
        r"""getRefAccelerationRaw(IPositionControlRaw self, int j, double * acc) -> bool"""
        return _yarp.IPositionControlRaw_getRefAccelerationRaw(self, j, acc)

    def positionMoveRaw(self, *args):
        r"""
        positionMoveRaw(IPositionControlRaw self, int j, double ref) -> bool
        positionMoveRaw(IPositionControlRaw self, double const * refs) -> bool
        positionMoveRaw(IPositionControlRaw self, int const n_joint, int const * joints, double const * refs) -> bool
        """
        return _yarp.IPositionControlRaw_positionMoveRaw(self, *args)

    def relativeMoveRaw(self, *args):
        r"""
        relativeMoveRaw(IPositionControlRaw self, int j, double delta) -> bool
        relativeMoveRaw(IPositionControlRaw self, double const * deltas) -> bool
        relativeMoveRaw(IPositionControlRaw self, int const n_joint, int const * joints, double const * deltas) -> bool
        """
        return _yarp.IPositionControlRaw_relativeMoveRaw(self, *args)

    def checkMotionDoneRaw(self, *args):
        r"""
        checkMotionDoneRaw(IPositionControlRaw self, int j, bool * flag) -> bool
        checkMotionDoneRaw(IPositionControlRaw self, bool * flag) -> bool
        checkMotionDoneRaw(IPositionControlRaw self, int const n_joint, int const * joints, bool * flags) -> bool
        """
        return _yarp.IPositionControlRaw_checkMotionDoneRaw(self, *args)

    def setRefSpeedsRaw(self, *args):
        r"""
        setRefSpeedsRaw(IPositionControlRaw self, double const * spds) -> bool
        setRefSpeedsRaw(IPositionControlRaw self, int const n_joint, int const * joints, double const * spds) -> bool
        """
        return _yarp.IPositionControlRaw_setRefSpeedsRaw(self, *args)

    def setRefAccelerationsRaw(self, *args):
        r"""
        setRefAccelerationsRaw(IPositionControlRaw self, double const * accs) -> bool
        setRefAccelerationsRaw(IPositionControlRaw self, int const n_joint, int const * joints, double const * accs) -> bool
        """
        return _yarp.IPositionControlRaw_setRefAccelerationsRaw(self, *args)

    def getRefSpeedsRaw(self, *args):
        r"""
        getRefSpeedsRaw(IPositionControlRaw self, double * spds) -> bool
        getRefSpeedsRaw(IPositionControlRaw self, int const n_joint, int const * joints, double * spds) -> bool
        """
        return _yarp.IPositionControlRaw_getRefSpeedsRaw(self, *args)

    def getRefAccelerationsRaw(self, *args):
        r"""
        getRefAccelerationsRaw(IPositionControlRaw self, double * accs) -> bool
        getRefAccelerationsRaw(IPositionControlRaw self, int const n_joint, int const * joints, double * accs) -> bool
        """
        return _yarp.IPositionControlRaw_getRefAccelerationsRaw(self, *args)

    def stopRaw(self, *args):
        r"""
        stopRaw(IPositionControlRaw self, int j) -> bool
        stopRaw(IPositionControlRaw self) -> bool
        stopRaw(IPositionControlRaw self, int const n_joint, int const * joints) -> bool
        """
        return _yarp.IPositionControlRaw_stopRaw(self, *args)

    def getTargetPositionRaw(self, joint, ref):
        r"""getTargetPositionRaw(IPositionControlRaw self, int const joint, double * ref) -> bool"""
        return _yarp.IPositionControlRaw_getTargetPositionRaw(self, joint, ref)

    def getTargetPositionsRaw(self, *args):
        r"""
        getTargetPositionsRaw(IPositionControlRaw self, double * refs) -> bool
        getTargetPositionsRaw(IPositionControlRaw self, int const n_joint, int const * joints, double * refs) -> bool
        """
        return _yarp.IPositionControlRaw_getTargetPositionsRaw(self, *args)

# Register IPositionControlRaw in _yarp:
_yarp.IPositionControlRaw_swigregister(IPositionControlRaw)

class IPositionControl(object):
    r"""Proxy of C++ yarp::dev::IPositionControl class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _yarp.delete_IPositionControl

    def setRefSpeed(self, j, sp):
        r"""setRefSpeed(IPositionControl self, int j, double sp) -> bool"""
        return _yarp.IPositionControl_setRefSpeed(self, j, sp)

    def setRefAcceleration(self, j, acc):
        r"""setRefAcceleration(IPositionControl self, int j, double acc) -> bool"""
        return _yarp.IPositionControl_setRefAcceleration(self, j, acc)

    def getAxes(self, *args):
        r"""
        getAxes(IPositionControl self, int * ax) -> bool
        getAxes(IPositionControl self) -> int
        """
        return _yarp.IPositionControl_getAxes(self, *args)

    def positionMove(self, *args):
        r"""
        positionMove(IPositionControl self, int j, double ref) -> bool
        positionMove(IPositionControl self, double const * refs) -> bool
        positionMove(IPositionControl self, int const n_joint, int const * joints, double const * refs) -> bool
        positionMove(IPositionControl self, DVector data) -> bool
        positionMove(IPositionControl self, int n_joint, IVector joints, DVector data) -> bool
        """
        return _yarp.IPositionControl_positionMove(self, *args)

    def relativeMove(self, *args):
        r"""
        relativeMove(IPositionControl self, int j, double delta) -> bool
        relativeMove(IPositionControl self, double const * deltas) -> bool
        relativeMove(IPositionControl self, int const n_joint, int const * joints, double const * deltas) -> bool
        relativeMove(IPositionControl self, DVector data) -> bool
        relativeMove(IPositionControl self, int n_joint, IVector joints, DVector data) -> bool
        """
        return _yarp.IPositionControl_relativeMove(self, *args)

    def setRefSpeeds(self, *args):
        r"""
        setRefSpeeds(IPositionControl self, double const * spds) -> bool
        setRefSpeeds(IPositionControl self, int const n_joint, int const * joints, double const * spds) -> bool
        setRefSpeeds(IPositionControl self, DVector data) -> bool
        setRefSpeeds(IPositionControl self, int n_joint, IVector joints, DVector data) -> bool
        """
        return _yarp.IPositionControl_setRefSpeeds(self, *args)

    def getRefSpeed(self, *args):
        r"""
        getRefSpeed(IPositionControl self, int j, double * ref) -> bool
        getRefSpeed(IPositionControl self, int j, DVector data) -> bool
        """
        return _yarp.IPositionControl_getRefSpeed(self, *args)

    def getRefSpeeds(self, *args):
        r"""
        getRefSpeeds(IPositionControl self, double * spds) -> bool
        getRefSpeeds(IPositionControl self, int const n_joint, int const * joints, double * spds) -> bool
        getRefSpeeds(IPositionControl self, DVector data) -> bool
        getRefSpeeds(IPositionControl self, int n_joint, IVector joints, DVector data) -> bool
        """
        return _yarp.IPositionControl_getRefSpeeds(self, *args)

    def setRefAccelerations(self, *args):
        r"""
        setRefAccelerations(IPositionControl self, double const * accs) -> bool
        setRefAccelerations(IPositionControl self, int const n_joint, int const * joints, double const * accs) -> bool
        setRefAccelerations(IPositionControl self, DVector data) -> bool
        setRefAccelerations(IPositionControl self, int n_joint, IVector joints, DVector data) -> bool
        """
        return _yarp.IPositionControl_setRefAccelerations(self, *args)

    def getRefAcceleration(self, *args):
        r"""
        getRefAcceleration(IPositionControl self, int j, double * acc) -> bool
        getRefAcceleration(IPositionControl self, int j, DVector data) -> bool
        """
        return _yarp.IPositionControl_getRefAcceleration(self, *args)

    def getRefAccelerations(self, *args):
        r"""
        getRefAccelerations(IPositionControl self, double * accs) -> bool
        getRefAccelerations(IPositionControl self, int const n_joint, int const * joints, double * accs) -> bool
        getRefAccelerations(IPositionControl self, DVector data) -> bool
        getRefAccelerations(IPositionControl self, int n_joint, IVector joints, DVector data) -> bool
        """
        return _yarp.IPositionControl_getRefAccelerations(self, *args)

    def checkMotionDone(self, *args):
        r"""
        checkMotionDone(IPositionControl self, int j, bool * flag) -> bool
        checkMotionDone(IPositionControl self, bool * flag) -> bool
        checkMotionDone(IPositionControl self, int const n_joint, int const * joints, bool * flag) -> bool
        checkMotionDone(IPositionControl self) -> bool
        checkMotionDone(IPositionControl self, BVector flag) -> bool
        checkMotionDone(IPositionControl self, int i, BVector flag) -> bool
        checkMotionDone(IPositionControl self, int n_joint, IVector joints, BVector flag) -> bool
        """
        return _yarp.IPositionControl_checkMotionDone(self, *args)

    def isMotionDone(self, *args):
        r"""
        isMotionDone(IPositionControl self, int i) -> bool
        isMotionDone(IPositionControl self) -> bool
        """
        return _yarp.IPositionControl_isMotionDone(self, *args)

    def stop(self, *args):
        r"""
        stop(IPositionControl self, int j) -> bool
        stop(IPositionControl self) -> bool
        stop(IPositionControl self, int const n_joint, int const * joints) -> bool
        stop(IPositionControl self, int n_joint, IVector joints) -> bool
        """
        return _yarp.IPositionControl_stop(self, *args)

    def getTargetPosition(self, *args):
        r"""
        getTargetPosition(IPositionControl self, int const joint, double * ref) -> bool
        getTargetPosition(IPositionControl self, int j, DVector data) -> bool
        """
        return _yarp.IPositionControl_getTargetPosition(self, *args)

    def getTargetPositions(self, *args):
        r"""
        getTargetPositions(IPositionControl self, double * refs) -> bool
        getTargetPositions(IPositionControl self, int const n_joint, int const * joints, double * refs) -> bool
        getTargetPositions(IPositionControl self, DVector data) -> bool
        getTargetPositions(IPositionControl self, int n_joint, IVector joints, DVector data) -> bool
        """
        return _yarp.IPositionControl_getTargetPositions(self, *args)

# Register IPositionControl in _yarp:
_yarp.IPositionControl_swigregister(IPositionControl)

class IEncodersRaw(object):
    r"""Proxy of C++ yarp::dev::IEncodersRaw class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _yarp.delete_IEncodersRaw

    def getAxes(self, ax):
        r"""getAxes(IEncodersRaw self, int * ax) -> bool"""
        return _yarp.IEncodersRaw_getAxes(self, ax)

    def resetEncoderRaw(self, j):
        r"""resetEncoderRaw(IEncodersRaw self, int j) -> bool"""
        return _yarp.IEncodersRaw_resetEncoderRaw(self, j)

    def resetEncodersRaw(self):
        r"""resetEncodersRaw(IEncodersRaw self) -> bool"""
        return _yarp.IEncodersRaw_resetEncodersRaw(self)

    def setEncoderRaw(self, j, val):
        r"""setEncoderRaw(IEncodersRaw self, int j, double val) -> bool"""
        return _yarp.IEncodersRaw_setEncoderRaw(self, j, val)

    def setEncodersRaw(self, vals):
        r"""setEncodersRaw(IEncodersRaw self, double const * vals) -> bool"""
        return _yarp.IEncodersRaw_setEncodersRaw(self, vals)

    def getEncoderRaw(self, j, v):
        r"""getEncoderRaw(IEncodersRaw self, int j, double * v) -> bool"""
        return _yarp.IEncodersRaw_getEncoderRaw(self, j, v)

    def getEncodersRaw(self, encs):
        r"""getEncodersRaw(IEncodersRaw self, double * encs) -> bool"""
        return _yarp.IEncodersRaw_getEncodersRaw(self, encs)

    def getEncoderSpeedRaw(self, j, sp):
        r"""getEncoderSpeedRaw(IEncodersRaw self, int j, double * sp) -> bool"""
        return _yarp.IEncodersRaw_getEncoderSpeedRaw(self, j, sp)

    def getEncoderSpeedsRaw(self, spds):
        r"""getEncoderSpeedsRaw(IEncodersRaw self, double * spds) -> bool"""
        return _yarp.IEncodersRaw_getEncoderSpeedsRaw(self, spds)

    def getEncoderAccelerationRaw(self, j, spds):
        r"""getEncoderAccelerationRaw(IEncodersRaw self, int j, double * spds) -> bool"""
        return _yarp.IEncodersRaw_getEncoderAccelerationRaw(self, j, spds)

    def getEncoderAccelerationsRaw(self, accs):
        r"""getEncoderAccelerationsRaw(IEncodersRaw self, double * accs) -> bool"""
        return _yarp.IEncodersRaw_getEncoderAccelerationsRaw(self, accs)

# Register IEncodersRaw in _yarp:
_yarp.IEncodersRaw_swigregister(IEncodersRaw)
VOCAB_POSITION_MOVE_GROUP = cvar.VOCAB_POSITION_MOVE_GROUP
VOCAB_RELATIVE_MOVE_GROUP = cvar.VOCAB_RELATIVE_MOVE_GROUP
VOCAB_MOTION_DONE_GROUP = cvar.VOCAB_MOTION_DONE_GROUP
VOCAB_REF_SPEED_GROUP = cvar.VOCAB_REF_SPEED_GROUP
VOCAB_REF_ACCELERATION_GROUP = cvar.VOCAB_REF_ACCELERATION_GROUP
VOCAB_STOP_GROUP = cvar.VOCAB_STOP_GROUP

class IEncoders(object):
    r"""Proxy of C++ yarp::dev::IEncoders class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _yarp.delete_IEncoders

    def resetEncoder(self, j):
        r"""resetEncoder(IEncoders self, int j) -> bool"""
        return _yarp.IEncoders_resetEncoder(self, j)

    def resetEncoders(self):
        r"""resetEncoders(IEncoders self) -> bool"""
        return _yarp.IEncoders_resetEncoders(self)

    def setEncoder(self, j, val):
        r"""setEncoder(IEncoders self, int j, double val) -> bool"""
        return _yarp.IEncoders_setEncoder(self, j, val)

    def getAxes(self, *args):
        r"""
        getAxes(IEncoders self, int * ax) -> bool
        getAxes(IEncoders self) -> int
        """
        return _yarp.IEncoders_getAxes(self, *args)

    def setEncoders(self, *args):
        r"""
        setEncoders(IEncoders self, double const * vals) -> bool
        setEncoders(IEncoders self, DVector data) -> bool
        """
        return _yarp.IEncoders_setEncoders(self, *args)

    def getEncoder(self, *args):
        r"""
        getEncoder(IEncoders self, int j, double * v) -> bool
        getEncoder(IEncoders self, int j) -> double
        """
        return _yarp.IEncoders_getEncoder(self, *args)

    def getEncoders(self, *args):
        r"""
        getEncoders(IEncoders self, double * encs) -> bool
        getEncoders(IEncoders self, DVector data) -> bool
        """
        return _yarp.IEncoders_getEncoders(self, *args)

    def getEncoderSpeed(self, *args):
        r"""
        getEncoderSpeed(IEncoders self, int j, double * sp) -> bool
        getEncoderSpeed(IEncoders self, int j) -> double
        """
        return _yarp.IEncoders_getEncoderSpeed(self, *args)

    def getEncoderSpeeds(self, *args):
        r"""
        getEncoderSpeeds(IEncoders self, double * spds) -> bool
        getEncoderSpeeds(IEncoders self, DVector data) -> bool
        """
        return _yarp.IEncoders_getEncoderSpeeds(self, *args)

    def getEncoderAcceleration(self, *args):
        r"""
        getEncoderAcceleration(IEncoders self, int j, double * spds) -> bool
        getEncoderAcceleration(IEncoders self, int j) -> double
        """
        return _yarp.IEncoders_getEncoderAcceleration(self, *args)

    def getEncoderAccelerations(self, *args):
        r"""
        getEncoderAccelerations(IEncoders self, double * accs) -> bool
        getEncoderAccelerations(IEncoders self, DVector data) -> bool
        """
        return _yarp.IEncoders_getEncoderAccelerations(self, *args)

# Register IEncoders in _yarp:
_yarp.IEncoders_swigregister(IEncoders)

class IControlMode(object):
    r"""Proxy of C++ yarp::dev::IControlMode class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _yarp.delete_IControlMode

    def setControlMode(self, j, mode):
        r"""setControlMode(IControlMode self, int const j, int const mode) -> bool"""
        return _yarp.IControlMode_setControlMode(self, j, mode)

    def getControlMode(self, *args):
        r"""
        getControlMode(IControlMode self, int j, int * mode) -> bool
        getControlMode(IControlMode self, int j) -> int
        """
        return _yarp.IControlMode_getControlMode(self, *args)

    def getControlModes(self, *args):
        r"""
        getControlModes(IControlMode self, int * modes) -> bool
        getControlModes(IControlMode self, int const n_joint, int const * joints, int * modes) -> bool
        getControlModes(IControlMode self, IVector data) -> bool
        getControlModes(IControlMode self, int n_joint, IVector joints, IVector data) -> bool
        """
        return _yarp.IControlMode_getControlModes(self, *args)

    def setControlModes(self, *args):
        r"""
        setControlModes(IControlMode self, int const n_joint, int const * joints, int * modes) -> bool
        setControlModes(IControlMode self, int * modes) -> bool
        setControlModes(IControlMode self, IVector data) -> bool
        setControlModes(IControlMode self, int n_joint, IVector joints, IVector data) -> bool
        """
        return _yarp.IControlMode_setControlModes(self, *args)

# Register IControlMode in _yarp:
_yarp.IControlMode_swigregister(IControlMode)
VOCAB_E_RESET = cvar.VOCAB_E_RESET
VOCAB_E_RESETS = cvar.VOCAB_E_RESETS
VOCAB_ENCODER = cvar.VOCAB_ENCODER
VOCAB_ENCODERS = cvar.VOCAB_ENCODERS
VOCAB_ENCODER_SPEED = cvar.VOCAB_ENCODER_SPEED
VOCAB_ENCODER_SPEEDS = cvar.VOCAB_ENCODER_SPEEDS
VOCAB_ENCODER_ACCELERATION = cvar.VOCAB_ENCODER_ACCELERATION
VOCAB_ENCODER_ACCELERATIONS = cvar.VOCAB_ENCODER_ACCELERATIONS

class IControlModeRaw(object):
    r"""Proxy of C++ yarp::dev::IControlModeRaw class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _yarp.delete_IControlModeRaw

    def getControlModeRaw(self, j, mode):
        r"""getControlModeRaw(IControlModeRaw self, int j, int * mode) -> bool"""
        return _yarp.IControlModeRaw_getControlModeRaw(self, j, mode)

    def getControlModesRaw(self, *args):
        r"""
        getControlModesRaw(IControlModeRaw self, int * modes) -> bool
        getControlModesRaw(IControlModeRaw self, int const n_joint, int const * joints, int * modes) -> bool
        """
        return _yarp.IControlModeRaw_getControlModesRaw(self, *args)

    def setControlModeRaw(self, j, mode):
        r"""setControlModeRaw(IControlModeRaw self, int const j, int const mode) -> bool"""
        return _yarp.IControlModeRaw_setControlModeRaw(self, j, mode)

    def setControlModesRaw(self, *args):
        r"""
        setControlModesRaw(IControlModeRaw self, int const n_joint, int const * joints, int * modes) -> bool
        setControlModesRaw(IControlModeRaw self, int * modes) -> bool
        """
        return _yarp.IControlModeRaw_setControlModesRaw(self, *args)

# Register IControlModeRaw in _yarp:
_yarp.IControlModeRaw_swigregister(IControlModeRaw)

VOCAB_IM_STIFF = _yarp.VOCAB_IM_STIFF

VOCAB_IM_COMPLIANT = _yarp.VOCAB_IM_COMPLIANT

VOCAB_IM_UNKNOWN = _yarp.VOCAB_IM_UNKNOWN

class IInteractionMode(object):
    r"""Proxy of C++ yarp::dev::IInteractionMode class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _yarp.delete_IInteractionMode

    def setInteractionMode(self, axis, mode):
        r"""setInteractionMode(IInteractionMode self, int axis, yarp::dev::InteractionModeEnum mode) -> bool"""
        return _yarp.IInteractionMode_setInteractionMode(self, axis, mode)

    def getInteractionMode(self, *args):
        r"""
        getInteractionMode(IInteractionMode self, int axis, yarp::dev::InteractionModeEnum * mode) -> bool
        getInteractionMode(IInteractionMode self, int axis) -> yarp::dev::InteractionModeEnum
        """
        return _yarp.IInteractionMode_getInteractionMode(self, *args)

    def getInteractionModes(self, *args):
        r"""
        getInteractionModes(IInteractionMode self, int n_joints, int * joints, yarp::dev::InteractionModeEnum * modes) -> bool
        getInteractionModes(IInteractionMode self, yarp::dev::InteractionModeEnum * modes) -> bool
        getInteractionModes(IInteractionMode self, int n_joint, IVector joints, IVector data) -> bool
        getInteractionModes(IInteractionMode self, IVector data) -> bool
        """
        return _yarp.IInteractionMode_getInteractionModes(self, *args)

    def setInteractionModes(self, *args):
        r"""
        setInteractionModes(IInteractionMode self, int n_joints, int * joints, yarp::dev::InteractionModeEnum * modes) -> bool
        setInteractionModes(IInteractionMode self, yarp::dev::InteractionModeEnum * modes) -> bool
        setInteractionModes(IInteractionMode self, int n_joint, IVector joints, IVector data) -> bool
        setInteractionModes(IInteractionMode self, IVector data) -> bool
        """
        return _yarp.IInteractionMode_setInteractionModes(self, *args)

# Register IInteractionMode in _yarp:
_yarp.IInteractionMode_swigregister(IInteractionMode)
VOCAB_ICONTROLMODE = cvar.VOCAB_ICONTROLMODE
VOCAB_CM_CONTROL_MODE = cvar.VOCAB_CM_CONTROL_MODE
VOCAB_CM_CONTROL_MODE_GROUP = cvar.VOCAB_CM_CONTROL_MODE_GROUP
VOCAB_CM_CONTROL_MODES = cvar.VOCAB_CM_CONTROL_MODES
VOCAB_CM_IDLE = cvar.VOCAB_CM_IDLE
VOCAB_CM_TORQUE = cvar.VOCAB_CM_TORQUE
VOCAB_CM_POSITION = cvar.VOCAB_CM_POSITION
VOCAB_CM_POSITION_DIRECT = cvar.VOCAB_CM_POSITION_DIRECT
VOCAB_CM_VELOCITY = cvar.VOCAB_CM_VELOCITY
VOCAB_CM_CURRENT = cvar.VOCAB_CM_CURRENT
VOCAB_CM_PWM = cvar.VOCAB_CM_PWM
VOCAB_CM_IMPEDANCE_POS = cvar.VOCAB_CM_IMPEDANCE_POS
VOCAB_CM_IMPEDANCE_VEL = cvar.VOCAB_CM_IMPEDANCE_VEL
VOCAB_CM_MIXED = cvar.VOCAB_CM_MIXED
VOCAB_CM_FORCE_IDLE = cvar.VOCAB_CM_FORCE_IDLE
VOCAB_CM_HW_FAULT = cvar.VOCAB_CM_HW_FAULT
VOCAB_CM_CALIBRATING = cvar.VOCAB_CM_CALIBRATING
VOCAB_CM_CALIB_DONE = cvar.VOCAB_CM_CALIB_DONE
VOCAB_CM_NOT_CONFIGURED = cvar.VOCAB_CM_NOT_CONFIGURED
VOCAB_CM_CONFIGURED = cvar.VOCAB_CM_CONFIGURED
VOCAB_CM_UNKNOWN = cvar.VOCAB_CM_UNKNOWN
VOCAB_INTERFACE_INTERACTION_MODE = cvar.VOCAB_INTERFACE_INTERACTION_MODE
VOCAB_INTERACTION_MODE = cvar.VOCAB_INTERACTION_MODE
VOCAB_INTERACTION_MODE_GROUP = cvar.VOCAB_INTERACTION_MODE_GROUP
VOCAB_INTERACTION_MODES = cvar.VOCAB_INTERACTION_MODES

class IInteractionModeRaw(object):
    r"""Proxy of C++ yarp::dev::IInteractionModeRaw class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _yarp.delete_IInteractionModeRaw

    def getInteractionModeRaw(self, axis, mode):
        r"""getInteractionModeRaw(IInteractionModeRaw self, int axis, yarp::dev::InteractionModeEnum * mode) -> bool"""
        return _yarp.IInteractionModeRaw_getInteractionModeRaw(self, axis, mode)

    def getInteractionModesRaw(self, *args):
        r"""
        getInteractionModesRaw(IInteractionModeRaw self, int n_joints, int * joints, yarp::dev::InteractionModeEnum * modes) -> bool
        getInteractionModesRaw(IInteractionModeRaw self, yarp::dev::InteractionModeEnum * modes) -> bool
        """
        return _yarp.IInteractionModeRaw_getInteractionModesRaw(self, *args)

    def setInteractionModeRaw(self, axis, mode):
        r"""setInteractionModeRaw(IInteractionModeRaw self, int axis, yarp::dev::InteractionModeEnum mode) -> bool"""
        return _yarp.IInteractionModeRaw_setInteractionModeRaw(self, axis, mode)

    def setInteractionModesRaw(self, *args):
        r"""
        setInteractionModesRaw(IInteractionModeRaw self, int n_joints, int * joints, yarp::dev::InteractionModeEnum * modes) -> bool
        setInteractionModesRaw(IInteractionModeRaw self, yarp::dev::InteractionModeEnum * modes) -> bool
        """
        return _yarp.IInteractionModeRaw_setInteractionModesRaw(self, *args)

# Register IInteractionModeRaw in _yarp:
_yarp.IInteractionModeRaw_swigregister(IInteractionModeRaw)

class IEncodersTimedRaw(IEncodersRaw):
    r"""Proxy of C++ yarp::dev::IEncodersTimedRaw class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _yarp.delete_IEncodersTimedRaw

    def getEncodersTimedRaw(self, encs, stamps):
        r"""getEncodersTimedRaw(IEncodersTimedRaw self, double * encs, double * stamps) -> bool"""
        return _yarp.IEncodersTimedRaw_getEncodersTimedRaw(self, encs, stamps)

    def getEncoderTimedRaw(self, j, encs, stamp):
        r"""getEncoderTimedRaw(IEncodersTimedRaw self, int j, double * encs, double * stamp) -> bool"""
        return _yarp.IEncodersTimedRaw_getEncoderTimedRaw(self, j, encs, stamp)

# Register IEncodersTimedRaw in _yarp:
_yarp.IEncodersTimedRaw_swigregister(IEncodersTimedRaw)

class IEncodersTimed(IEncoders):
    r"""Proxy of C++ yarp::dev::IEncodersTimed class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _yarp.delete_IEncodersTimed

    def getEncodersTimed(self, *args):
        r"""
        getEncodersTimed(IEncodersTimed self, double * encs, double * time) -> bool
        getEncodersTimed(IEncodersTimed self, DVector data, DVector time) -> bool
        """
        return _yarp.IEncodersTimed_getEncodersTimed(self, *args)

    def getEncoderTimed(self, *args):
        r"""
        getEncoderTimed(IEncodersTimed self, int j, double * encs, double * time) -> bool
        getEncoderTimed(IEncodersTimed self, int j, DVector data, DVector time) -> bool
        """
        return _yarp.IEncodersTimed_getEncoderTimed(self, *args)

# Register IEncodersTimed in _yarp:
_yarp.IEncodersTimed_swigregister(IEncodersTimed)

class IMotorRaw(object):
    r"""Proxy of C++ yarp::dev::IMotorRaw class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _yarp.delete_IMotorRaw

    def getNumberOfMotorsRaw(self, num):
        r"""getNumberOfMotorsRaw(IMotorRaw self, int * num) -> bool"""
        return _yarp.IMotorRaw_getNumberOfMotorsRaw(self, num)

    def getTemperatureRaw(self, m, val):
        r"""getTemperatureRaw(IMotorRaw self, int m, double * val) -> bool"""
        return _yarp.IMotorRaw_getTemperatureRaw(self, m, val)

    def getTemperaturesRaw(self, vals):
        r"""getTemperaturesRaw(IMotorRaw self, double * vals) -> bool"""
        return _yarp.IMotorRaw_getTemperaturesRaw(self, vals)

    def getTemperatureLimitRaw(self, m, temp):
        r"""getTemperatureLimitRaw(IMotorRaw self, int m, double * temp) -> bool"""
        return _yarp.IMotorRaw_getTemperatureLimitRaw(self, m, temp)

    def setTemperatureLimitRaw(self, m, temp):
        r"""setTemperatureLimitRaw(IMotorRaw self, int m, double const temp) -> bool"""
        return _yarp.IMotorRaw_setTemperatureLimitRaw(self, m, temp)

    def getGearboxRatioRaw(self, m, val):
        r"""getGearboxRatioRaw(IMotorRaw self, int m, double * val) -> bool"""
        return _yarp.IMotorRaw_getGearboxRatioRaw(self, m, val)

    def setGearboxRatioRaw(self, m, val):
        r"""setGearboxRatioRaw(IMotorRaw self, int m, double const val) -> bool"""
        return _yarp.IMotorRaw_setGearboxRatioRaw(self, m, val)

# Register IMotorRaw in _yarp:
_yarp.IMotorRaw_swigregister(IMotorRaw)

class IMotor(object):
    r"""Proxy of C++ yarp::dev::IMotor class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _yarp.delete_IMotor

    def setTemperatureLimit(self, m, temp):
        r"""setTemperatureLimit(IMotor self, int m, double const temp) -> bool"""
        return _yarp.IMotor_setTemperatureLimit(self, m, temp)

    def setGearboxRatio(self, m, val):
        r"""setGearboxRatio(IMotor self, int m, double const val) -> bool"""
        return _yarp.IMotor_setGearboxRatio(self, m, val)

    def getNumberOfMotors(self, *args):
        r"""
        getNumberOfMotors(IMotor self, int * num) -> bool
        getNumberOfMotors(IMotor self) -> int
        """
        return _yarp.IMotor_getNumberOfMotors(self, *args)

    def getTemperature(self, *args):
        r"""
        getTemperature(IMotor self, int m, double * val) -> bool
        getTemperature(IMotor self, int j, DVector data) -> bool
        """
        return _yarp.IMotor_getTemperature(self, *args)

    def getTemperatures(self, *args):
        r"""
        getTemperatures(IMotor self, double * vals) -> bool
        getTemperatures(IMotor self, DVector data) -> bool
        """
        return _yarp.IMotor_getTemperatures(self, *args)

    def getTemperatureLimit(self, *args):
        r"""
        getTemperatureLimit(IMotor self, int m, double * temp) -> bool
        getTemperatureLimit(IMotor self, int j, DVector data) -> bool
        """
        return _yarp.IMotor_getTemperatureLimit(self, *args)

    def getGearboxRatio(self, *args):
        r"""
        getGearboxRatio(IMotor self, int m, double * val) -> bool
        getGearboxRatio(IMotor self, int j, DVector data) -> bool
        """
        return _yarp.IMotor_getGearboxRatio(self, *args)

# Register IMotor in _yarp:
_yarp.IMotor_swigregister(IMotor)

class IMotorEncodersRaw(object):
    r"""Proxy of C++ yarp::dev::IMotorEncodersRaw class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _yarp.delete_IMotorEncodersRaw

    def getNumberOfMotorEncodersRaw(self, num):
        r"""getNumberOfMotorEncodersRaw(IMotorEncodersRaw self, int * num) -> bool"""
        return _yarp.IMotorEncodersRaw_getNumberOfMotorEncodersRaw(self, num)

    def resetMotorEncoderRaw(self, m):
        r"""resetMotorEncoderRaw(IMotorEncodersRaw self, int m) -> bool"""
        return _yarp.IMotorEncodersRaw_resetMotorEncoderRaw(self, m)

    def resetMotorEncodersRaw(self):
        r"""resetMotorEncodersRaw(IMotorEncodersRaw self) -> bool"""
        return _yarp.IMotorEncodersRaw_resetMotorEncodersRaw(self)

    def setMotorEncoderCountsPerRevolutionRaw(self, m, cpr):
        r"""setMotorEncoderCountsPerRevolutionRaw(IMotorEncodersRaw self, int m, double const cpr) -> bool"""
        return _yarp.IMotorEncodersRaw_setMotorEncoderCountsPerRevolutionRaw(self, m, cpr)

    def getMotorEncoderCountsPerRevolutionRaw(self, m, cpr):
        r"""getMotorEncoderCountsPerRevolutionRaw(IMotorEncodersRaw self, int m, double * cpr) -> bool"""
        return _yarp.IMotorEncodersRaw_getMotorEncoderCountsPerRevolutionRaw(self, m, cpr)

    def setMotorEncoderRaw(self, m, val):
        r"""setMotorEncoderRaw(IMotorEncodersRaw self, int m, double const val) -> bool"""
        return _yarp.IMotorEncodersRaw_setMotorEncoderRaw(self, m, val)

    def setMotorEncodersRaw(self, vals):
        r"""setMotorEncodersRaw(IMotorEncodersRaw self, double const * vals) -> bool"""
        return _yarp.IMotorEncodersRaw_setMotorEncodersRaw(self, vals)

    def getMotorEncoderRaw(self, m, v):
        r"""getMotorEncoderRaw(IMotorEncodersRaw self, int m, double * v) -> bool"""
        return _yarp.IMotorEncodersRaw_getMotorEncoderRaw(self, m, v)

    def getMotorEncodersRaw(self, encs):
        r"""getMotorEncodersRaw(IMotorEncodersRaw self, double * encs) -> bool"""
        return _yarp.IMotorEncodersRaw_getMotorEncodersRaw(self, encs)

    def getMotorEncodersTimedRaw(self, encs, stamps):
        r"""getMotorEncodersTimedRaw(IMotorEncodersRaw self, double * encs, double * stamps) -> bool"""
        return _yarp.IMotorEncodersRaw_getMotorEncodersTimedRaw(self, encs, stamps)

    def getMotorEncoderTimedRaw(self, m, encs, stamp):
        r"""getMotorEncoderTimedRaw(IMotorEncodersRaw self, int m, double * encs, double * stamp) -> bool"""
        return _yarp.IMotorEncodersRaw_getMotorEncoderTimedRaw(self, m, encs, stamp)

    def getMotorEncoderSpeedRaw(self, m, sp):
        r"""getMotorEncoderSpeedRaw(IMotorEncodersRaw self, int m, double * sp) -> bool"""
        return _yarp.IMotorEncodersRaw_getMotorEncoderSpeedRaw(self, m, sp)

    def getMotorEncoderSpeedsRaw(self, spds):
        r"""getMotorEncoderSpeedsRaw(IMotorEncodersRaw self, double * spds) -> bool"""
        return _yarp.IMotorEncodersRaw_getMotorEncoderSpeedsRaw(self, spds)

    def getMotorEncoderAccelerationRaw(self, m, spds):
        r"""getMotorEncoderAccelerationRaw(IMotorEncodersRaw self, int m, double * spds) -> bool"""
        return _yarp.IMotorEncodersRaw_getMotorEncoderAccelerationRaw(self, m, spds)

    def getMotorEncoderAccelerationsRaw(self, accs):
        r"""getMotorEncoderAccelerationsRaw(IMotorEncodersRaw self, double * accs) -> bool"""
        return _yarp.IMotorEncodersRaw_getMotorEncoderAccelerationsRaw(self, accs)

# Register IMotorEncodersRaw in _yarp:
_yarp.IMotorEncodersRaw_swigregister(IMotorEncodersRaw)
VOCAB_MOTORS_NUMBER = cvar.VOCAB_MOTORS_NUMBER
VOCAB_TEMPERATURE = cvar.VOCAB_TEMPERATURE
VOCAB_GEARBOX_RATIO = cvar.VOCAB_GEARBOX_RATIO
VOCAB_TEMPERATURES = cvar.VOCAB_TEMPERATURES
VOCAB_TEMPERATURE_LIMIT = cvar.VOCAB_TEMPERATURE_LIMIT

class IMotorEncoders(object):
    r"""Proxy of C++ yarp::dev::IMotorEncoders class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _yarp.delete_IMotorEncoders

    def resetMotorEncoder(self, m):
        r"""resetMotorEncoder(IMotorEncoders self, int m) -> bool"""
        return _yarp.IMotorEncoders_resetMotorEncoder(self, m)

    def resetMotorEncoders(self):
        r"""resetMotorEncoders(IMotorEncoders self) -> bool"""
        return _yarp.IMotorEncoders_resetMotorEncoders(self)

    def setMotorEncoderCountsPerRevolution(self, m, cpr):
        r"""setMotorEncoderCountsPerRevolution(IMotorEncoders self, int m, double const cpr) -> bool"""
        return _yarp.IMotorEncoders_setMotorEncoderCountsPerRevolution(self, m, cpr)

    def setMotorEncoder(self, m, val):
        r"""setMotorEncoder(IMotorEncoders self, int m, double const val) -> bool"""
        return _yarp.IMotorEncoders_setMotorEncoder(self, m, val)

    def getNumberOfMotorEncoders(self, *args):
        r"""
        getNumberOfMotorEncoders(IMotorEncoders self, int * num) -> bool
        getNumberOfMotorEncoders(IMotorEncoders self) -> int
        """
        return _yarp.IMotorEncoders_getNumberOfMotorEncoders(self, *args)

    def getMotorEncoderCountsPerRevolution(self, *args):
        r"""
        getMotorEncoderCountsPerRevolution(IMotorEncoders self, int m, double * cpr) -> bool
        getMotorEncoderCountsPerRevolution(IMotorEncoders self, int j, DVector data) -> bool
        """
        return _yarp.IMotorEncoders_getMotorEncoderCountsPerRevolution(self, *args)

    def setMotorEncoders(self, *args):
        r"""
        setMotorEncoders(IMotorEncoders self, double const * vals) -> bool
        setMotorEncoders(IMotorEncoders self, DVector encs) -> bool
        """
        return _yarp.IMotorEncoders_setMotorEncoders(self, *args)

    def getMotorEncoder(self, *args):
        r"""
        getMotorEncoder(IMotorEncoders self, int m, double * v) -> bool
        getMotorEncoder(IMotorEncoders self, int j) -> double
        """
        return _yarp.IMotorEncoders_getMotorEncoder(self, *args)

    def getMotorEncoders(self, *args):
        r"""
        getMotorEncoders(IMotorEncoders self, double * encs) -> bool
        getMotorEncoders(IMotorEncoders self, DVector encs) -> bool
        """
        return _yarp.IMotorEncoders_getMotorEncoders(self, *args)

    def getMotorEncoderTimed(self, *args):
        r"""
        getMotorEncoderTimed(IMotorEncoders self, int m, double * encs, double * time) -> bool
        getMotorEncoderTimed(IMotorEncoders self, int j, DVector enc, DVector time) -> bool
        """
        return _yarp.IMotorEncoders_getMotorEncoderTimed(self, *args)

    def getMotorEncodersTimed(self, *args):
        r"""
        getMotorEncodersTimed(IMotorEncoders self, double * encs, double * time) -> bool
        getMotorEncodersTimed(IMotorEncoders self, DVector encs, DVector times) -> bool
        """
        return _yarp.IMotorEncoders_getMotorEncodersTimed(self, *args)

    def getMotorEncoderSpeed(self, *args):
        r"""
        getMotorEncoderSpeed(IMotorEncoders self, int m, double * sp) -> bool
        getMotorEncoderSpeed(IMotorEncoders self, int j) -> double
        """
        return _yarp.IMotorEncoders_getMotorEncoderSpeed(self, *args)

    def getMotorEncoderSpeeds(self, *args):
        r"""
        getMotorEncoderSpeeds(IMotorEncoders self, double * spds) -> bool
        getMotorEncoderSpeeds(IMotorEncoders self, DVector speeds) -> bool
        """
        return _yarp.IMotorEncoders_getMotorEncoderSpeeds(self, *args)

    def getMotorEncoderAcceleration(self, *args):
        r"""
        getMotorEncoderAcceleration(IMotorEncoders self, int m, double * acc) -> bool
        getMotorEncoderAcceleration(IMotorEncoders self, int j, DVector acc) -> bool
        """
        return _yarp.IMotorEncoders_getMotorEncoderAcceleration(self, *args)

    def getMotorEncoderAccelerations(self, *args):
        r"""
        getMotorEncoderAccelerations(IMotorEncoders self, double * accs) -> bool
        getMotorEncoderAccelerations(IMotorEncoders self, DVector accs) -> bool
        """
        return _yarp.IMotorEncoders_getMotorEncoderAccelerations(self, *args)

# Register IMotorEncoders in _yarp:
_yarp.IMotorEncoders_swigregister(IMotorEncoders)

class MotorTorqueParameters(object):
    r"""Proxy of C++ yarp::dev::MotorTorqueParameters class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    bemf = property(_yarp.MotorTorqueParameters_bemf_get, _yarp.MotorTorqueParameters_bemf_set, doc=r"""bemf : double""")
    bemf_scale = property(_yarp.MotorTorqueParameters_bemf_scale_get, _yarp.MotorTorqueParameters_bemf_scale_set, doc=r"""bemf_scale : double""")
    ktau = property(_yarp.MotorTorqueParameters_ktau_get, _yarp.MotorTorqueParameters_ktau_set, doc=r"""ktau : double""")
    ktau_scale = property(_yarp.MotorTorqueParameters_ktau_scale_get, _yarp.MotorTorqueParameters_ktau_scale_set, doc=r"""ktau_scale : double""")

    def __init__(self):
        r"""__init__(MotorTorqueParameters self) -> MotorTorqueParameters"""
        _yarp.MotorTorqueParameters_swiginit(self, _yarp.new_MotorTorqueParameters())
    __swig_destroy__ = _yarp.delete_MotorTorqueParameters

# Register MotorTorqueParameters in _yarp:
_yarp.MotorTorqueParameters_swigregister(MotorTorqueParameters)
VOCAB_MOTOR_E_RESET = cvar.VOCAB_MOTOR_E_RESET
VOCAB_MOTOR_E_RESETS = cvar.VOCAB_MOTOR_E_RESETS
VOCAB_MOTOR_ENCODER = cvar.VOCAB_MOTOR_ENCODER
VOCAB_MOTOR_ENCODERS = cvar.VOCAB_MOTOR_ENCODERS
VOCAB_MOTOR_CPR = cvar.VOCAB_MOTOR_CPR
VOCAB_MOTOR_ENCODER_NUMBER = cvar.VOCAB_MOTOR_ENCODER_NUMBER
VOCAB_MOTOR_ENCODER_SPEED = cvar.VOCAB_MOTOR_ENCODER_SPEED
VOCAB_MOTOR_ENCODER_SPEEDS = cvar.VOCAB_MOTOR_ENCODER_SPEEDS
VOCAB_MOTOR_ENCODER_ACCELERATION = cvar.VOCAB_MOTOR_ENCODER_ACCELERATION
VOCAB_MOTOR_ENCODER_ACCELERATIONS = cvar.VOCAB_MOTOR_ENCODER_ACCELERATIONS

class ITorqueControl(object):
    r"""Proxy of C++ yarp::dev::ITorqueControl class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _yarp.delete_ITorqueControl

    def setRefTorque(self, j, t):
        r"""setRefTorque(ITorqueControl self, int j, double t) -> bool"""
        return _yarp.ITorqueControl_setRefTorque(self, j, t)

    def setMotorTorqueParams(self, j, params):
        r"""setMotorTorqueParams(ITorqueControl self, int j, MotorTorqueParameters params) -> bool"""
        return _yarp.ITorqueControl_setMotorTorqueParams(self, j, params)

    def getAxes(self, *args):
        r"""
        getAxes(ITorqueControl self, int * ax) -> bool
        getAxes(ITorqueControl self) -> int
        """
        return _yarp.ITorqueControl_getAxes(self, *args)

    def getRefTorques(self, *args):
        r"""
        getRefTorques(ITorqueControl self, double * t) -> bool
        getRefTorques(ITorqueControl self, DVector data) -> bool
        """
        return _yarp.ITorqueControl_getRefTorques(self, *args)

    def getRefTorque(self, *args):
        r"""
        getRefTorque(ITorqueControl self, int j, double * t) -> bool
        getRefTorque(ITorqueControl self, int j, DVector data) -> bool
        """
        return _yarp.ITorqueControl_getRefTorque(self, *args)

    def setRefTorques(self, *args):
        r"""
        setRefTorques(ITorqueControl self, double const * t) -> bool
        setRefTorques(ITorqueControl self, int const n_joint, int const * joints, double const * t) -> bool
        setRefTorques(ITorqueControl self, DVector data) -> bool
        setRefTorques(ITorqueControl self, int n_joint, IVector joints, DVector data) -> bool
        """
        return _yarp.ITorqueControl_setRefTorques(self, *args)

    def getMotorTorqueParams(self, *args):
        r"""
        getMotorTorqueParams(ITorqueControl self, int j, MotorTorqueParameters params) -> bool
        getMotorTorqueParams(ITorqueControl self, int j, MotorTorqueParameters params) -> bool
        """
        return _yarp.ITorqueControl_getMotorTorqueParams(self, *args)

    def getTorque(self, *args):
        r"""
        getTorque(ITorqueControl self, int j, double * t) -> bool
        getTorque(ITorqueControl self, int j, DVector data) -> bool
        """
        return _yarp.ITorqueControl_getTorque(self, *args)

    def getTorques(self, *args):
        r"""
        getTorques(ITorqueControl self, double * t) -> bool
        getTorques(ITorqueControl self, DVector data) -> bool
        """
        return _yarp.ITorqueControl_getTorques(self, *args)

    def getTorqueRange(self, *args):
        r"""
        getTorqueRange(ITorqueControl self, int j, double * min, double * max) -> bool
        getTorqueRange(ITorqueControl self, int j, DVector min, DVector max) -> bool
        """
        return _yarp.ITorqueControl_getTorqueRange(self, *args)

    def getTorqueRanges(self, *args):
        r"""
        getTorqueRanges(ITorqueControl self, double * min, double * max) -> bool
        getTorqueRanges(ITorqueControl self, DVector mins, DVector maxs) -> bool
        """
        return _yarp.ITorqueControl_getTorqueRanges(self, *args)

# Register ITorqueControl in _yarp:
_yarp.ITorqueControl_swigregister(ITorqueControl)

class ITorqueControlRaw(object):
    r"""Proxy of C++ yarp::dev::ITorqueControlRaw class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _yarp.delete_ITorqueControlRaw

    def getAxes(self, ax):
        r"""getAxes(ITorqueControlRaw self, int * ax) -> bool"""
        return _yarp.ITorqueControlRaw_getAxes(self, ax)

    def getTorqueRaw(self, j, t):
        r"""getTorqueRaw(ITorqueControlRaw self, int j, double * t) -> bool"""
        return _yarp.ITorqueControlRaw_getTorqueRaw(self, j, t)

    def getTorquesRaw(self, t):
        r"""getTorquesRaw(ITorqueControlRaw self, double * t) -> bool"""
        return _yarp.ITorqueControlRaw_getTorquesRaw(self, t)

    def getTorqueRangeRaw(self, j, min, max):
        r"""getTorqueRangeRaw(ITorqueControlRaw self, int j, double * min, double * max) -> bool"""
        return _yarp.ITorqueControlRaw_getTorqueRangeRaw(self, j, min, max)

    def getTorqueRangesRaw(self, min, max):
        r"""getTorqueRangesRaw(ITorqueControlRaw self, double * min, double * max) -> bool"""
        return _yarp.ITorqueControlRaw_getTorqueRangesRaw(self, min, max)

    def setRefTorqueRaw(self, j, t):
        r"""setRefTorqueRaw(ITorqueControlRaw self, int j, double t) -> bool"""
        return _yarp.ITorqueControlRaw_setRefTorqueRaw(self, j, t)

    def setRefTorquesRaw(self, *args):
        r"""
        setRefTorquesRaw(ITorqueControlRaw self, double const * t) -> bool
        setRefTorquesRaw(ITorqueControlRaw self, int const n_joint, int const * joints, double const * t) -> bool
        """
        return _yarp.ITorqueControlRaw_setRefTorquesRaw(self, *args)

    def getRefTorquesRaw(self, t):
        r"""getRefTorquesRaw(ITorqueControlRaw self, double * t) -> bool"""
        return _yarp.ITorqueControlRaw_getRefTorquesRaw(self, t)

    def getRefTorqueRaw(self, j, t):
        r"""getRefTorqueRaw(ITorqueControlRaw self, int j, double * t) -> bool"""
        return _yarp.ITorqueControlRaw_getRefTorqueRaw(self, j, t)

    def getMotorTorqueParamsRaw(self, j, params):
        r"""getMotorTorqueParamsRaw(ITorqueControlRaw self, int j, MotorTorqueParameters params) -> bool"""
        return _yarp.ITorqueControlRaw_getMotorTorqueParamsRaw(self, j, params)

    def setMotorTorqueParamsRaw(self, j, params):
        r"""setMotorTorqueParamsRaw(ITorqueControlRaw self, int j, MotorTorqueParameters params) -> bool"""
        return _yarp.ITorqueControlRaw_setMotorTorqueParamsRaw(self, j, params)

# Register ITorqueControlRaw in _yarp:
_yarp.ITorqueControlRaw_swigregister(ITorqueControlRaw)

class IImpedanceControlRaw(object):
    r"""Proxy of C++ yarp::dev::IImpedanceControlRaw class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _yarp.delete_IImpedanceControlRaw

    def getAxes(self, ax):
        r"""getAxes(IImpedanceControlRaw self, int * ax) -> bool"""
        return _yarp.IImpedanceControlRaw_getAxes(self, ax)

    def getImpedanceRaw(self, j, stiffness, damping):
        r"""getImpedanceRaw(IImpedanceControlRaw self, int j, double * stiffness, double * damping) -> bool"""
        return _yarp.IImpedanceControlRaw_getImpedanceRaw(self, j, stiffness, damping)

    def setImpedanceRaw(self, j, stiffness, damping):
        r"""setImpedanceRaw(IImpedanceControlRaw self, int j, double stiffness, double damping) -> bool"""
        return _yarp.IImpedanceControlRaw_setImpedanceRaw(self, j, stiffness, damping)

    def setImpedanceOffsetRaw(self, j, offset):
        r"""setImpedanceOffsetRaw(IImpedanceControlRaw self, int j, double offset) -> bool"""
        return _yarp.IImpedanceControlRaw_setImpedanceOffsetRaw(self, j, offset)

    def getImpedanceOffsetRaw(self, j, offset):
        r"""getImpedanceOffsetRaw(IImpedanceControlRaw self, int j, double * offset) -> bool"""
        return _yarp.IImpedanceControlRaw_getImpedanceOffsetRaw(self, j, offset)

    def getCurrentImpedanceLimitRaw(self, j, min_stiff, max_stiff, min_damp, max_damp):
        r"""getCurrentImpedanceLimitRaw(IImpedanceControlRaw self, int j, double * min_stiff, double * max_stiff, double * min_damp, double * max_damp) -> bool"""
        return _yarp.IImpedanceControlRaw_getCurrentImpedanceLimitRaw(self, j, min_stiff, max_stiff, min_damp, max_damp)

# Register IImpedanceControlRaw in _yarp:
_yarp.IImpedanceControlRaw_swigregister(IImpedanceControlRaw)
VOCAB_TORQUE = cvar.VOCAB_TORQUE
VOCAB_TORQUE_MODE = cvar.VOCAB_TORQUE_MODE
VOCAB_TRQS = cvar.VOCAB_TRQS
VOCAB_TRQ = cvar.VOCAB_TRQ
VOCAB_BEMF = cvar.VOCAB_BEMF
VOCAB_MOTOR_PARAMS = cvar.VOCAB_MOTOR_PARAMS
VOCAB_RANGES = cvar.VOCAB_RANGES
VOCAB_RANGE = cvar.VOCAB_RANGE
VOCAB_IMP_PARAM = cvar.VOCAB_IMP_PARAM
VOCAB_IMP_OFFSET = cvar.VOCAB_IMP_OFFSET
VOCAB_TORQUES_DIRECTS = cvar.VOCAB_TORQUES_DIRECTS
VOCAB_TORQUES_DIRECT = cvar.VOCAB_TORQUES_DIRECT
VOCAB_TORQUES_DIRECT_GROUP = cvar.VOCAB_TORQUES_DIRECT_GROUP

class IImpedanceControl(object):
    r"""Proxy of C++ yarp::dev::IImpedanceControl class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _yarp.delete_IImpedanceControl

    def setImpedance(self, j, stiffness, damping):
        r"""setImpedance(IImpedanceControl self, int j, double stiffness, double damping) -> bool"""
        return _yarp.IImpedanceControl_setImpedance(self, j, stiffness, damping)

    def setImpedanceOffset(self, j, offset):
        r"""setImpedanceOffset(IImpedanceControl self, int j, double offset) -> bool"""
        return _yarp.IImpedanceControl_setImpedanceOffset(self, j, offset)

    def getAxes(self, *args):
        r"""
        getAxes(IImpedanceControl self, int * ax) -> bool
        getAxes(IImpedanceControl self) -> int
        """
        return _yarp.IImpedanceControl_getAxes(self, *args)

    def getImpedance(self, *args):
        r"""
        getImpedance(IImpedanceControl self, int j, double * stiffness, double * damping) -> bool
        getImpedance(IImpedanceControl self, int j, DVector stiffness, DVector damping) -> bool
        """
        return _yarp.IImpedanceControl_getImpedance(self, *args)

    def getImpedanceOffset(self, *args):
        r"""
        getImpedanceOffset(IImpedanceControl self, int j, double * offset) -> bool
        getImpedanceOffset(IImpedanceControl self, int j, DVector data) -> bool
        """
        return _yarp.IImpedanceControl_getImpedanceOffset(self, *args)

    def getCurrentImpedanceLimit(self, *args):
        r"""
        getCurrentImpedanceLimit(IImpedanceControl self, int j, double * min_stiff, double * max_stiff, double * min_damp, double * max_damp) -> bool
        getCurrentImpedanceLimit(IImpedanceControl self, int j, DVector min_stiff, DVector max_stiff, DVector min_damp, DVector max_damp) -> bool
        """
        return _yarp.IImpedanceControl_getCurrentImpedanceLimit(self, *args)

# Register IImpedanceControl in _yarp:
_yarp.IImpedanceControl_swigregister(IImpedanceControl)

class IVelocityControlRaw(object):
    r"""Proxy of C++ yarp::dev::IVelocityControlRaw class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _yarp.delete_IVelocityControlRaw

    def getAxes(self, axis):
        r"""getAxes(IVelocityControlRaw self, int * axis) -> bool"""
        return _yarp.IVelocityControlRaw_getAxes(self, axis)

    def setRefAccelerationRaw(self, j, acc):
        r"""setRefAccelerationRaw(IVelocityControlRaw self, int j, double acc) -> bool"""
        return _yarp.IVelocityControlRaw_setRefAccelerationRaw(self, j, acc)

    def getRefAccelerationRaw(self, j, acc):
        r"""getRefAccelerationRaw(IVelocityControlRaw self, int j, double * acc) -> bool"""
        return _yarp.IVelocityControlRaw_getRefAccelerationRaw(self, j, acc)

    def velocityMoveRaw(self, *args):
        r"""
        velocityMoveRaw(IVelocityControlRaw self, int j, double sp) -> bool
        velocityMoveRaw(IVelocityControlRaw self, double const * sp) -> bool
        velocityMoveRaw(IVelocityControlRaw self, int const n_joint, int const * joints, double const * spds) -> bool
        """
        return _yarp.IVelocityControlRaw_velocityMoveRaw(self, *args)

    def getRefVelocityRaw(self, joint, vel):
        r"""getRefVelocityRaw(IVelocityControlRaw self, int const joint, double * vel) -> bool"""
        return _yarp.IVelocityControlRaw_getRefVelocityRaw(self, joint, vel)

    def getRefVelocitiesRaw(self, *args):
        r"""
        getRefVelocitiesRaw(IVelocityControlRaw self, double * vels) -> bool
        getRefVelocitiesRaw(IVelocityControlRaw self, int const n_joint, int const * joints, double * vels) -> bool
        """
        return _yarp.IVelocityControlRaw_getRefVelocitiesRaw(self, *args)

    def setRefAccelerationsRaw(self, *args):
        r"""
        setRefAccelerationsRaw(IVelocityControlRaw self, double const * accs) -> bool
        setRefAccelerationsRaw(IVelocityControlRaw self, int const n_joint, int const * joints, double const * accs) -> bool
        """
        return _yarp.IVelocityControlRaw_setRefAccelerationsRaw(self, *args)

    def getRefAccelerationsRaw(self, *args):
        r"""
        getRefAccelerationsRaw(IVelocityControlRaw self, double * accs) -> bool
        getRefAccelerationsRaw(IVelocityControlRaw self, int const n_joint, int const * joints, double * accs) -> bool
        """
        return _yarp.IVelocityControlRaw_getRefAccelerationsRaw(self, *args)

    def stopRaw(self, *args):
        r"""
        stopRaw(IVelocityControlRaw self, int j) -> bool
        stopRaw(IVelocityControlRaw self) -> bool
        stopRaw(IVelocityControlRaw self, int const n_joint, int const * joints) -> bool
        """
        return _yarp.IVelocityControlRaw_stopRaw(self, *args)

# Register IVelocityControlRaw in _yarp:
_yarp.IVelocityControlRaw_swigregister(IVelocityControlRaw)
VOCAB_IMPEDANCE = cvar.VOCAB_IMPEDANCE
VOCAB_POSITION = cvar.VOCAB_POSITION
VOCAB_VELOCITY = cvar.VOCAB_VELOCITY

class IVelocityControl(object):
    r"""Proxy of C++ yarp::dev::IVelocityControl class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _yarp.delete_IVelocityControl

    def setRefAcceleration(self, j, acc):
        r"""setRefAcceleration(IVelocityControl self, int j, double acc) -> bool"""
        return _yarp.IVelocityControl_setRefAcceleration(self, j, acc)

    def getAxes(self, *args):
        r"""
        getAxes(IVelocityControl self, int * axes) -> bool
        getAxes(IVelocityControl self) -> int
        """
        return _yarp.IVelocityControl_getAxes(self, *args)

    def getRefAcceleration(self, *args):
        r"""
        getRefAcceleration(IVelocityControl self, int j, double * acc) -> bool
        getRefAcceleration(IVelocityControl self, int j, DVector data) -> bool
        """
        return _yarp.IVelocityControl_getRefAcceleration(self, *args)

    def velocityMove(self, *args):
        r"""
        velocityMove(IVelocityControl self, int j, double sp) -> bool
        velocityMove(IVelocityControl self, double const * sp) -> bool
        velocityMove(IVelocityControl self, int const n_joint, int const * joints, double const * spds) -> bool
        velocityMove(IVelocityControl self, DVector data) -> bool
        velocityMove(IVelocityControl self, int n_joint, IVector joints, DVector data) -> bool
        """
        return _yarp.IVelocityControl_velocityMove(self, *args)

    def getRefVelocity(self, *args):
        r"""
        getRefVelocity(IVelocityControl self, int const joint, double * vel) -> bool
        getRefVelocity(IVelocityControl self, int j, DVector data) -> bool
        """
        return _yarp.IVelocityControl_getRefVelocity(self, *args)

    def getRefVelocities(self, *args):
        r"""
        getRefVelocities(IVelocityControl self, double * vels) -> bool
        getRefVelocities(IVelocityControl self, int const n_joint, int const * joints, double * vels) -> bool
        getRefVelocities(IVelocityControl self, DVector data) -> bool
        getRefVelocities(IVelocityControl self, int n_joint, IVector joints, DVector data) -> bool
        """
        return _yarp.IVelocityControl_getRefVelocities(self, *args)

    def setRefAccelerations(self, *args):
        r"""
        setRefAccelerations(IVelocityControl self, double const * accs) -> bool
        setRefAccelerations(IVelocityControl self, int const n_joint, int const * joints, double const * accs) -> bool
        setRefAccelerations(IVelocityControl self, DVector data) -> bool
        setRefAccelerations(IVelocityControl self, int n_joint, IVector joints, DVector data) -> bool
        """
        return _yarp.IVelocityControl_setRefAccelerations(self, *args)

    def getRefAccelerations(self, *args):
        r"""
        getRefAccelerations(IVelocityControl self, double * accs) -> bool
        getRefAccelerations(IVelocityControl self, int const n_joint, int const * joints, double * accs) -> bool
        getRefAccelerations(IVelocityControl self, DVector data) -> bool
        getRefAccelerations(IVelocityControl self, int n_joint, IVector joints, DVector data) -> bool
        """
        return _yarp.IVelocityControl_getRefAccelerations(self, *args)

    def stop(self, *args):
        r"""
        stop(IVelocityControl self, int j) -> bool
        stop(IVelocityControl self) -> bool
        stop(IVelocityControl self, int const n_joint, int const * joints) -> bool
        stop(IVelocityControl self, int n_joint, IVector joints) -> bool
        """
        return _yarp.IVelocityControl_stop(self, *args)

# Register IVelocityControl in _yarp:
_yarp.IVelocityControl_swigregister(IVelocityControl)

class IPWMControl(object):
    r"""Proxy of C++ yarp::dev::IPWMControl class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _yarp.delete_IPWMControl

    def setRefDutyCycle(self, m, ref):
        r"""setRefDutyCycle(IPWMControl self, int m, double ref) -> bool"""
        return _yarp.IPWMControl_setRefDutyCycle(self, m, ref)

    def getNumberOfMotors(self, *args):
        r"""
        getNumberOfMotors(IPWMControl self, int * number) -> bool
        getNumberOfMotors(IPWMControl self) -> int
        """
        return _yarp.IPWMControl_getNumberOfMotors(self, *args)

    def setRefDutyCycles(self, *args):
        r"""
        setRefDutyCycles(IPWMControl self, double const * refs) -> bool
        setRefDutyCycles(IPWMControl self, DVector data) -> bool
        """
        return _yarp.IPWMControl_setRefDutyCycles(self, *args)

    def getRefDutyCycle(self, *args):
        r"""
        getRefDutyCycle(IPWMControl self, int m, double * ref) -> bool
        getRefDutyCycle(IPWMControl self, int j, DVector data) -> bool
        """
        return _yarp.IPWMControl_getRefDutyCycle(self, *args)

    def getRefDutyCycles(self, *args):
        r"""
        getRefDutyCycles(IPWMControl self, double * refs) -> bool
        getRefDutyCycles(IPWMControl self, DVector data) -> bool
        """
        return _yarp.IPWMControl_getRefDutyCycles(self, *args)

    def getDutyCycle(self, *args):
        r"""
        getDutyCycle(IPWMControl self, int m, double * val) -> bool
        getDutyCycle(IPWMControl self, int j, DVector data) -> bool
        """
        return _yarp.IPWMControl_getDutyCycle(self, *args)

    def getDutyCycles(self, *args):
        r"""
        getDutyCycles(IPWMControl self, double * vals) -> bool
        getDutyCycles(IPWMControl self, DVector data) -> bool
        """
        return _yarp.IPWMControl_getDutyCycles(self, *args)

# Register IPWMControl in _yarp:
_yarp.IPWMControl_swigregister(IPWMControl)
VOCAB_VELOCITY_MOVE_GROUP = cvar.VOCAB_VELOCITY_MOVE_GROUP
VOCAB_VEL_PID = cvar.VOCAB_VEL_PID
VOCAB_VEL_PIDS = cvar.VOCAB_VEL_PIDS

class IPWMControlRaw(object):
    r"""Proxy of C++ yarp::dev::IPWMControlRaw class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _yarp.delete_IPWMControlRaw

    def getNumberOfMotorsRaw(self, number):
        r"""getNumberOfMotorsRaw(IPWMControlRaw self, int * number) -> bool"""
        return _yarp.IPWMControlRaw_getNumberOfMotorsRaw(self, number)

    def setRefDutyCycleRaw(self, m, ref):
        r"""setRefDutyCycleRaw(IPWMControlRaw self, int m, double ref) -> bool"""
        return _yarp.IPWMControlRaw_setRefDutyCycleRaw(self, m, ref)

    def setRefDutyCyclesRaw(self, refs):
        r"""setRefDutyCyclesRaw(IPWMControlRaw self, double const * refs) -> bool"""
        return _yarp.IPWMControlRaw_setRefDutyCyclesRaw(self, refs)

    def getRefDutyCycleRaw(self, m, ref):
        r"""getRefDutyCycleRaw(IPWMControlRaw self, int m, double * ref) -> bool"""
        return _yarp.IPWMControlRaw_getRefDutyCycleRaw(self, m, ref)

    def getRefDutyCyclesRaw(self, refs):
        r"""getRefDutyCyclesRaw(IPWMControlRaw self, double * refs) -> bool"""
        return _yarp.IPWMControlRaw_getRefDutyCyclesRaw(self, refs)

    def getDutyCycleRaw(self, m, val):
        r"""getDutyCycleRaw(IPWMControlRaw self, int m, double * val) -> bool"""
        return _yarp.IPWMControlRaw_getDutyCycleRaw(self, m, val)

    def getDutyCyclesRaw(self, vals):
        r"""getDutyCyclesRaw(IPWMControlRaw self, double * vals) -> bool"""
        return _yarp.IPWMControlRaw_getDutyCyclesRaw(self, vals)

# Register IPWMControlRaw in _yarp:
_yarp.IPWMControlRaw_swigregister(IPWMControlRaw)

class ICurrentControl(object):
    r"""Proxy of C++ yarp::dev::ICurrentControl class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _yarp.delete_ICurrentControl

    def setRefCurrent(self, m, curr):
        r"""setRefCurrent(ICurrentControl self, int m, double curr) -> bool"""
        return _yarp.ICurrentControl_setRefCurrent(self, m, curr)

    def getNumberOfMotors(self, *args):
        r"""
        getNumberOfMotors(ICurrentControl self, int * ax) -> bool
        getNumberOfMotors(ICurrentControl self) -> int
        """
        return _yarp.ICurrentControl_getNumberOfMotors(self, *args)

    def getCurrent(self, *args):
        r"""
        getCurrent(ICurrentControl self, int m, double * curr) -> bool
        getCurrent(ICurrentControl self, int j, DVector data) -> bool
        """
        return _yarp.ICurrentControl_getCurrent(self, *args)

    def getCurrents(self, *args):
        r"""
        getCurrents(ICurrentControl self, double * currs) -> bool
        getCurrents(ICurrentControl self, DVector data) -> bool
        """
        return _yarp.ICurrentControl_getCurrents(self, *args)

    def getCurrentRange(self, *args):
        r"""
        getCurrentRange(ICurrentControl self, int m, double * min, double * max) -> bool
        getCurrentRange(ICurrentControl self, int j, DVector min, DVector max) -> bool
        """
        return _yarp.ICurrentControl_getCurrentRange(self, *args)

    def getCurrentRanges(self, *args):
        r"""
        getCurrentRanges(ICurrentControl self, double * min, double * max) -> bool
        getCurrentRanges(ICurrentControl self, DVector mins, DVector maxs) -> bool
        """
        return _yarp.ICurrentControl_getCurrentRanges(self, *args)

    def setRefCurrents(self, *args):
        r"""
        setRefCurrents(ICurrentControl self, double const * currs) -> bool
        setRefCurrents(ICurrentControl self, int const n_motor, int const * motors, double const * currs) -> bool
        setRefCurrents(ICurrentControl self, DVector data) -> bool
        setRefCurrents(ICurrentControl self, int n_joint, IVector joints, DVector data) -> bool
        """
        return _yarp.ICurrentControl_setRefCurrents(self, *args)

    def getRefCurrents(self, *args):
        r"""
        getRefCurrents(ICurrentControl self, double * currs) -> bool
        getRefCurrents(ICurrentControl self, DVector data) -> bool
        """
        return _yarp.ICurrentControl_getRefCurrents(self, *args)

    def getRefCurrent(self, *args):
        r"""
        getRefCurrent(ICurrentControl self, int m, double * curr) -> bool
        getRefCurrent(ICurrentControl self, int j, DVector data) -> bool
        """
        return _yarp.ICurrentControl_getRefCurrent(self, *args)

# Register ICurrentControl in _yarp:
_yarp.ICurrentControl_swigregister(ICurrentControl)
VOCAB_PWMCONTROL_INTERFACE = cvar.VOCAB_PWMCONTROL_INTERFACE
VOCAB_PWMCONTROL_REF_PWM = cvar.VOCAB_PWMCONTROL_REF_PWM
VOCAB_PWMCONTROL_REF_PWMS = cvar.VOCAB_PWMCONTROL_REF_PWMS
VOCAB_PWMCONTROL_PWM_OUTPUT = cvar.VOCAB_PWMCONTROL_PWM_OUTPUT
VOCAB_PWMCONTROL_PWM_OUTPUTS = cvar.VOCAB_PWMCONTROL_PWM_OUTPUTS

class ICurrentControlRaw(object):
    r"""Proxy of C++ yarp::dev::ICurrentControlRaw class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _yarp.delete_ICurrentControlRaw

    def getNumberOfMotorsRaw(self, number):
        r"""getNumberOfMotorsRaw(ICurrentControlRaw self, int * number) -> bool"""
        return _yarp.ICurrentControlRaw_getNumberOfMotorsRaw(self, number)

    def getCurrentRaw(self, m, curr):
        r"""getCurrentRaw(ICurrentControlRaw self, int m, double * curr) -> bool"""
        return _yarp.ICurrentControlRaw_getCurrentRaw(self, m, curr)

    def getCurrentsRaw(self, currs):
        r"""getCurrentsRaw(ICurrentControlRaw self, double * currs) -> bool"""
        return _yarp.ICurrentControlRaw_getCurrentsRaw(self, currs)

    def getCurrentRangeRaw(self, m, min, max):
        r"""getCurrentRangeRaw(ICurrentControlRaw self, int m, double * min, double * max) -> bool"""
        return _yarp.ICurrentControlRaw_getCurrentRangeRaw(self, m, min, max)

    def getCurrentRangesRaw(self, min, max):
        r"""getCurrentRangesRaw(ICurrentControlRaw self, double * min, double * max) -> bool"""
        return _yarp.ICurrentControlRaw_getCurrentRangesRaw(self, min, max)

    def setRefCurrentRaw(self, m, curr):
        r"""setRefCurrentRaw(ICurrentControlRaw self, int m, double curr) -> bool"""
        return _yarp.ICurrentControlRaw_setRefCurrentRaw(self, m, curr)

    def setRefCurrentsRaw(self, *args):
        r"""
        setRefCurrentsRaw(ICurrentControlRaw self, double const * currs) -> bool
        setRefCurrentsRaw(ICurrentControlRaw self, int const n_motor, int const * motors, double const * currs) -> bool
        """
        return _yarp.ICurrentControlRaw_setRefCurrentsRaw(self, *args)

    def getRefCurrentsRaw(self, currs):
        r"""getRefCurrentsRaw(ICurrentControlRaw self, double * currs) -> bool"""
        return _yarp.ICurrentControlRaw_getRefCurrentsRaw(self, currs)

    def getRefCurrentRaw(self, m, curr):
        r"""getRefCurrentRaw(ICurrentControlRaw self, int m, double * curr) -> bool"""
        return _yarp.ICurrentControlRaw_getRefCurrentRaw(self, m, curr)

# Register ICurrentControlRaw in _yarp:
_yarp.ICurrentControlRaw_swigregister(ICurrentControlRaw)

class IAnalogSensor(object):
    r"""Proxy of C++ yarp::dev::IAnalogSensor class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    AS_OK = _yarp.IAnalogSensor_AS_OK
    
    AS_ERROR = _yarp.IAnalogSensor_AS_ERROR
    
    AS_OVF = _yarp.IAnalogSensor_AS_OVF
    
    AS_TIMEOUT = _yarp.IAnalogSensor_AS_TIMEOUT
    
    __swig_destroy__ = _yarp.delete_IAnalogSensor

    def read(self, out):
        r"""read(IAnalogSensor self, Vector out) -> int"""
        return _yarp.IAnalogSensor_read(self, out)

    def getState(self, ch):
        r"""getState(IAnalogSensor self, int ch) -> int"""
        return _yarp.IAnalogSensor_getState(self, ch)

    def getChannels(self):
        r"""getChannels(IAnalogSensor self) -> int"""
        return _yarp.IAnalogSensor_getChannels(self)

    def calibrateSensor(self, *args):
        r"""
        calibrateSensor(IAnalogSensor self) -> int
        calibrateSensor(IAnalogSensor self, Vector value) -> int
        """
        return _yarp.IAnalogSensor_calibrateSensor(self, *args)

    def calibrateChannel(self, *args):
        r"""
        calibrateChannel(IAnalogSensor self, int ch) -> int
        calibrateChannel(IAnalogSensor self, int ch, double value) -> int
        """
        return _yarp.IAnalogSensor_calibrateChannel(self, *args)

# Register IAnalogSensor in _yarp:
_yarp.IAnalogSensor_swigregister(IAnalogSensor)
VOCAB_CURRENTCONTROL_INTERFACE = cvar.VOCAB_CURRENTCONTROL_INTERFACE
VOCAB_CURRENT_REF = cvar.VOCAB_CURRENT_REF
VOCAB_CURRENT_REFS = cvar.VOCAB_CURRENT_REFS
VOCAB_CURRENT_REF_GROUP = cvar.VOCAB_CURRENT_REF_GROUP
VOCAB_CURRENT_RANGE = cvar.VOCAB_CURRENT_RANGE
VOCAB_CURRENT_RANGES = cvar.VOCAB_CURRENT_RANGES
VOCAB_IANALOG = cvar.VOCAB_IANALOG

class IRemoteVariablesRaw(object):
    r"""Proxy of C++ yarp::dev::IRemoteVariablesRaw class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _yarp.delete_IRemoteVariablesRaw

    def getRemoteVariableRaw(self, key, val):
        r"""getRemoteVariableRaw(IRemoteVariablesRaw self, std::string key, Bottle val) -> bool"""
        return _yarp.IRemoteVariablesRaw_getRemoteVariableRaw(self, key, val)

    def setRemoteVariableRaw(self, key, val):
        r"""setRemoteVariableRaw(IRemoteVariablesRaw self, std::string key, Bottle val) -> bool"""
        return _yarp.IRemoteVariablesRaw_setRemoteVariableRaw(self, key, val)

    def getRemoteVariablesListRaw(self, listOfKeys):
        r"""getRemoteVariablesListRaw(IRemoteVariablesRaw self, Bottle listOfKeys) -> bool"""
        return _yarp.IRemoteVariablesRaw_getRemoteVariablesListRaw(self, listOfKeys)

# Register IRemoteVariablesRaw in _yarp:
_yarp.IRemoteVariablesRaw_swigregister(IRemoteVariablesRaw)

class IRemoteVariables(object):
    r"""Proxy of C++ yarp::dev::IRemoteVariables class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _yarp.delete_IRemoteVariables

    def getRemoteVariable(self, key, val):
        r"""getRemoteVariable(IRemoteVariables self, std::string key, Bottle val) -> bool"""
        return _yarp.IRemoteVariables_getRemoteVariable(self, key, val)

    def setRemoteVariable(self, key, val):
        r"""setRemoteVariable(IRemoteVariables self, std::string key, Bottle val) -> bool"""
        return _yarp.IRemoteVariables_setRemoteVariable(self, key, val)

    def getRemoteVariablesList(self, listOfKeys):
        r"""getRemoteVariablesList(IRemoteVariables self, Bottle listOfKeys) -> bool"""
        return _yarp.IRemoteVariables_getRemoteVariablesList(self, listOfKeys)

# Register IRemoteVariables in _yarp:
_yarp.IRemoteVariables_swigregister(IRemoteVariables)

class IPidControlRaw(object):
    r"""Proxy of C++ yarp::dev::IPidControlRaw class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _yarp.delete_IPidControlRaw

    def setPidRaw(self, pidtype, j, pid):
        r"""setPidRaw(IPidControlRaw self, PidControlTypeEnum const & pidtype, int j, Pid pid) -> bool"""
        return _yarp.IPidControlRaw_setPidRaw(self, pidtype, j, pid)

    def setPidsRaw(self, pidtype, pids):
        r"""setPidsRaw(IPidControlRaw self, PidControlTypeEnum const & pidtype, Pid pids) -> bool"""
        return _yarp.IPidControlRaw_setPidsRaw(self, pidtype, pids)

    def setPidReferenceRaw(self, pidtype, j, ref):
        r"""setPidReferenceRaw(IPidControlRaw self, PidControlTypeEnum const & pidtype, int j, double ref) -> bool"""
        return _yarp.IPidControlRaw_setPidReferenceRaw(self, pidtype, j, ref)

    def setPidReferencesRaw(self, pidtype, refs):
        r"""setPidReferencesRaw(IPidControlRaw self, PidControlTypeEnum const & pidtype, double const * refs) -> bool"""
        return _yarp.IPidControlRaw_setPidReferencesRaw(self, pidtype, refs)

    def setPidErrorLimitRaw(self, pidtype, j, limit):
        r"""setPidErrorLimitRaw(IPidControlRaw self, PidControlTypeEnum const & pidtype, int j, double limit) -> bool"""
        return _yarp.IPidControlRaw_setPidErrorLimitRaw(self, pidtype, j, limit)

    def setPidErrorLimitsRaw(self, pidtype, limits):
        r"""setPidErrorLimitsRaw(IPidControlRaw self, PidControlTypeEnum const & pidtype, double const * limits) -> bool"""
        return _yarp.IPidControlRaw_setPidErrorLimitsRaw(self, pidtype, limits)

    def getPidErrorRaw(self, pidtype, j, err):
        r"""getPidErrorRaw(IPidControlRaw self, PidControlTypeEnum const & pidtype, int j, double * err) -> bool"""
        return _yarp.IPidControlRaw_getPidErrorRaw(self, pidtype, j, err)

    def getPidErrorsRaw(self, pidtype, errs):
        r"""getPidErrorsRaw(IPidControlRaw self, PidControlTypeEnum const & pidtype, double * errs) -> bool"""
        return _yarp.IPidControlRaw_getPidErrorsRaw(self, pidtype, errs)

    def getPidOutputRaw(self, pidtype, j, out):
        r"""getPidOutputRaw(IPidControlRaw self, PidControlTypeEnum const & pidtype, int j, double * out) -> bool"""
        return _yarp.IPidControlRaw_getPidOutputRaw(self, pidtype, j, out)

    def getPidOutputsRaw(self, pidtype, outs):
        r"""getPidOutputsRaw(IPidControlRaw self, PidControlTypeEnum const & pidtype, double * outs) -> bool"""
        return _yarp.IPidControlRaw_getPidOutputsRaw(self, pidtype, outs)

    def getPidRaw(self, pidtype, j, pid):
        r"""getPidRaw(IPidControlRaw self, PidControlTypeEnum const & pidtype, int j, Pid pid) -> bool"""
        return _yarp.IPidControlRaw_getPidRaw(self, pidtype, j, pid)

    def getPidsRaw(self, pidtype, pids):
        r"""getPidsRaw(IPidControlRaw self, PidControlTypeEnum const & pidtype, Pid pids) -> bool"""
        return _yarp.IPidControlRaw_getPidsRaw(self, pidtype, pids)

    def getPidReferenceRaw(self, pidtype, j, ref):
        r"""getPidReferenceRaw(IPidControlRaw self, PidControlTypeEnum const & pidtype, int j, double * ref) -> bool"""
        return _yarp.IPidControlRaw_getPidReferenceRaw(self, pidtype, j, ref)

    def getPidReferencesRaw(self, pidtype, refs):
        r"""getPidReferencesRaw(IPidControlRaw self, PidControlTypeEnum const & pidtype, double * refs) -> bool"""
        return _yarp.IPidControlRaw_getPidReferencesRaw(self, pidtype, refs)

    def getPidErrorLimitRaw(self, pidtype, j, limit):
        r"""getPidErrorLimitRaw(IPidControlRaw self, PidControlTypeEnum const & pidtype, int j, double * limit) -> bool"""
        return _yarp.IPidControlRaw_getPidErrorLimitRaw(self, pidtype, j, limit)

    def getPidErrorLimitsRaw(self, pidtype, limits):
        r"""getPidErrorLimitsRaw(IPidControlRaw self, PidControlTypeEnum const & pidtype, double * limits) -> bool"""
        return _yarp.IPidControlRaw_getPidErrorLimitsRaw(self, pidtype, limits)

    def resetPidRaw(self, pidtype, j):
        r"""resetPidRaw(IPidControlRaw self, PidControlTypeEnum const & pidtype, int j) -> bool"""
        return _yarp.IPidControlRaw_resetPidRaw(self, pidtype, j)

    def disablePidRaw(self, pidtype, j):
        r"""disablePidRaw(IPidControlRaw self, PidControlTypeEnum const & pidtype, int j) -> bool"""
        return _yarp.IPidControlRaw_disablePidRaw(self, pidtype, j)

    def enablePidRaw(self, pidtype, j):
        r"""enablePidRaw(IPidControlRaw self, PidControlTypeEnum const & pidtype, int j) -> bool"""
        return _yarp.IPidControlRaw_enablePidRaw(self, pidtype, j)

    def setPidOffsetRaw(self, pidtype, j, v):
        r"""setPidOffsetRaw(IPidControlRaw self, PidControlTypeEnum const & pidtype, int j, double v) -> bool"""
        return _yarp.IPidControlRaw_setPidOffsetRaw(self, pidtype, j, v)

    def isPidEnabledRaw(self, pidtype, j, enabled):
        r"""isPidEnabledRaw(IPidControlRaw self, PidControlTypeEnum const & pidtype, int j, bool * enabled) -> bool"""
        return _yarp.IPidControlRaw_isPidEnabledRaw(self, pidtype, j, enabled)

# Register IPidControlRaw in _yarp:
_yarp.IPidControlRaw_swigregister(IPidControlRaw)
VOCAB_REMOTE_VARIABILE_INTERFACE = cvar.VOCAB_REMOTE_VARIABILE_INTERFACE
VOCAB_VARIABLE = cvar.VOCAB_VARIABLE
VOCAB_LIST_VARIABLES = cvar.VOCAB_LIST_VARIABLES

class IPidControl(object):
    r"""Proxy of C++ yarp::dev::IPidControl class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _yarp.delete_IPidControl

    def setPid(self, *args):
        r"""
        setPid(IPidControl self, PidControlTypeEnum const & pidtype, int j, Pid pid) -> bool
        setPid(IPidControl self, int pidtype, int j, Pid pid) -> bool
        """
        return _yarp.IPidControl_setPid(self, *args)

    def setPids(self, *args):
        r"""
        setPids(IPidControl self, PidControlTypeEnum const & pidtype, Pid pids) -> bool
        setPids(IPidControl self, int pidtype, PidVector pids) -> bool
        """
        return _yarp.IPidControl_setPids(self, *args)

    def setPidReference(self, *args):
        r"""
        setPidReference(IPidControl self, PidControlTypeEnum const & pidtype, int j, double ref) -> bool
        setPidReference(IPidControl self, int pidtype, int j, double ref) -> bool
        """
        return _yarp.IPidControl_setPidReference(self, *args)

    def setPidReferences(self, *args):
        r"""
        setPidReferences(IPidControl self, PidControlTypeEnum const & pidtype, double const * refs) -> bool
        setPidReferences(IPidControl self, int pidtype, DVector data) -> bool
        """
        return _yarp.IPidControl_setPidReferences(self, *args)

    def setPidErrorLimit(self, *args):
        r"""
        setPidErrorLimit(IPidControl self, PidControlTypeEnum const & pidtype, int j, double limit) -> bool
        setPidErrorLimit(IPidControl self, int pidtype, int j, double limit) -> bool
        """
        return _yarp.IPidControl_setPidErrorLimit(self, *args)

    def setPidErrorLimits(self, *args):
        r"""
        setPidErrorLimits(IPidControl self, PidControlTypeEnum const & pidtype, double const * limits) -> bool
        setPidErrorLimits(IPidControl self, int pidtype, DVector data) -> bool
        """
        return _yarp.IPidControl_setPidErrorLimits(self, *args)

    def getPidError(self, *args):
        r"""
        getPidError(IPidControl self, PidControlTypeEnum const & pidtype, int j, double * err) -> bool
        getPidError(IPidControl self, int pidtype, int j, DVector data) -> bool
        """
        return _yarp.IPidControl_getPidError(self, *args)

    def getPidErrors(self, *args):
        r"""
        getPidErrors(IPidControl self, PidControlTypeEnum const & pidtype, double * errs) -> bool
        getPidErrors(IPidControl self, int pidtype, DVector data) -> bool
        """
        return _yarp.IPidControl_getPidErrors(self, *args)

    def getPidOutput(self, *args):
        r"""
        getPidOutput(IPidControl self, PidControlTypeEnum const & pidtype, int j, double * out) -> bool
        getPidOutput(IPidControl self, int pidtype, int j, DVector data) -> bool
        """
        return _yarp.IPidControl_getPidOutput(self, *args)

    def getPidOutputs(self, *args):
        r"""
        getPidOutputs(IPidControl self, PidControlTypeEnum const & pidtype, double * outs) -> bool
        getPidOutputs(IPidControl self, int pidtype, DVector data) -> bool
        """
        return _yarp.IPidControl_getPidOutputs(self, *args)

    def getPid(self, *args):
        r"""
        getPid(IPidControl self, PidControlTypeEnum const & pidtype, int j, Pid pid) -> bool
        getPid(IPidControl self, int pidtype, int j, PidVector data) -> bool
        """
        return _yarp.IPidControl_getPid(self, *args)

    def getPids(self, *args):
        r"""
        getPids(IPidControl self, PidControlTypeEnum const & pidtype, Pid pids) -> bool
        getPids(IPidControl self, int pidtype, PidVector data) -> bool
        """
        return _yarp.IPidControl_getPids(self, *args)

    def getPidReference(self, *args):
        r"""
        getPidReference(IPidControl self, PidControlTypeEnum const & pidtype, int j, double * ref) -> bool
        getPidReference(IPidControl self, int pidtype, int j, DVector data) -> bool
        """
        return _yarp.IPidControl_getPidReference(self, *args)

    def getPidReferences(self, *args):
        r"""
        getPidReferences(IPidControl self, PidControlTypeEnum const & pidtype, double * refs) -> bool
        getPidReferences(IPidControl self, int pidtype, DVector data) -> bool
        """
        return _yarp.IPidControl_getPidReferences(self, *args)

    def getPidErrorLimit(self, *args):
        r"""
        getPidErrorLimit(IPidControl self, PidControlTypeEnum const & pidtype, int j, double * limit) -> bool
        getPidErrorLimit(IPidControl self, int pidtype, int j, DVector data) -> bool
        """
        return _yarp.IPidControl_getPidErrorLimit(self, *args)

    def getPidErrorLimits(self, *args):
        r"""
        getPidErrorLimits(IPidControl self, PidControlTypeEnum const & pidtype, double * limits) -> bool
        getPidErrorLimits(IPidControl self, int pidtype, DVector data) -> bool
        """
        return _yarp.IPidControl_getPidErrorLimits(self, *args)

    def resetPid(self, *args):
        r"""
        resetPid(IPidControl self, PidControlTypeEnum const & pidtype, int j) -> bool
        resetPid(IPidControl self, int pidtype, int j) -> bool
        """
        return _yarp.IPidControl_resetPid(self, *args)

    def disablePid(self, *args):
        r"""
        disablePid(IPidControl self, PidControlTypeEnum const & pidtype, int j) -> bool
        disablePid(IPidControl self, int pidtype, int j) -> bool
        """
        return _yarp.IPidControl_disablePid(self, *args)

    def enablePid(self, *args):
        r"""
        enablePid(IPidControl self, PidControlTypeEnum const & pidtype, int j) -> bool
        enablePid(IPidControl self, int pidtype, int j) -> bool
        """
        return _yarp.IPidControl_enablePid(self, *args)

    def setPidOffset(self, *args):
        r"""
        setPidOffset(IPidControl self, PidControlTypeEnum const & pidtype, int j, double v) -> bool
        setPidOffset(IPidControl self, int pidtype, int j, double offset) -> bool
        """
        return _yarp.IPidControl_setPidOffset(self, *args)

    def isPidEnabled(self, *args):
        r"""
        isPidEnabled(IPidControl self, PidControlTypeEnum const & pidtype, int j, bool * enabled) -> bool
        isPidEnabled(IPidControl self, int pidtype, int j, BVector flag) -> bool
        """
        return _yarp.IPidControl_isPidEnabled(self, *args)

# Register IPidControl in _yarp:
_yarp.IPidControl_swigregister(IPidControl)

class IPositionDirect(object):
    r"""Proxy of C++ yarp::dev::IPositionDirect class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _yarp.delete_IPositionDirect

    def setPosition(self, j, ref):
        r"""setPosition(IPositionDirect self, int j, double ref) -> bool"""
        return _yarp.IPositionDirect_setPosition(self, j, ref)

    def getAxes(self, *args):
        r"""
        getAxes(IPositionDirect self, int * ax) -> bool
        getAxes(IPositionDirect self) -> int
        """
        return _yarp.IPositionDirect_getAxes(self, *args)

    def setPositions(self, *args):
        r"""
        setPositions(IPositionDirect self, int const n_joint, int const * joints, double const * refs) -> bool
        setPositions(IPositionDirect self, double const * refs) -> bool
        setPositions(IPositionDirect self, int n_joint, IVector joints, DVector data) -> bool
        setPositions(IPositionDirect self, DVector data) -> bool
        """
        return _yarp.IPositionDirect_setPositions(self, *args)

    def getRefPosition(self, *args):
        r"""
        getRefPosition(IPositionDirect self, int const joint, double * ref) -> bool
        getRefPosition(IPositionDirect self, int j, DVector data) -> bool
        """
        return _yarp.IPositionDirect_getRefPosition(self, *args)

    def getRefPositions(self, *args):
        r"""
        getRefPositions(IPositionDirect self, double * refs) -> bool
        getRefPositions(IPositionDirect self, int const n_joint, int const * joints, double * refs) -> bool
        getRefPositions(IPositionDirect self, DVector data) -> bool
        getRefPositions(IPositionDirect self, int n_joint, IVector joints, DVector data) -> bool
        """
        return _yarp.IPositionDirect_getRefPositions(self, *args)

# Register IPositionDirect in _yarp:
_yarp.IPositionDirect_swigregister(IPositionDirect)
VOCAB_PID = cvar.VOCAB_PID
VOCAB_PIDS = cvar.VOCAB_PIDS

class IPositionDirectRaw(object):
    r"""Proxy of C++ yarp::dev::IPositionDirectRaw class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _yarp.delete_IPositionDirectRaw

    def getAxes(self, axes):
        r"""getAxes(IPositionDirectRaw self, int * axes) -> bool"""
        return _yarp.IPositionDirectRaw_getAxes(self, axes)

    def setPositionRaw(self, j, ref):
        r"""setPositionRaw(IPositionDirectRaw self, int j, double ref) -> bool"""
        return _yarp.IPositionDirectRaw_setPositionRaw(self, j, ref)

    def setPositionsRaw(self, *args):
        r"""
        setPositionsRaw(IPositionDirectRaw self, int const n_joint, int const * joints, double const * refs) -> bool
        setPositionsRaw(IPositionDirectRaw self, double const * refs) -> bool
        """
        return _yarp.IPositionDirectRaw_setPositionsRaw(self, *args)

    def getRefPositionRaw(self, joint, ref):
        r"""getRefPositionRaw(IPositionDirectRaw self, int const joint, double * ref) -> bool"""
        return _yarp.IPositionDirectRaw_getRefPositionRaw(self, joint, ref)

    def getRefPositionsRaw(self, *args):
        r"""
        getRefPositionsRaw(IPositionDirectRaw self, double * refs) -> bool
        getRefPositionsRaw(IPositionDirectRaw self, int const n_joint, int const * joints, double * refs) -> bool
        """
        return _yarp.IPositionDirectRaw_getRefPositionsRaw(self, *args)

# Register IPositionDirectRaw in _yarp:
_yarp.IPositionDirectRaw_swigregister(IPositionDirectRaw)

MAS_OK = _yarp.MAS_OK

MAS_ERROR = _yarp.MAS_ERROR

MAS_OVF = _yarp.MAS_OVF

MAS_TIMEOUT = _yarp.MAS_TIMEOUT

MAS_WAITING_FOR_FIRST_READ = _yarp.MAS_WAITING_FOR_FIRST_READ

MAS_UNKNOWN = _yarp.MAS_UNKNOWN

class IThreeAxisGyroscopes(object):
    r"""Proxy of C++ yarp::dev::IThreeAxisGyroscopes class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def getNrOfThreeAxisGyroscopes(self):
        r"""getNrOfThreeAxisGyroscopes(IThreeAxisGyroscopes self) -> size_t"""
        return _yarp.IThreeAxisGyroscopes_getNrOfThreeAxisGyroscopes(self)

    def getThreeAxisGyroscopeStatus(self, sens_index):
        r"""getThreeAxisGyroscopeStatus(IThreeAxisGyroscopes self, size_t sens_index) -> yarp::dev::MAS_status"""
        return _yarp.IThreeAxisGyroscopes_getThreeAxisGyroscopeStatus(self, sens_index)
    __swig_destroy__ = _yarp.delete_IThreeAxisGyroscopes

    def getThreeAxisGyroscopeName(self, *args):
        r"""
        getThreeAxisGyroscopeName(IThreeAxisGyroscopes self, size_t sens_index, std::string & name) -> bool
        getThreeAxisGyroscopeName(IThreeAxisGyroscopes self, int sens_index) -> std::string
        """
        return _yarp.IThreeAxisGyroscopes_getThreeAxisGyroscopeName(self, *args)

    def getThreeAxisGyroscopeFrameName(self, *args):
        r"""
        getThreeAxisGyroscopeFrameName(IThreeAxisGyroscopes self, size_t sens_index, std::string & frameName) -> bool
        getThreeAxisGyroscopeFrameName(IThreeAxisGyroscopes self, int sens_index) -> std::string
        """
        return _yarp.IThreeAxisGyroscopes_getThreeAxisGyroscopeFrameName(self, *args)

    def getThreeAxisGyroscopeMeasure(self, *args):
        r"""
        getThreeAxisGyroscopeMeasure(IThreeAxisGyroscopes self, size_t sens_index, Vector out, double & timestamp) -> bool
        getThreeAxisGyroscopeMeasure(IThreeAxisGyroscopes self, int sens_index, Vector out) -> double
        """
        return _yarp.IThreeAxisGyroscopes_getThreeAxisGyroscopeMeasure(self, *args)

# Register IThreeAxisGyroscopes in _yarp:
_yarp.IThreeAxisGyroscopes_swigregister(IThreeAxisGyroscopes)
VOCAB_POSITION_DIRECT = cvar.VOCAB_POSITION_DIRECT
VOCAB_POSITION_DIRECTS = cvar.VOCAB_POSITION_DIRECTS
VOCAB_POSITION_DIRECT_GROUP = cvar.VOCAB_POSITION_DIRECT_GROUP
ThreeAxisGyroscope_EXTENDED_INTERFACE = _yarp.ThreeAxisGyroscope_EXTENDED_INTERFACE


class IThreeAxisLinearAccelerometers(object):
    r"""Proxy of C++ yarp::dev::IThreeAxisLinearAccelerometers class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def getNrOfThreeAxisLinearAccelerometers(self):
        r"""getNrOfThreeAxisLinearAccelerometers(IThreeAxisLinearAccelerometers self) -> size_t"""
        return _yarp.IThreeAxisLinearAccelerometers_getNrOfThreeAxisLinearAccelerometers(self)

    def getThreeAxisLinearAccelerometerStatus(self, sens_index):
        r"""getThreeAxisLinearAccelerometerStatus(IThreeAxisLinearAccelerometers self, size_t sens_index) -> yarp::dev::MAS_status"""
        return _yarp.IThreeAxisLinearAccelerometers_getThreeAxisLinearAccelerometerStatus(self, sens_index)
    __swig_destroy__ = _yarp.delete_IThreeAxisLinearAccelerometers

    def getThreeAxisLinearAccelerometerName(self, *args):
        r"""
        getThreeAxisLinearAccelerometerName(IThreeAxisLinearAccelerometers self, size_t sens_index, std::string & name) -> bool
        getThreeAxisLinearAccelerometerName(IThreeAxisLinearAccelerometers self, int sens_index) -> std::string
        """
        return _yarp.IThreeAxisLinearAccelerometers_getThreeAxisLinearAccelerometerName(self, *args)

    def getThreeAxisLinearAccelerometerFrameName(self, *args):
        r"""
        getThreeAxisLinearAccelerometerFrameName(IThreeAxisLinearAccelerometers self, size_t sens_index, std::string & frameName) -> bool
        getThreeAxisLinearAccelerometerFrameName(IThreeAxisLinearAccelerometers self, int sens_index) -> std::string
        """
        return _yarp.IThreeAxisLinearAccelerometers_getThreeAxisLinearAccelerometerFrameName(self, *args)

    def getThreeAxisLinearAccelerometerMeasure(self, *args):
        r"""
        getThreeAxisLinearAccelerometerMeasure(IThreeAxisLinearAccelerometers self, size_t sens_index, Vector out, double & timestamp) -> bool
        getThreeAxisLinearAccelerometerMeasure(IThreeAxisLinearAccelerometers self, int sens_index, Vector out) -> double
        """
        return _yarp.IThreeAxisLinearAccelerometers_getThreeAxisLinearAccelerometerMeasure(self, *args)

# Register IThreeAxisLinearAccelerometers in _yarp:
_yarp.IThreeAxisLinearAccelerometers_swigregister(IThreeAxisLinearAccelerometers)
ThreeAxisLinearAccelerometer_EXTENDED_INTERFACE = _yarp.ThreeAxisLinearAccelerometer_EXTENDED_INTERFACE


class IThreeAxisMagnetometers(object):
    r"""Proxy of C++ yarp::dev::IThreeAxisMagnetometers class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def getNrOfThreeAxisMagnetometers(self):
        r"""getNrOfThreeAxisMagnetometers(IThreeAxisMagnetometers self) -> size_t"""
        return _yarp.IThreeAxisMagnetometers_getNrOfThreeAxisMagnetometers(self)

    def getThreeAxisMagnetometerStatus(self, sens_index):
        r"""getThreeAxisMagnetometerStatus(IThreeAxisMagnetometers self, size_t sens_index) -> yarp::dev::MAS_status"""
        return _yarp.IThreeAxisMagnetometers_getThreeAxisMagnetometerStatus(self, sens_index)
    __swig_destroy__ = _yarp.delete_IThreeAxisMagnetometers

    def getThreeAxisMagnetometerName(self, *args):
        r"""
        getThreeAxisMagnetometerName(IThreeAxisMagnetometers self, size_t sens_index, std::string & name) -> bool
        getThreeAxisMagnetometerName(IThreeAxisMagnetometers self, int sens_index) -> std::string
        """
        return _yarp.IThreeAxisMagnetometers_getThreeAxisMagnetometerName(self, *args)

    def getThreeAxisMagnetometerFrameName(self, *args):
        r"""
        getThreeAxisMagnetometerFrameName(IThreeAxisMagnetometers self, size_t sens_index, std::string & frameName) -> bool
        getThreeAxisMagnetometerFrameName(IThreeAxisMagnetometers self, int sens_index) -> std::string
        """
        return _yarp.IThreeAxisMagnetometers_getThreeAxisMagnetometerFrameName(self, *args)

    def getThreeAxisMagnetometerMeasure(self, *args):
        r"""
        getThreeAxisMagnetometerMeasure(IThreeAxisMagnetometers self, size_t sens_index, Vector out, double & timestamp) -> bool
        getThreeAxisMagnetometerMeasure(IThreeAxisMagnetometers self, int sens_index, Vector out) -> double
        """
        return _yarp.IThreeAxisMagnetometers_getThreeAxisMagnetometerMeasure(self, *args)

# Register IThreeAxisMagnetometers in _yarp:
_yarp.IThreeAxisMagnetometers_swigregister(IThreeAxisMagnetometers)
ThreeAxisMagnetometer_EXTENDED_INTERFACE = _yarp.ThreeAxisMagnetometer_EXTENDED_INTERFACE


class IPositionSensors(object):
    r"""Proxy of C++ yarp::dev::IPositionSensors class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def getNrOfPositionSensors(self):
        r"""getNrOfPositionSensors(IPositionSensors self) -> size_t"""
        return _yarp.IPositionSensors_getNrOfPositionSensors(self)

    def getPositionSensorStatus(self, sens_index):
        r"""getPositionSensorStatus(IPositionSensors self, size_t sens_index) -> yarp::dev::MAS_status"""
        return _yarp.IPositionSensors_getPositionSensorStatus(self, sens_index)

    def getPositionSensorName(self, sens_index, name):
        r"""getPositionSensorName(IPositionSensors self, size_t sens_index, std::string & name) -> bool"""
        return _yarp.IPositionSensors_getPositionSensorName(self, sens_index, name)

    def getPositionSensorFrameName(self, sens_index, frameName):
        r"""getPositionSensorFrameName(IPositionSensors self, size_t sens_index, std::string & frameName) -> bool"""
        return _yarp.IPositionSensors_getPositionSensorFrameName(self, sens_index, frameName)

    def getPositionSensorMeasure(self, sens_index, xyz, timestamp):
        r"""getPositionSensorMeasure(IPositionSensors self, size_t sens_index, Vector xyz, double & timestamp) -> bool"""
        return _yarp.IPositionSensors_getPositionSensorMeasure(self, sens_index, xyz, timestamp)
    __swig_destroy__ = _yarp.delete_IPositionSensors

# Register IPositionSensors in _yarp:
_yarp.IPositionSensors_swigregister(IPositionSensors)

class IOrientationSensors(object):
    r"""Proxy of C++ yarp::dev::IOrientationSensors class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def getNrOfOrientationSensors(self):
        r"""getNrOfOrientationSensors(IOrientationSensors self) -> size_t"""
        return _yarp.IOrientationSensors_getNrOfOrientationSensors(self)

    def getOrientationSensorStatus(self, sens_index):
        r"""getOrientationSensorStatus(IOrientationSensors self, size_t sens_index) -> yarp::dev::MAS_status"""
        return _yarp.IOrientationSensors_getOrientationSensorStatus(self, sens_index)
    __swig_destroy__ = _yarp.delete_IOrientationSensors

    def getOrientationSensorName(self, *args):
        r"""
        getOrientationSensorName(IOrientationSensors self, size_t sens_index, std::string & name) -> bool
        getOrientationSensorName(IOrientationSensors self, int sens_index) -> std::string
        """
        return _yarp.IOrientationSensors_getOrientationSensorName(self, *args)

    def getOrientationSensorFrameName(self, *args):
        r"""
        getOrientationSensorFrameName(IOrientationSensors self, size_t sens_index, std::string & frameName) -> bool
        getOrientationSensorFrameName(IOrientationSensors self, int sens_index) -> std::string
        """
        return _yarp.IOrientationSensors_getOrientationSensorFrameName(self, *args)

    def getOrientationSensorMeasureAsRollPitchYaw(self, *args):
        r"""
        getOrientationSensorMeasureAsRollPitchYaw(IOrientationSensors self, size_t sens_index, Vector rpy, double & timestamp) -> bool
        getOrientationSensorMeasureAsRollPitchYaw(IOrientationSensors self, int sens_index, Vector rpy) -> double
        """
        return _yarp.IOrientationSensors_getOrientationSensorMeasureAsRollPitchYaw(self, *args)

# Register IOrientationSensors in _yarp:
_yarp.IOrientationSensors_swigregister(IOrientationSensors)
OrientationSensor_EXTENDED_INTERFACE = _yarp.OrientationSensor_EXTENDED_INTERFACE


class ITemperatureSensors(object):
    r"""Proxy of C++ yarp::dev::ITemperatureSensors class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def getNrOfTemperatureSensors(self):
        r"""getNrOfTemperatureSensors(ITemperatureSensors self) -> size_t"""
        return _yarp.ITemperatureSensors_getNrOfTemperatureSensors(self)

    def getTemperatureSensorStatus(self, sens_index):
        r"""getTemperatureSensorStatus(ITemperatureSensors self, size_t sens_index) -> yarp::dev::MAS_status"""
        return _yarp.ITemperatureSensors_getTemperatureSensorStatus(self, sens_index)
    __swig_destroy__ = _yarp.delete_ITemperatureSensors

    def getTemperatureSensorName(self, *args):
        r"""
        getTemperatureSensorName(ITemperatureSensors self, size_t sens_index, std::string & name) -> bool
        getTemperatureSensorName(ITemperatureSensors self, int sens_index) -> std::string
        """
        return _yarp.ITemperatureSensors_getTemperatureSensorName(self, *args)

    def getTemperatureSensorFrameName(self, *args):
        r"""
        getTemperatureSensorFrameName(ITemperatureSensors self, size_t sens_index, std::string & frameName) -> bool
        getTemperatureSensorFrameName(ITemperatureSensors self, int sens_index) -> std::string
        """
        return _yarp.ITemperatureSensors_getTemperatureSensorFrameName(self, *args)

    def getTemperatureSensorMeasure(self, *args):
        r"""
        getTemperatureSensorMeasure(ITemperatureSensors self, size_t sens_index, double & out, double & timestamp) -> bool
        getTemperatureSensorMeasure(ITemperatureSensors self, size_t sens_index, Vector out, double & timestamp) -> bool
        getTemperatureSensorMeasure(ITemperatureSensors self, int sens_index, Vector out) -> double
        """
        return _yarp.ITemperatureSensors_getTemperatureSensorMeasure(self, *args)

# Register ITemperatureSensors in _yarp:
_yarp.ITemperatureSensors_swigregister(ITemperatureSensors)
TemperatureSensor_EXTENDED_INTERFACE = _yarp.TemperatureSensor_EXTENDED_INTERFACE


class ISixAxisForceTorqueSensors(object):
    r"""Proxy of C++ yarp::dev::ISixAxisForceTorqueSensors class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def getNrOfSixAxisForceTorqueSensors(self):
        r"""getNrOfSixAxisForceTorqueSensors(ISixAxisForceTorqueSensors self) -> size_t"""
        return _yarp.ISixAxisForceTorqueSensors_getNrOfSixAxisForceTorqueSensors(self)

    def getSixAxisForceTorqueSensorStatus(self, sens_index):
        r"""getSixAxisForceTorqueSensorStatus(ISixAxisForceTorqueSensors self, size_t sens_index) -> yarp::dev::MAS_status"""
        return _yarp.ISixAxisForceTorqueSensors_getSixAxisForceTorqueSensorStatus(self, sens_index)
    __swig_destroy__ = _yarp.delete_ISixAxisForceTorqueSensors

    def getSixAxisForceTorqueSensorName(self, *args):
        r"""
        getSixAxisForceTorqueSensorName(ISixAxisForceTorqueSensors self, size_t sens_index, std::string & name) -> bool
        getSixAxisForceTorqueSensorName(ISixAxisForceTorqueSensors self, int sens_index) -> std::string
        """
        return _yarp.ISixAxisForceTorqueSensors_getSixAxisForceTorqueSensorName(self, *args)

    def getSixAxisForceTorqueSensorFrameName(self, *args):
        r"""
        getSixAxisForceTorqueSensorFrameName(ISixAxisForceTorqueSensors self, size_t sens_index, std::string & frameName) -> bool
        getSixAxisForceTorqueSensorFrameName(ISixAxisForceTorqueSensors self, int sens_index) -> std::string
        """
        return _yarp.ISixAxisForceTorqueSensors_getSixAxisForceTorqueSensorFrameName(self, *args)

    def getSixAxisForceTorqueSensorMeasure(self, *args):
        r"""
        getSixAxisForceTorqueSensorMeasure(ISixAxisForceTorqueSensors self, size_t sens_index, Vector out, double & timestamp) -> bool
        getSixAxisForceTorqueSensorMeasure(ISixAxisForceTorqueSensors self, int sens_index, Vector out) -> double
        """
        return _yarp.ISixAxisForceTorqueSensors_getSixAxisForceTorqueSensorMeasure(self, *args)

# Register ISixAxisForceTorqueSensors in _yarp:
_yarp.ISixAxisForceTorqueSensors_swigregister(ISixAxisForceTorqueSensors)
SixAxisForceTorqueSensor_EXTENDED_INTERFACE = _yarp.SixAxisForceTorqueSensor_EXTENDED_INTERFACE


class IContactLoadCellArrays(object):
    r"""Proxy of C++ yarp::dev::IContactLoadCellArrays class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def getNrOfContactLoadCellArrays(self):
        r"""getNrOfContactLoadCellArrays(IContactLoadCellArrays self) -> size_t"""
        return _yarp.IContactLoadCellArrays_getNrOfContactLoadCellArrays(self)

    def getContactLoadCellArrayStatus(self, sens_index):
        r"""getContactLoadCellArrayStatus(IContactLoadCellArrays self, size_t sens_index) -> yarp::dev::MAS_status"""
        return _yarp.IContactLoadCellArrays_getContactLoadCellArrayStatus(self, sens_index)

    def getContactLoadCellArraySize(self, sens_index):
        r"""getContactLoadCellArraySize(IContactLoadCellArrays self, size_t sens_index) -> size_t"""
        return _yarp.IContactLoadCellArrays_getContactLoadCellArraySize(self, sens_index)
    __swig_destroy__ = _yarp.delete_IContactLoadCellArrays

    def getContactLoadCellArrayName(self, *args):
        r"""
        getContactLoadCellArrayName(IContactLoadCellArrays self, size_t sens_index, std::string & name) -> bool
        getContactLoadCellArrayName(IContactLoadCellArrays self, int sens_index) -> std::string
        """
        return _yarp.IContactLoadCellArrays_getContactLoadCellArrayName(self, *args)

    def getContactLoadCellArrayMeasure(self, *args):
        r"""
        getContactLoadCellArrayMeasure(IContactLoadCellArrays self, size_t sens_index, Vector out, double & timestamp) -> bool
        getContactLoadCellArrayMeasure(IContactLoadCellArrays self, int sens_index, Vector out) -> double
        """
        return _yarp.IContactLoadCellArrays_getContactLoadCellArrayMeasure(self, *args)

# Register IContactLoadCellArrays in _yarp:
_yarp.IContactLoadCellArrays_swigregister(IContactLoadCellArrays)
ContactLoadCellArray_EXTENDED_INTERFACE = _yarp.ContactLoadCellArray_EXTENDED_INTERFACE


class IEncoderArrays(object):
    r"""Proxy of C++ yarp::dev::IEncoderArrays class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def getNrOfEncoderArrays(self):
        r"""getNrOfEncoderArrays(IEncoderArrays self) -> size_t"""
        return _yarp.IEncoderArrays_getNrOfEncoderArrays(self)

    def getEncoderArrayStatus(self, sens_index):
        r"""getEncoderArrayStatus(IEncoderArrays self, size_t sens_index) -> yarp::dev::MAS_status"""
        return _yarp.IEncoderArrays_getEncoderArrayStatus(self, sens_index)

    def getEncoderArraySize(self, sens_index):
        r"""getEncoderArraySize(IEncoderArrays self, size_t sens_index) -> size_t"""
        return _yarp.IEncoderArrays_getEncoderArraySize(self, sens_index)
    __swig_destroy__ = _yarp.delete_IEncoderArrays

    def getEncoderArrayName(self, *args):
        r"""
        getEncoderArrayName(IEncoderArrays self, size_t sens_index, std::string & name) -> bool
        getEncoderArrayName(IEncoderArrays self, int sens_index) -> std::string
        """
        return _yarp.IEncoderArrays_getEncoderArrayName(self, *args)

    def getEncoderArrayMeasure(self, *args):
        r"""
        getEncoderArrayMeasure(IEncoderArrays self, size_t sens_index, Vector out, double & timestamp) -> bool
        getEncoderArrayMeasure(IEncoderArrays self, int sens_index, Vector out) -> double
        """
        return _yarp.IEncoderArrays_getEncoderArrayMeasure(self, *args)

# Register IEncoderArrays in _yarp:
_yarp.IEncoderArrays_swigregister(IEncoderArrays)
EncoderArray_EXTENDED_INTERFACE = _yarp.EncoderArray_EXTENDED_INTERFACE


class ISkinPatches(object):
    r"""Proxy of C++ yarp::dev::ISkinPatches class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def getNrOfSkinPatches(self):
        r"""getNrOfSkinPatches(ISkinPatches self) -> size_t"""
        return _yarp.ISkinPatches_getNrOfSkinPatches(self)

    def getSkinPatchStatus(self, sens_index):
        r"""getSkinPatchStatus(ISkinPatches self, size_t sens_index) -> yarp::dev::MAS_status"""
        return _yarp.ISkinPatches_getSkinPatchStatus(self, sens_index)

    def getSkinPatchSize(self, sens_index):
        r"""getSkinPatchSize(ISkinPatches self, size_t sens_index) -> size_t"""
        return _yarp.ISkinPatches_getSkinPatchSize(self, sens_index)
    __swig_destroy__ = _yarp.delete_ISkinPatches

    def getSkinPatchName(self, *args):
        r"""
        getSkinPatchName(ISkinPatches self, size_t sens_index, std::string & name) -> bool
        getSkinPatchName(ISkinPatches self, int sens_index) -> std::string
        """
        return _yarp.ISkinPatches_getSkinPatchName(self, *args)

    def getSkinPatchMeasure(self, *args):
        r"""
        getSkinPatchMeasure(ISkinPatches self, size_t sens_index, Vector out, double & timestamp) -> bool
        getSkinPatchMeasure(ISkinPatches self, int sens_index, Vector out) -> double
        """
        return _yarp.ISkinPatches_getSkinPatchMeasure(self, *args)

# Register ISkinPatches in _yarp:
_yarp.ISkinPatches_swigregister(ISkinPatches)
SkinPatch_EXTENDED_INTERFACE = _yarp.SkinPatch_EXTENDED_INTERFACE


class IFrameGrabber(object):
    r"""Proxy of C++ yarp::dev::IFrameGrabber class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _yarp.delete_IFrameGrabber

    def getRawBuffer(self, buffer):
        r"""getRawBuffer(IFrameGrabber self, unsigned char * buffer) -> bool"""
        return _yarp.IFrameGrabber_getRawBuffer(self, buffer)

    def getRawBufferSize(self):
        r"""getRawBufferSize(IFrameGrabber self) -> int"""
        return _yarp.IFrameGrabber_getRawBufferSize(self)

    def height(self):
        r"""height(IFrameGrabber self) -> int"""
        return _yarp.IFrameGrabber_height(self)

    def width(self):
        r"""width(IFrameGrabber self) -> int"""
        return _yarp.IFrameGrabber_width(self)

# Register IFrameGrabber in _yarp:
_yarp.IFrameGrabber_swigregister(IFrameGrabber)

class IFrameGrabberRgb(object):
    r"""Proxy of C++ yarp::dev::IFrameGrabberRgb class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _yarp.delete_IFrameGrabberRgb

    def getRgbBuffer(self, buffer):
        r"""getRgbBuffer(IFrameGrabberRgb self, unsigned char * buffer) -> bool"""
        return _yarp.IFrameGrabberRgb_getRgbBuffer(self, buffer)

    def height(self):
        r"""height(IFrameGrabberRgb self) -> int"""
        return _yarp.IFrameGrabberRgb_height(self)

    def width(self):
        r"""width(IFrameGrabberRgb self) -> int"""
        return _yarp.IFrameGrabberRgb_width(self)

# Register IFrameGrabberRgb in _yarp:
_yarp.IFrameGrabberRgb_swigregister(IFrameGrabberRgb)

class DVector(object):
    r"""Proxy of C++ std::vector< double > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        r"""iterator(DVector self) -> SwigPyIterator"""
        return _yarp.DVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        r"""__nonzero__(DVector self) -> bool"""
        return _yarp.DVector___nonzero__(self)

    def __bool__(self):
        r"""__bool__(DVector self) -> bool"""
        return _yarp.DVector___bool__(self)

    def __len__(self):
        r"""__len__(DVector self) -> std::vector< double >::size_type"""
        return _yarp.DVector___len__(self)

    def __getslice__(self, i, j):
        r"""__getslice__(DVector self, std::vector< double >::difference_type i, std::vector< double >::difference_type j) -> DVector"""
        return _yarp.DVector___getslice__(self, i, j)

    def __setslice__(self, *args):
        r"""
        __setslice__(DVector self, std::vector< double >::difference_type i, std::vector< double >::difference_type j)
        __setslice__(DVector self, std::vector< double >::difference_type i, std::vector< double >::difference_type j, DVector v)
        """
        return _yarp.DVector___setslice__(self, *args)

    def __delslice__(self, i, j):
        r"""__delslice__(DVector self, std::vector< double >::difference_type i, std::vector< double >::difference_type j)"""
        return _yarp.DVector___delslice__(self, i, j)

    def __delitem__(self, *args):
        r"""
        __delitem__(DVector self, std::vector< double >::difference_type i)
        __delitem__(DVector self, PySliceObject * slice)
        """
        return _yarp.DVector___delitem__(self, *args)

    def __getitem__(self, *args):
        r"""
        __getitem__(DVector self, PySliceObject * slice) -> DVector
        __getitem__(DVector self, std::vector< double >::difference_type i) -> std::vector< double >::value_type const &
        """
        return _yarp.DVector___getitem__(self, *args)

    def __setitem__(self, *args):
        r"""
        __setitem__(DVector self, PySliceObject * slice, DVector v)
        __setitem__(DVector self, PySliceObject * slice)
        __setitem__(DVector self, std::vector< double >::difference_type i, std::vector< double >::value_type const & x)
        """
        return _yarp.DVector___setitem__(self, *args)

    def pop(self):
        r"""pop(DVector self) -> std::vector< double >::value_type"""
        return _yarp.DVector_pop(self)

    def append(self, x):
        r"""append(DVector self, std::vector< double >::value_type const & x)"""
        return _yarp.DVector_append(self, x)

    def empty(self):
        r"""empty(DVector self) -> bool"""
        return _yarp.DVector_empty(self)

    def size(self):
        r"""size(DVector self) -> std::vector< double >::size_type"""
        return _yarp.DVector_size(self)

    def swap(self, v):
        r"""swap(DVector self, DVector v)"""
        return _yarp.DVector_swap(self, v)

    def begin(self):
        r"""begin(DVector self) -> std::vector< double >::iterator"""
        return _yarp.DVector_begin(self)

    def end(self):
        r"""end(DVector self) -> std::vector< double >::iterator"""
        return _yarp.DVector_end(self)

    def rbegin(self):
        r"""rbegin(DVector self) -> std::vector< double >::reverse_iterator"""
        return _yarp.DVector_rbegin(self)

    def rend(self):
        r"""rend(DVector self) -> std::vector< double >::reverse_iterator"""
        return _yarp.DVector_rend(self)

    def clear(self):
        r"""clear(DVector self)"""
        return _yarp.DVector_clear(self)

    def get_allocator(self):
        r"""get_allocator(DVector self) -> std::vector< double >::allocator_type"""
        return _yarp.DVector_get_allocator(self)

    def pop_back(self):
        r"""pop_back(DVector self)"""
        return _yarp.DVector_pop_back(self)

    def erase(self, *args):
        r"""
        erase(DVector self, std::vector< double >::iterator pos) -> std::vector< double >::iterator
        erase(DVector self, std::vector< double >::iterator first, std::vector< double >::iterator last) -> std::vector< double >::iterator
        """
        return _yarp.DVector_erase(self, *args)

    def __init__(self, *args):
        r"""
        __init__(DVector self) -> DVector
        __init__(DVector self, DVector other) -> DVector
        __init__(DVector self, std::vector< double >::size_type size) -> DVector
        __init__(DVector self, std::vector< double >::size_type size, std::vector< double >::value_type const & value) -> DVector
        """
        _yarp.DVector_swiginit(self, _yarp.new_DVector(*args))

    def push_back(self, x):
        r"""push_back(DVector self, std::vector< double >::value_type const & x)"""
        return _yarp.DVector_push_back(self, x)

    def front(self):
        r"""front(DVector self) -> std::vector< double >::value_type const &"""
        return _yarp.DVector_front(self)

    def back(self):
        r"""back(DVector self) -> std::vector< double >::value_type const &"""
        return _yarp.DVector_back(self)

    def assign(self, n, x):
        r"""assign(DVector self, std::vector< double >::size_type n, std::vector< double >::value_type const & x)"""
        return _yarp.DVector_assign(self, n, x)

    def resize(self, *args):
        r"""
        resize(DVector self, std::vector< double >::size_type new_size)
        resize(DVector self, std::vector< double >::size_type new_size, std::vector< double >::value_type const & x)
        """
        return _yarp.DVector_resize(self, *args)

    def insert(self, *args):
        r"""
        insert(DVector self, std::vector< double >::iterator pos, std::vector< double >::value_type const & x) -> std::vector< double >::iterator
        insert(DVector self, std::vector< double >::iterator pos, std::vector< double >::size_type n, std::vector< double >::value_type const & x)
        """
        return _yarp.DVector_insert(self, *args)

    def reserve(self, n):
        r"""reserve(DVector self, std::vector< double >::size_type n)"""
        return _yarp.DVector_reserve(self, n)

    def capacity(self):
        r"""capacity(DVector self) -> std::vector< double >::size_type"""
        return _yarp.DVector_capacity(self)
    __swig_destroy__ = _yarp.delete_DVector

# Register DVector in _yarp:
_yarp.DVector_swigregister(DVector)

class BVector(object):
    r"""Proxy of C++ std::vector< bool > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        r"""iterator(BVector self) -> SwigPyIterator"""
        return _yarp.BVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        r"""__nonzero__(BVector self) -> bool"""
        return _yarp.BVector___nonzero__(self)

    def __bool__(self):
        r"""__bool__(BVector self) -> bool"""
        return _yarp.BVector___bool__(self)

    def __len__(self):
        r"""__len__(BVector self) -> std::vector< bool >::size_type"""
        return _yarp.BVector___len__(self)

    def __getslice__(self, i, j):
        r"""__getslice__(BVector self, std::vector< bool >::difference_type i, std::vector< bool >::difference_type j) -> BVector"""
        return _yarp.BVector___getslice__(self, i, j)

    def __setslice__(self, *args):
        r"""
        __setslice__(BVector self, std::vector< bool >::difference_type i, std::vector< bool >::difference_type j)
        __setslice__(BVector self, std::vector< bool >::difference_type i, std::vector< bool >::difference_type j, BVector v)
        """
        return _yarp.BVector___setslice__(self, *args)

    def __delslice__(self, i, j):
        r"""__delslice__(BVector self, std::vector< bool >::difference_type i, std::vector< bool >::difference_type j)"""
        return _yarp.BVector___delslice__(self, i, j)

    def __delitem__(self, *args):
        r"""
        __delitem__(BVector self, std::vector< bool >::difference_type i)
        __delitem__(BVector self, PySliceObject * slice)
        """
        return _yarp.BVector___delitem__(self, *args)

    def __getitem__(self, *args):
        r"""
        __getitem__(BVector self, PySliceObject * slice) -> BVector
        __getitem__(BVector self, std::vector< bool >::difference_type i) -> std::vector< bool >::value_type
        """
        return _yarp.BVector___getitem__(self, *args)

    def __setitem__(self, *args):
        r"""
        __setitem__(BVector self, PySliceObject * slice, BVector v)
        __setitem__(BVector self, PySliceObject * slice)
        __setitem__(BVector self, std::vector< bool >::difference_type i, std::vector< bool >::value_type x)
        """
        return _yarp.BVector___setitem__(self, *args)

    def pop(self):
        r"""pop(BVector self) -> std::vector< bool >::value_type"""
        return _yarp.BVector_pop(self)

    def append(self, x):
        r"""append(BVector self, std::vector< bool >::value_type x)"""
        return _yarp.BVector_append(self, x)

    def empty(self):
        r"""empty(BVector self) -> bool"""
        return _yarp.BVector_empty(self)

    def size(self):
        r"""size(BVector self) -> std::vector< bool >::size_type"""
        return _yarp.BVector_size(self)

    def swap(self, v):
        r"""swap(BVector self, BVector v)"""
        return _yarp.BVector_swap(self, v)

    def begin(self):
        r"""begin(BVector self) -> std::vector< bool >::iterator"""
        return _yarp.BVector_begin(self)

    def end(self):
        r"""end(BVector self) -> std::vector< bool >::iterator"""
        return _yarp.BVector_end(self)

    def rbegin(self):
        r"""rbegin(BVector self) -> std::vector< bool >::reverse_iterator"""
        return _yarp.BVector_rbegin(self)

    def rend(self):
        r"""rend(BVector self) -> std::vector< bool >::reverse_iterator"""
        return _yarp.BVector_rend(self)

    def clear(self):
        r"""clear(BVector self)"""
        return _yarp.BVector_clear(self)

    def get_allocator(self):
        r"""get_allocator(BVector self) -> std::vector< bool >::allocator_type"""
        return _yarp.BVector_get_allocator(self)

    def pop_back(self):
        r"""pop_back(BVector self)"""
        return _yarp.BVector_pop_back(self)

    def erase(self, *args):
        r"""
        erase(BVector self, std::vector< bool >::iterator pos) -> std::vector< bool >::iterator
        erase(BVector self, std::vector< bool >::iterator first, std::vector< bool >::iterator last) -> std::vector< bool >::iterator
        """
        return _yarp.BVector_erase(self, *args)

    def __init__(self, *args):
        r"""
        __init__(BVector self) -> BVector
        __init__(BVector self, BVector other) -> BVector
        __init__(BVector self, std::vector< bool >::size_type size) -> BVector
        __init__(BVector self, std::vector< bool >::size_type size, std::vector< bool >::value_type value) -> BVector
        """
        _yarp.BVector_swiginit(self, _yarp.new_BVector(*args))

    def push_back(self, x):
        r"""push_back(BVector self, std::vector< bool >::value_type x)"""
        return _yarp.BVector_push_back(self, x)

    def front(self):
        r"""front(BVector self) -> std::vector< bool >::value_type"""
        return _yarp.BVector_front(self)

    def back(self):
        r"""back(BVector self) -> std::vector< bool >::value_type"""
        return _yarp.BVector_back(self)

    def assign(self, n, x):
        r"""assign(BVector self, std::vector< bool >::size_type n, std::vector< bool >::value_type x)"""
        return _yarp.BVector_assign(self, n, x)

    def resize(self, *args):
        r"""
        resize(BVector self, std::vector< bool >::size_type new_size)
        resize(BVector self, std::vector< bool >::size_type new_size, std::vector< bool >::value_type x)
        """
        return _yarp.BVector_resize(self, *args)

    def insert(self, *args):
        r"""
        insert(BVector self, std::vector< bool >::iterator pos, std::vector< bool >::value_type x) -> std::vector< bool >::iterator
        insert(BVector self, std::vector< bool >::iterator pos, std::vector< bool >::size_type n, std::vector< bool >::value_type x)
        """
        return _yarp.BVector_insert(self, *args)

    def reserve(self, n):
        r"""reserve(BVector self, std::vector< bool >::size_type n)"""
        return _yarp.BVector_reserve(self, n)

    def capacity(self):
        r"""capacity(BVector self) -> std::vector< bool >::size_type"""
        return _yarp.BVector_capacity(self)
    __swig_destroy__ = _yarp.delete_BVector

# Register BVector in _yarp:
_yarp.BVector_swigregister(BVector)

class SVector(object):
    r"""Proxy of C++ std::vector< std::string > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        r"""iterator(SVector self) -> SwigPyIterator"""
        return _yarp.SVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        r"""__nonzero__(SVector self) -> bool"""
        return _yarp.SVector___nonzero__(self)

    def __bool__(self):
        r"""__bool__(SVector self) -> bool"""
        return _yarp.SVector___bool__(self)

    def __len__(self):
        r"""__len__(SVector self) -> std::vector< std::string >::size_type"""
        return _yarp.SVector___len__(self)

    def __getslice__(self, i, j):
        r"""__getslice__(SVector self, std::vector< std::string >::difference_type i, std::vector< std::string >::difference_type j) -> std::vector< std::string,std::allocator< std::string > > *"""
        return _yarp.SVector___getslice__(self, i, j)

    def __setslice__(self, *args):
        r"""
        __setslice__(SVector self, std::vector< std::string >::difference_type i, std::vector< std::string >::difference_type j)
        __setslice__(SVector self, std::vector< std::string >::difference_type i, std::vector< std::string >::difference_type j, std::vector< std::string,std::allocator< std::string > > const & v)
        """
        return _yarp.SVector___setslice__(self, *args)

    def __delslice__(self, i, j):
        r"""__delslice__(SVector self, std::vector< std::string >::difference_type i, std::vector< std::string >::difference_type j)"""
        return _yarp.SVector___delslice__(self, i, j)

    def __delitem__(self, *args):
        r"""
        __delitem__(SVector self, std::vector< std::string >::difference_type i)
        __delitem__(SVector self, PySliceObject * slice)
        """
        return _yarp.SVector___delitem__(self, *args)

    def __getitem__(self, *args):
        r"""
        __getitem__(SVector self, PySliceObject * slice) -> std::vector< std::string,std::allocator< std::string > >
        __getitem__(SVector self, std::vector< std::string >::difference_type i) -> std::vector< std::string >::value_type const &
        """
        return _yarp.SVector___getitem__(self, *args)

    def __setitem__(self, *args):
        r"""
        __setitem__(SVector self, PySliceObject * slice, std::vector< std::string,std::allocator< std::string > > const & v)
        __setitem__(SVector self, PySliceObject * slice)
        __setitem__(SVector self, std::vector< std::string >::difference_type i, std::vector< std::string >::value_type const & x)
        """
        return _yarp.SVector___setitem__(self, *args)

    def pop(self):
        r"""pop(SVector self) -> std::vector< std::string >::value_type"""
        return _yarp.SVector_pop(self)

    def append(self, x):
        r"""append(SVector self, std::vector< std::string >::value_type const & x)"""
        return _yarp.SVector_append(self, x)

    def empty(self):
        r"""empty(SVector self) -> bool"""
        return _yarp.SVector_empty(self)

    def size(self):
        r"""size(SVector self) -> std::vector< std::string >::size_type"""
        return _yarp.SVector_size(self)

    def swap(self, v):
        r"""swap(SVector self, SVector v)"""
        return _yarp.SVector_swap(self, v)

    def begin(self):
        r"""begin(SVector self) -> std::vector< std::string >::iterator"""
        return _yarp.SVector_begin(self)

    def end(self):
        r"""end(SVector self) -> std::vector< std::string >::iterator"""
        return _yarp.SVector_end(self)

    def rbegin(self):
        r"""rbegin(SVector self) -> std::vector< std::string >::reverse_iterator"""
        return _yarp.SVector_rbegin(self)

    def rend(self):
        r"""rend(SVector self) -> std::vector< std::string >::reverse_iterator"""
        return _yarp.SVector_rend(self)

    def clear(self):
        r"""clear(SVector self)"""
        return _yarp.SVector_clear(self)

    def get_allocator(self):
        r"""get_allocator(SVector self) -> std::vector< std::string >::allocator_type"""
        return _yarp.SVector_get_allocator(self)

    def pop_back(self):
        r"""pop_back(SVector self)"""
        return _yarp.SVector_pop_back(self)

    def erase(self, *args):
        r"""
        erase(SVector self, std::vector< std::string >::iterator pos) -> std::vector< std::string >::iterator
        erase(SVector self, std::vector< std::string >::iterator first, std::vector< std::string >::iterator last) -> std::vector< std::string >::iterator
        """
        return _yarp.SVector_erase(self, *args)

    def __init__(self, *args):
        r"""
        __init__(SVector self) -> SVector
        __init__(SVector self, SVector other) -> SVector
        __init__(SVector self, std::vector< std::string >::size_type size) -> SVector
        __init__(SVector self, std::vector< std::string >::size_type size, std::vector< std::string >::value_type const & value) -> SVector
        """
        _yarp.SVector_swiginit(self, _yarp.new_SVector(*args))

    def push_back(self, x):
        r"""push_back(SVector self, std::vector< std::string >::value_type const & x)"""
        return _yarp.SVector_push_back(self, x)

    def front(self):
        r"""front(SVector self) -> std::vector< std::string >::value_type const &"""
        return _yarp.SVector_front(self)

    def back(self):
        r"""back(SVector self) -> std::vector< std::string >::value_type const &"""
        return _yarp.SVector_back(self)

    def assign(self, n, x):
        r"""assign(SVector self, std::vector< std::string >::size_type n, std::vector< std::string >::value_type const & x)"""
        return _yarp.SVector_assign(self, n, x)

    def resize(self, *args):
        r"""
        resize(SVector self, std::vector< std::string >::size_type new_size)
        resize(SVector self, std::vector< std::string >::size_type new_size, std::vector< std::string >::value_type const & x)
        """
        return _yarp.SVector_resize(self, *args)

    def insert(self, *args):
        r"""
        insert(SVector self, std::vector< std::string >::iterator pos, std::vector< std::string >::value_type const & x) -> std::vector< std::string >::iterator
        insert(SVector self, std::vector< std::string >::iterator pos, std::vector< std::string >::size_type n, std::vector< std::string >::value_type const & x)
        """
        return _yarp.SVector_insert(self, *args)

    def reserve(self, n):
        r"""reserve(SVector self, std::vector< std::string >::size_type n)"""
        return _yarp.SVector_reserve(self, n)

    def capacity(self):
        r"""capacity(SVector self) -> std::vector< std::string >::size_type"""
        return _yarp.SVector_capacity(self)
    __swig_destroy__ = _yarp.delete_SVector

# Register SVector in _yarp:
_yarp.SVector_swigregister(SVector)

class IVector(object):
    r"""Proxy of C++ std::vector< int > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        r"""iterator(IVector self) -> SwigPyIterator"""
        return _yarp.IVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        r"""__nonzero__(IVector self) -> bool"""
        return _yarp.IVector___nonzero__(self)

    def __bool__(self):
        r"""__bool__(IVector self) -> bool"""
        return _yarp.IVector___bool__(self)

    def __len__(self):
        r"""__len__(IVector self) -> std::vector< int >::size_type"""
        return _yarp.IVector___len__(self)

    def __getslice__(self, i, j):
        r"""__getslice__(IVector self, std::vector< int >::difference_type i, std::vector< int >::difference_type j) -> IVector"""
        return _yarp.IVector___getslice__(self, i, j)

    def __setslice__(self, *args):
        r"""
        __setslice__(IVector self, std::vector< int >::difference_type i, std::vector< int >::difference_type j)
        __setslice__(IVector self, std::vector< int >::difference_type i, std::vector< int >::difference_type j, IVector v)
        """
        return _yarp.IVector___setslice__(self, *args)

    def __delslice__(self, i, j):
        r"""__delslice__(IVector self, std::vector< int >::difference_type i, std::vector< int >::difference_type j)"""
        return _yarp.IVector___delslice__(self, i, j)

    def __delitem__(self, *args):
        r"""
        __delitem__(IVector self, std::vector< int >::difference_type i)
        __delitem__(IVector self, PySliceObject * slice)
        """
        return _yarp.IVector___delitem__(self, *args)

    def __getitem__(self, *args):
        r"""
        __getitem__(IVector self, PySliceObject * slice) -> IVector
        __getitem__(IVector self, std::vector< int >::difference_type i) -> std::vector< int >::value_type const &
        """
        return _yarp.IVector___getitem__(self, *args)

    def __setitem__(self, *args):
        r"""
        __setitem__(IVector self, PySliceObject * slice, IVector v)
        __setitem__(IVector self, PySliceObject * slice)
        __setitem__(IVector self, std::vector< int >::difference_type i, std::vector< int >::value_type const & x)
        """
        return _yarp.IVector___setitem__(self, *args)

    def pop(self):
        r"""pop(IVector self) -> std::vector< int >::value_type"""
        return _yarp.IVector_pop(self)

    def append(self, x):
        r"""append(IVector self, std::vector< int >::value_type const & x)"""
        return _yarp.IVector_append(self, x)

    def empty(self):
        r"""empty(IVector self) -> bool"""
        return _yarp.IVector_empty(self)

    def size(self):
        r"""size(IVector self) -> std::vector< int >::size_type"""
        return _yarp.IVector_size(self)

    def swap(self, v):
        r"""swap(IVector self, IVector v)"""
        return _yarp.IVector_swap(self, v)

    def begin(self):
        r"""begin(IVector self) -> std::vector< int >::iterator"""
        return _yarp.IVector_begin(self)

    def end(self):
        r"""end(IVector self) -> std::vector< int >::iterator"""
        return _yarp.IVector_end(self)

    def rbegin(self):
        r"""rbegin(IVector self) -> std::vector< int >::reverse_iterator"""
        return _yarp.IVector_rbegin(self)

    def rend(self):
        r"""rend(IVector self) -> std::vector< int >::reverse_iterator"""
        return _yarp.IVector_rend(self)

    def clear(self):
        r"""clear(IVector self)"""
        return _yarp.IVector_clear(self)

    def get_allocator(self):
        r"""get_allocator(IVector self) -> std::vector< int >::allocator_type"""
        return _yarp.IVector_get_allocator(self)

    def pop_back(self):
        r"""pop_back(IVector self)"""
        return _yarp.IVector_pop_back(self)

    def erase(self, *args):
        r"""
        erase(IVector self, std::vector< int >::iterator pos) -> std::vector< int >::iterator
        erase(IVector self, std::vector< int >::iterator first, std::vector< int >::iterator last) -> std::vector< int >::iterator
        """
        return _yarp.IVector_erase(self, *args)

    def __init__(self, *args):
        r"""
        __init__(IVector self) -> IVector
        __init__(IVector self, IVector other) -> IVector
        __init__(IVector self, std::vector< int >::size_type size) -> IVector
        __init__(IVector self, std::vector< int >::size_type size, std::vector< int >::value_type const & value) -> IVector
        """
        _yarp.IVector_swiginit(self, _yarp.new_IVector(*args))

    def push_back(self, x):
        r"""push_back(IVector self, std::vector< int >::value_type const & x)"""
        return _yarp.IVector_push_back(self, x)

    def front(self):
        r"""front(IVector self) -> std::vector< int >::value_type const &"""
        return _yarp.IVector_front(self)

    def back(self):
        r"""back(IVector self) -> std::vector< int >::value_type const &"""
        return _yarp.IVector_back(self)

    def assign(self, n, x):
        r"""assign(IVector self, std::vector< int >::size_type n, std::vector< int >::value_type const & x)"""
        return _yarp.IVector_assign(self, n, x)

    def resize(self, *args):
        r"""
        resize(IVector self, std::vector< int >::size_type new_size)
        resize(IVector self, std::vector< int >::size_type new_size, std::vector< int >::value_type const & x)
        """
        return _yarp.IVector_resize(self, *args)

    def insert(self, *args):
        r"""
        insert(IVector self, std::vector< int >::iterator pos, std::vector< int >::value_type const & x) -> std::vector< int >::iterator
        insert(IVector self, std::vector< int >::iterator pos, std::vector< int >::size_type n, std::vector< int >::value_type const & x)
        """
        return _yarp.IVector_insert(self, *args)

    def reserve(self, n):
        r"""reserve(IVector self, std::vector< int >::size_type n)"""
        return _yarp.IVector_reserve(self, n)

    def capacity(self):
        r"""capacity(IVector self) -> std::vector< int >::size_type"""
        return _yarp.IVector_capacity(self)
    __swig_destroy__ = _yarp.delete_IVector

# Register IVector in _yarp:
_yarp.IVector_swigregister(IVector)

class ShortVector(object):
    r"""Proxy of C++ std::vector< short > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        r"""iterator(ShortVector self) -> SwigPyIterator"""
        return _yarp.ShortVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        r"""__nonzero__(ShortVector self) -> bool"""
        return _yarp.ShortVector___nonzero__(self)

    def __bool__(self):
        r"""__bool__(ShortVector self) -> bool"""
        return _yarp.ShortVector___bool__(self)

    def __len__(self):
        r"""__len__(ShortVector self) -> std::vector< short >::size_type"""
        return _yarp.ShortVector___len__(self)

    def __getslice__(self, i, j):
        r"""__getslice__(ShortVector self, std::vector< short >::difference_type i, std::vector< short >::difference_type j) -> ShortVector"""
        return _yarp.ShortVector___getslice__(self, i, j)

    def __setslice__(self, *args):
        r"""
        __setslice__(ShortVector self, std::vector< short >::difference_type i, std::vector< short >::difference_type j)
        __setslice__(ShortVector self, std::vector< short >::difference_type i, std::vector< short >::difference_type j, ShortVector v)
        """
        return _yarp.ShortVector___setslice__(self, *args)

    def __delslice__(self, i, j):
        r"""__delslice__(ShortVector self, std::vector< short >::difference_type i, std::vector< short >::difference_type j)"""
        return _yarp.ShortVector___delslice__(self, i, j)

    def __delitem__(self, *args):
        r"""
        __delitem__(ShortVector self, std::vector< short >::difference_type i)
        __delitem__(ShortVector self, PySliceObject * slice)
        """
        return _yarp.ShortVector___delitem__(self, *args)

    def __getitem__(self, *args):
        r"""
        __getitem__(ShortVector self, PySliceObject * slice) -> ShortVector
        __getitem__(ShortVector self, std::vector< short >::difference_type i) -> std::vector< short >::value_type const &
        """
        return _yarp.ShortVector___getitem__(self, *args)

    def __setitem__(self, *args):
        r"""
        __setitem__(ShortVector self, PySliceObject * slice, ShortVector v)
        __setitem__(ShortVector self, PySliceObject * slice)
        __setitem__(ShortVector self, std::vector< short >::difference_type i, std::vector< short >::value_type const & x)
        """
        return _yarp.ShortVector___setitem__(self, *args)

    def pop(self):
        r"""pop(ShortVector self) -> std::vector< short >::value_type"""
        return _yarp.ShortVector_pop(self)

    def append(self, x):
        r"""append(ShortVector self, std::vector< short >::value_type const & x)"""
        return _yarp.ShortVector_append(self, x)

    def empty(self):
        r"""empty(ShortVector self) -> bool"""
        return _yarp.ShortVector_empty(self)

    def size(self):
        r"""size(ShortVector self) -> std::vector< short >::size_type"""
        return _yarp.ShortVector_size(self)

    def swap(self, v):
        r"""swap(ShortVector self, ShortVector v)"""
        return _yarp.ShortVector_swap(self, v)

    def begin(self):
        r"""begin(ShortVector self) -> std::vector< short >::iterator"""
        return _yarp.ShortVector_begin(self)

    def end(self):
        r"""end(ShortVector self) -> std::vector< short >::iterator"""
        return _yarp.ShortVector_end(self)

    def rbegin(self):
        r"""rbegin(ShortVector self) -> std::vector< short >::reverse_iterator"""
        return _yarp.ShortVector_rbegin(self)

    def rend(self):
        r"""rend(ShortVector self) -> std::vector< short >::reverse_iterator"""
        return _yarp.ShortVector_rend(self)

    def clear(self):
        r"""clear(ShortVector self)"""
        return _yarp.ShortVector_clear(self)

    def get_allocator(self):
        r"""get_allocator(ShortVector self) -> std::vector< short >::allocator_type"""
        return _yarp.ShortVector_get_allocator(self)

    def pop_back(self):
        r"""pop_back(ShortVector self)"""
        return _yarp.ShortVector_pop_back(self)

    def erase(self, *args):
        r"""
        erase(ShortVector self, std::vector< short >::iterator pos) -> std::vector< short >::iterator
        erase(ShortVector self, std::vector< short >::iterator first, std::vector< short >::iterator last) -> std::vector< short >::iterator
        """
        return _yarp.ShortVector_erase(self, *args)

    def __init__(self, *args):
        r"""
        __init__(ShortVector self) -> ShortVector
        __init__(ShortVector self, ShortVector other) -> ShortVector
        __init__(ShortVector self, std::vector< short >::size_type size) -> ShortVector
        __init__(ShortVector self, std::vector< short >::size_type size, std::vector< short >::value_type const & value) -> ShortVector
        """
        _yarp.ShortVector_swiginit(self, _yarp.new_ShortVector(*args))

    def push_back(self, x):
        r"""push_back(ShortVector self, std::vector< short >::value_type const & x)"""
        return _yarp.ShortVector_push_back(self, x)

    def front(self):
        r"""front(ShortVector self) -> std::vector< short >::value_type const &"""
        return _yarp.ShortVector_front(self)

    def back(self):
        r"""back(ShortVector self) -> std::vector< short >::value_type const &"""
        return _yarp.ShortVector_back(self)

    def assign(self, n, x):
        r"""assign(ShortVector self, std::vector< short >::size_type n, std::vector< short >::value_type const & x)"""
        return _yarp.ShortVector_assign(self, n, x)

    def resize(self, *args):
        r"""
        resize(ShortVector self, std::vector< short >::size_type new_size)
        resize(ShortVector self, std::vector< short >::size_type new_size, std::vector< short >::value_type const & x)
        """
        return _yarp.ShortVector_resize(self, *args)

    def insert(self, *args):
        r"""
        insert(ShortVector self, std::vector< short >::iterator pos, std::vector< short >::value_type const & x) -> std::vector< short >::iterator
        insert(ShortVector self, std::vector< short >::iterator pos, std::vector< short >::size_type n, std::vector< short >::value_type const & x)
        """
        return _yarp.ShortVector_insert(self, *args)

    def reserve(self, n):
        r"""reserve(ShortVector self, std::vector< short >::size_type n)"""
        return _yarp.ShortVector_reserve(self, n)

    def capacity(self):
        r"""capacity(ShortVector self) -> std::vector< short >::size_type"""
        return _yarp.ShortVector_capacity(self)
    __swig_destroy__ = _yarp.delete_ShortVector

# Register ShortVector in _yarp:
_yarp.ShortVector_swigregister(ShortVector)

class PidVector(object):
    r"""Proxy of C++ std::vector< yarp::dev::Pid > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        r"""iterator(PidVector self) -> SwigPyIterator"""
        return _yarp.PidVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        r"""__nonzero__(PidVector self) -> bool"""
        return _yarp.PidVector___nonzero__(self)

    def __bool__(self):
        r"""__bool__(PidVector self) -> bool"""
        return _yarp.PidVector___bool__(self)

    def __len__(self):
        r"""__len__(PidVector self) -> std::vector< yarp::dev::Pid >::size_type"""
        return _yarp.PidVector___len__(self)

    def __getslice__(self, i, j):
        r"""__getslice__(PidVector self, std::vector< yarp::dev::Pid >::difference_type i, std::vector< yarp::dev::Pid >::difference_type j) -> PidVector"""
        return _yarp.PidVector___getslice__(self, i, j)

    def __setslice__(self, *args):
        r"""
        __setslice__(PidVector self, std::vector< yarp::dev::Pid >::difference_type i, std::vector< yarp::dev::Pid >::difference_type j)
        __setslice__(PidVector self, std::vector< yarp::dev::Pid >::difference_type i, std::vector< yarp::dev::Pid >::difference_type j, PidVector v)
        """
        return _yarp.PidVector___setslice__(self, *args)

    def __delslice__(self, i, j):
        r"""__delslice__(PidVector self, std::vector< yarp::dev::Pid >::difference_type i, std::vector< yarp::dev::Pid >::difference_type j)"""
        return _yarp.PidVector___delslice__(self, i, j)

    def __delitem__(self, *args):
        r"""
        __delitem__(PidVector self, std::vector< yarp::dev::Pid >::difference_type i)
        __delitem__(PidVector self, PySliceObject * slice)
        """
        return _yarp.PidVector___delitem__(self, *args)

    def __getitem__(self, *args):
        r"""
        __getitem__(PidVector self, PySliceObject * slice) -> PidVector
        __getitem__(PidVector self, std::vector< yarp::dev::Pid >::difference_type i) -> Pid
        """
        return _yarp.PidVector___getitem__(self, *args)

    def __setitem__(self, *args):
        r"""
        __setitem__(PidVector self, PySliceObject * slice, PidVector v)
        __setitem__(PidVector self, PySliceObject * slice)
        __setitem__(PidVector self, std::vector< yarp::dev::Pid >::difference_type i, Pid x)
        """
        return _yarp.PidVector___setitem__(self, *args)

    def pop(self):
        r"""pop(PidVector self) -> Pid"""
        return _yarp.PidVector_pop(self)

    def append(self, x):
        r"""append(PidVector self, Pid x)"""
        return _yarp.PidVector_append(self, x)

    def empty(self):
        r"""empty(PidVector self) -> bool"""
        return _yarp.PidVector_empty(self)

    def size(self):
        r"""size(PidVector self) -> std::vector< yarp::dev::Pid >::size_type"""
        return _yarp.PidVector_size(self)

    def swap(self, v):
        r"""swap(PidVector self, PidVector v)"""
        return _yarp.PidVector_swap(self, v)

    def begin(self):
        r"""begin(PidVector self) -> std::vector< yarp::dev::Pid >::iterator"""
        return _yarp.PidVector_begin(self)

    def end(self):
        r"""end(PidVector self) -> std::vector< yarp::dev::Pid >::iterator"""
        return _yarp.PidVector_end(self)

    def rbegin(self):
        r"""rbegin(PidVector self) -> std::vector< yarp::dev::Pid >::reverse_iterator"""
        return _yarp.PidVector_rbegin(self)

    def rend(self):
        r"""rend(PidVector self) -> std::vector< yarp::dev::Pid >::reverse_iterator"""
        return _yarp.PidVector_rend(self)

    def clear(self):
        r"""clear(PidVector self)"""
        return _yarp.PidVector_clear(self)

    def get_allocator(self):
        r"""get_allocator(PidVector self) -> std::vector< yarp::dev::Pid >::allocator_type"""
        return _yarp.PidVector_get_allocator(self)

    def pop_back(self):
        r"""pop_back(PidVector self)"""
        return _yarp.PidVector_pop_back(self)

    def erase(self, *args):
        r"""
        erase(PidVector self, std::vector< yarp::dev::Pid >::iterator pos) -> std::vector< yarp::dev::Pid >::iterator
        erase(PidVector self, std::vector< yarp::dev::Pid >::iterator first, std::vector< yarp::dev::Pid >::iterator last) -> std::vector< yarp::dev::Pid >::iterator
        """
        return _yarp.PidVector_erase(self, *args)

    def __init__(self, *args):
        r"""
        __init__(PidVector self) -> PidVector
        __init__(PidVector self, PidVector other) -> PidVector
        __init__(PidVector self, std::vector< yarp::dev::Pid >::size_type size) -> PidVector
        __init__(PidVector self, std::vector< yarp::dev::Pid >::size_type size, Pid value) -> PidVector
        """
        _yarp.PidVector_swiginit(self, _yarp.new_PidVector(*args))

    def push_back(self, x):
        r"""push_back(PidVector self, Pid x)"""
        return _yarp.PidVector_push_back(self, x)

    def front(self):
        r"""front(PidVector self) -> Pid"""
        return _yarp.PidVector_front(self)

    def back(self):
        r"""back(PidVector self) -> Pid"""
        return _yarp.PidVector_back(self)

    def assign(self, n, x):
        r"""assign(PidVector self, std::vector< yarp::dev::Pid >::size_type n, Pid x)"""
        return _yarp.PidVector_assign(self, n, x)

    def resize(self, *args):
        r"""
        resize(PidVector self, std::vector< yarp::dev::Pid >::size_type new_size)
        resize(PidVector self, std::vector< yarp::dev::Pid >::size_type new_size, Pid x)
        """
        return _yarp.PidVector_resize(self, *args)

    def insert(self, *args):
        r"""
        insert(PidVector self, std::vector< yarp::dev::Pid >::iterator pos, Pid x) -> std::vector< yarp::dev::Pid >::iterator
        insert(PidVector self, std::vector< yarp::dev::Pid >::iterator pos, std::vector< yarp::dev::Pid >::size_type n, Pid x)
        """
        return _yarp.PidVector_insert(self, *args)

    def reserve(self, n):
        r"""reserve(PidVector self, std::vector< yarp::dev::Pid >::size_type n)"""
        return _yarp.PidVector_reserve(self, n)

    def capacity(self):
        r"""capacity(PidVector self) -> std::vector< yarp::dev::Pid >::size_type"""
        return _yarp.PidVector_capacity(self)
    __swig_destroy__ = _yarp.delete_PidVector

# Register PidVector in _yarp:
_yarp.PidVector_swigregister(PidVector)

class ImageRgb(Image):
    r"""Proxy of C++ yarp::sig::ImageOf< yarp::sig::PixelRgb > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        r"""__init__(ImageRgb self) -> ImageRgb"""
        _yarp.ImageRgb_swiginit(self, _yarp.new_ImageRgb())

    def getPixelSize(self):
        r"""getPixelSize(ImageRgb self) -> size_t"""
        return _yarp.ImageRgb_getPixelSize(self)

    def getPixelCode(self):
        r"""getPixelCode(ImageRgb self) -> int"""
        return _yarp.ImageRgb_getPixelCode(self)

    def pixel(self, *args):
        r"""
        pixel(ImageRgb self, size_t x, size_t y) -> PixelRgb
        pixel(ImageRgb self, size_t x, size_t y) -> PixelRgb
        """
        return _yarp.ImageRgb_pixel(self, *args)

    def access(self, *args):
        r"""
        access(ImageRgb self, size_t x, size_t y) -> PixelRgb
        access(ImageRgb self, size_t x, size_t y) -> PixelRgb
        """
        return _yarp.ImageRgb_access(self, *args)

    def safePixel(self, *args):
        r"""
        safePixel(ImageRgb self, size_t x, size_t y) -> PixelRgb
        safePixel(ImageRgb self, size_t x, size_t y) -> PixelRgb
        """
        return _yarp.ImageRgb_safePixel(self, *args)
    __swig_destroy__ = _yarp.delete_ImageRgb

# Register ImageRgb in _yarp:
_yarp.ImageRgb_swigregister(ImageRgb)

class TypedReaderImageRgb(object):
    r"""Proxy of C++ yarp::os::TypedReader< yarp::sig::ImageOf< yarp::sig::PixelRgb > > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def setStrict(self, strict=True):
        r"""setStrict(TypedReaderImageRgb self, bool strict=True)"""
        return _yarp.TypedReaderImageRgb_setStrict(self, strict)

    def read(self, shouldWait=True):
        r"""read(TypedReaderImageRgb self, bool shouldWait=True) -> ImageRgb"""
        return _yarp.TypedReaderImageRgb_read(self, shouldWait)

    def interrupt(self):
        r"""interrupt(TypedReaderImageRgb self)"""
        return _yarp.TypedReaderImageRgb_interrupt(self)

    def lastRead(self):
        r"""lastRead(TypedReaderImageRgb self) -> ImageRgb"""
        return _yarp.TypedReaderImageRgb_lastRead(self)

    def isClosed(self):
        r"""isClosed(TypedReaderImageRgb self) -> bool"""
        return _yarp.TypedReaderImageRgb_isClosed(self)

    def useCallback(self, callback):
        r"""useCallback(TypedReaderImageRgb self, TypedReaderCallbackImageRgb callback)"""
        return _yarp.TypedReaderImageRgb_useCallback(self, callback)

    def disableCallback(self):
        r"""disableCallback(TypedReaderImageRgb self)"""
        return _yarp.TypedReaderImageRgb_disableCallback(self)

    def getPendingReads(self):
        r"""getPendingReads(TypedReaderImageRgb self) -> int"""
        return _yarp.TypedReaderImageRgb_getPendingReads(self)
    __swig_destroy__ = _yarp.delete_TypedReaderImageRgb

    def getName(self):
        r"""getName(TypedReaderImageRgb self) -> std::string"""
        return _yarp.TypedReaderImageRgb_getName(self)

    def setReplier(self, reader):
        r"""setReplier(TypedReaderImageRgb self, PortReader reader)"""
        return _yarp.TypedReaderImageRgb_setReplier(self, reader)

    def acquire(self):
        r"""acquire(TypedReaderImageRgb self) -> void *"""
        return _yarp.TypedReaderImageRgb_acquire(self)

    def release(self, handle):
        r"""release(TypedReaderImageRgb self, void * handle)"""
        return _yarp.TypedReaderImageRgb_release(self, handle)

    def setTargetPeriod(self, period):
        r"""setTargetPeriod(TypedReaderImageRgb self, double period)"""
        return _yarp.TypedReaderImageRgb_setTargetPeriod(self, period)

# Register TypedReaderImageRgb in _yarp:
_yarp.TypedReaderImageRgb_swigregister(TypedReaderImageRgb)

class TypedReaderCallbackImageRgb(object):
    r"""Proxy of C++ yarp::os::TypedReaderCallback< yarp::sig::ImageOf< yarp::sig::PixelRgb > > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _yarp.delete_TypedReaderCallbackImageRgb

    def onRead(self, *args):
        r"""
        onRead(TypedReaderCallbackImageRgb self, ImageRgb datum)
        onRead(TypedReaderCallbackImageRgb self, ImageRgb datum, TypedReaderImageRgb reader)
        """
        return _yarp.TypedReaderCallbackImageRgb_onRead(self, *args)

    def __init__(self):
        r"""__init__(TypedReaderCallbackImageRgb self) -> TypedReaderCallbackImageRgb"""
        _yarp.TypedReaderCallbackImageRgb_swiginit(self, _yarp.new_TypedReaderCallbackImageRgb())

# Register TypedReaderCallbackImageRgb in _yarp:
_yarp.TypedReaderCallbackImageRgb_swigregister(TypedReaderCallbackImageRgb)

class BufferedPortImageRgb(Contactable, TypedReaderImageRgb, TypedReaderCallbackImageRgb):
    r"""Proxy of C++ yarp::os::BufferedPort< yarp::sig::ImageOf< yarp::sig::PixelRgb > > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        __init__(BufferedPortImageRgb self) -> BufferedPortImageRgb
        __init__(BufferedPortImageRgb self, Port port) -> BufferedPortImageRgb
        """
        _yarp.BufferedPortImageRgb_swiginit(self, _yarp.new_BufferedPortImageRgb(*args))
    __swig_destroy__ = _yarp.delete_BufferedPortImageRgb

    def addOutput(self, *args):
        r"""
        addOutput(BufferedPortImageRgb self, std::string const & name) -> bool
        addOutput(BufferedPortImageRgb self, std::string const & name, std::string const & carrier) -> bool
        addOutput(BufferedPortImageRgb self, Contact contact) -> bool
        """
        return _yarp.BufferedPortImageRgb_addOutput(self, *args)

    def close(self):
        r"""close(BufferedPortImageRgb self)"""
        return _yarp.BufferedPortImageRgb_close(self)

    def interrupt(self):
        r"""interrupt(BufferedPortImageRgb self)"""
        return _yarp.BufferedPortImageRgb_interrupt(self)

    def resume(self):
        r"""resume(BufferedPortImageRgb self)"""
        return _yarp.BufferedPortImageRgb_resume(self)

    def getPendingReads(self):
        r"""getPendingReads(BufferedPortImageRgb self) -> int"""
        return _yarp.BufferedPortImageRgb_getPendingReads(self)

    def where(self):
        r"""where(BufferedPortImageRgb self) -> Contact"""
        return _yarp.BufferedPortImageRgb_where(self)

    def getName(self):
        r"""getName(BufferedPortImageRgb self) -> std::string"""
        return _yarp.BufferedPortImageRgb_getName(self)

    def prepare(self):
        r"""prepare(BufferedPortImageRgb self) -> ImageRgb"""
        return _yarp.BufferedPortImageRgb_prepare(self)

    def unprepare(self):
        r"""unprepare(BufferedPortImageRgb self) -> bool"""
        return _yarp.BufferedPortImageRgb_unprepare(self)

    def write(self, forceStrict=False):
        r"""write(BufferedPortImageRgb self, bool forceStrict=False)"""
        return _yarp.BufferedPortImageRgb_write(self, forceStrict)

    def writeStrict(self):
        r"""writeStrict(BufferedPortImageRgb self)"""
        return _yarp.BufferedPortImageRgb_writeStrict(self)

    def waitForWrite(self):
        r"""waitForWrite(BufferedPortImageRgb self)"""
        return _yarp.BufferedPortImageRgb_waitForWrite(self)

    def setStrict(self, strict=True):
        r"""setStrict(BufferedPortImageRgb self, bool strict=True)"""
        return _yarp.BufferedPortImageRgb_setStrict(self, strict)

    def read(self, shouldWait=True):
        r"""read(BufferedPortImageRgb self, bool shouldWait=True) -> ImageRgb"""
        return _yarp.BufferedPortImageRgb_read(self, shouldWait)

    def lastRead(self):
        r"""lastRead(BufferedPortImageRgb self) -> ImageRgb"""
        return _yarp.BufferedPortImageRgb_lastRead(self)

    def isClosed(self):
        r"""isClosed(BufferedPortImageRgb self) -> bool"""
        return _yarp.BufferedPortImageRgb_isClosed(self)

    def setReplier(self, reader):
        r"""setReplier(BufferedPortImageRgb self, PortReader reader)"""
        return _yarp.BufferedPortImageRgb_setReplier(self, reader)

    def setReader(self, reader):
        r"""setReader(BufferedPortImageRgb self, PortReader reader)"""
        return _yarp.BufferedPortImageRgb_setReader(self, reader)

    def setAdminReader(self, reader):
        r"""setAdminReader(BufferedPortImageRgb self, PortReader reader)"""
        return _yarp.BufferedPortImageRgb_setAdminReader(self, reader)

    def onRead(self, *args):
        r"""
        onRead(BufferedPortImageRgb self, ImageRgb datum, TypedReaderImageRgb reader)
        onRead(BufferedPortImageRgb self, ImageRgb datum)
        """
        return _yarp.BufferedPortImageRgb_onRead(self, *args)

    def useCallback(self, *args):
        r"""
        useCallback(BufferedPortImageRgb self, TypedReaderCallbackImageRgb callback)
        useCallback(BufferedPortImageRgb self)
        """
        return _yarp.BufferedPortImageRgb_useCallback(self, *args)

    def disableCallback(self):
        r"""disableCallback(BufferedPortImageRgb self)"""
        return _yarp.BufferedPortImageRgb_disableCallback(self)

    def setEnvelope(self, envelope):
        r"""setEnvelope(BufferedPortImageRgb self, PortWriter envelope) -> bool"""
        return _yarp.BufferedPortImageRgb_setEnvelope(self, envelope)

    def getEnvelope(self, envelope):
        r"""getEnvelope(BufferedPortImageRgb self, PortReader envelope) -> bool"""
        return _yarp.BufferedPortImageRgb_getEnvelope(self, envelope)

    def getInputCount(self):
        r"""getInputCount(BufferedPortImageRgb self) -> int"""
        return _yarp.BufferedPortImageRgb_getInputCount(self)

    def getOutputCount(self):
        r"""getOutputCount(BufferedPortImageRgb self) -> int"""
        return _yarp.BufferedPortImageRgb_getOutputCount(self)

    def isWriting(self):
        r"""isWriting(BufferedPortImageRgb self) -> bool"""
        return _yarp.BufferedPortImageRgb_isWriting(self)

    def getReport(self, reporter):
        r"""getReport(BufferedPortImageRgb self, PortReport reporter)"""
        return _yarp.BufferedPortImageRgb_getReport(self, reporter)

    def setReporter(self, reporter):
        r"""setReporter(BufferedPortImageRgb self, PortReport reporter)"""
        return _yarp.BufferedPortImageRgb_setReporter(self, reporter)

    def resetReporter(self):
        r"""resetReporter(BufferedPortImageRgb self)"""
        return _yarp.BufferedPortImageRgb_resetReporter(self)

    def acquire(self):
        r"""acquire(BufferedPortImageRgb self) -> void *"""
        return _yarp.BufferedPortImageRgb_acquire(self)

    def release(self, handle):
        r"""release(BufferedPortImageRgb self, void * handle)"""
        return _yarp.BufferedPortImageRgb_release(self, handle)

    def setTargetPeriod(self, period):
        r"""setTargetPeriod(BufferedPortImageRgb self, double period)"""
        return _yarp.BufferedPortImageRgb_setTargetPeriod(self, period)

    def getType(self):
        r"""getType(BufferedPortImageRgb self) -> yarp::os::Type"""
        return _yarp.BufferedPortImageRgb_getType(self)

    def promiseType(self, typ):
        r"""promiseType(BufferedPortImageRgb self, yarp::os::Type const & typ)"""
        return _yarp.BufferedPortImageRgb_promiseType(self, typ)

    def setInputMode(self, expectInput):
        r"""setInputMode(BufferedPortImageRgb self, bool expectInput)"""
        return _yarp.BufferedPortImageRgb_setInputMode(self, expectInput)

    def setOutputMode(self, expectOutput):
        r"""setOutputMode(BufferedPortImageRgb self, bool expectOutput)"""
        return _yarp.BufferedPortImageRgb_setOutputMode(self, expectOutput)

    def setRpcMode(self, expectRpc):
        r"""setRpcMode(BufferedPortImageRgb self, bool expectRpc)"""
        return _yarp.BufferedPortImageRgb_setRpcMode(self, expectRpc)

    def acquireProperties(self, readOnly):
        r"""acquireProperties(BufferedPortImageRgb self, bool readOnly) -> Property"""
        return _yarp.BufferedPortImageRgb_acquireProperties(self, readOnly)

    def releaseProperties(self, prop):
        r"""releaseProperties(BufferedPortImageRgb self, Property prop)"""
        return _yarp.BufferedPortImageRgb_releaseProperties(self, prop)

    def includeNodeInName(self, flag):
        r"""includeNodeInName(BufferedPortImageRgb self, bool flag)"""
        return _yarp.BufferedPortImageRgb_includeNodeInName(self, flag)

    def setCallbackLock(self, *args):
        r"""
        setCallbackLock(BufferedPortImageRgb self, yarp::os::Mutex * mutex) -> bool
        setCallbackLock(BufferedPortImageRgb self, std::mutex * mutex) -> bool
        """
        return _yarp.BufferedPortImageRgb_setCallbackLock(self, *args)

    def removeCallbackLock(self):
        r"""removeCallbackLock(BufferedPortImageRgb self) -> bool"""
        return _yarp.BufferedPortImageRgb_removeCallbackLock(self)

    def lockCallback(self):
        r"""lockCallback(BufferedPortImageRgb self) -> bool"""
        return _yarp.BufferedPortImageRgb_lockCallback(self)

    def tryLockCallback(self):
        r"""tryLockCallback(BufferedPortImageRgb self) -> bool"""
        return _yarp.BufferedPortImageRgb_tryLockCallback(self)

    def unlockCallback(self):
        r"""unlockCallback(BufferedPortImageRgb self)"""
        return _yarp.BufferedPortImageRgb_unlockCallback(self)

# Register BufferedPortImageRgb in _yarp:
_yarp.BufferedPortImageRgb_swigregister(BufferedPortImageRgb)

class ImageRgba(Image):
    r"""Proxy of C++ yarp::sig::ImageOf< yarp::sig::PixelRgba > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        r"""__init__(ImageRgba self) -> ImageRgba"""
        _yarp.ImageRgba_swiginit(self, _yarp.new_ImageRgba())

    def getPixelSize(self):
        r"""getPixelSize(ImageRgba self) -> size_t"""
        return _yarp.ImageRgba_getPixelSize(self)

    def getPixelCode(self):
        r"""getPixelCode(ImageRgba self) -> int"""
        return _yarp.ImageRgba_getPixelCode(self)

    def pixel(self, *args):
        r"""
        pixel(ImageRgba self, size_t x, size_t y) -> PixelRgba
        pixel(ImageRgba self, size_t x, size_t y) -> PixelRgba
        """
        return _yarp.ImageRgba_pixel(self, *args)

    def access(self, *args):
        r"""
        access(ImageRgba self, size_t x, size_t y) -> PixelRgba
        access(ImageRgba self, size_t x, size_t y) -> PixelRgba
        """
        return _yarp.ImageRgba_access(self, *args)

    def safePixel(self, *args):
        r"""
        safePixel(ImageRgba self, size_t x, size_t y) -> PixelRgba
        safePixel(ImageRgba self, size_t x, size_t y) -> PixelRgba
        """
        return _yarp.ImageRgba_safePixel(self, *args)
    __swig_destroy__ = _yarp.delete_ImageRgba

# Register ImageRgba in _yarp:
_yarp.ImageRgba_swigregister(ImageRgba)

class TypedReaderImageRgba(object):
    r"""Proxy of C++ yarp::os::TypedReader< yarp::sig::ImageOf< yarp::sig::PixelRgba > > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def setStrict(self, strict=True):
        r"""setStrict(TypedReaderImageRgba self, bool strict=True)"""
        return _yarp.TypedReaderImageRgba_setStrict(self, strict)

    def read(self, shouldWait=True):
        r"""read(TypedReaderImageRgba self, bool shouldWait=True) -> ImageRgba"""
        return _yarp.TypedReaderImageRgba_read(self, shouldWait)

    def interrupt(self):
        r"""interrupt(TypedReaderImageRgba self)"""
        return _yarp.TypedReaderImageRgba_interrupt(self)

    def lastRead(self):
        r"""lastRead(TypedReaderImageRgba self) -> ImageRgba"""
        return _yarp.TypedReaderImageRgba_lastRead(self)

    def isClosed(self):
        r"""isClosed(TypedReaderImageRgba self) -> bool"""
        return _yarp.TypedReaderImageRgba_isClosed(self)

    def useCallback(self, callback):
        r"""useCallback(TypedReaderImageRgba self, TypedReaderCallbackImageRgba callback)"""
        return _yarp.TypedReaderImageRgba_useCallback(self, callback)

    def disableCallback(self):
        r"""disableCallback(TypedReaderImageRgba self)"""
        return _yarp.TypedReaderImageRgba_disableCallback(self)

    def getPendingReads(self):
        r"""getPendingReads(TypedReaderImageRgba self) -> int"""
        return _yarp.TypedReaderImageRgba_getPendingReads(self)
    __swig_destroy__ = _yarp.delete_TypedReaderImageRgba

    def getName(self):
        r"""getName(TypedReaderImageRgba self) -> std::string"""
        return _yarp.TypedReaderImageRgba_getName(self)

    def setReplier(self, reader):
        r"""setReplier(TypedReaderImageRgba self, PortReader reader)"""
        return _yarp.TypedReaderImageRgba_setReplier(self, reader)

    def acquire(self):
        r"""acquire(TypedReaderImageRgba self) -> void *"""
        return _yarp.TypedReaderImageRgba_acquire(self)

    def release(self, handle):
        r"""release(TypedReaderImageRgba self, void * handle)"""
        return _yarp.TypedReaderImageRgba_release(self, handle)

    def setTargetPeriod(self, period):
        r"""setTargetPeriod(TypedReaderImageRgba self, double period)"""
        return _yarp.TypedReaderImageRgba_setTargetPeriod(self, period)

# Register TypedReaderImageRgba in _yarp:
_yarp.TypedReaderImageRgba_swigregister(TypedReaderImageRgba)

class TypedReaderCallbackImageRgba(object):
    r"""Proxy of C++ yarp::os::TypedReaderCallback< yarp::sig::ImageOf< yarp::sig::PixelRgba > > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _yarp.delete_TypedReaderCallbackImageRgba

    def onRead(self, *args):
        r"""
        onRead(TypedReaderCallbackImageRgba self, ImageRgba datum)
        onRead(TypedReaderCallbackImageRgba self, ImageRgba datum, TypedReaderImageRgba reader)
        """
        return _yarp.TypedReaderCallbackImageRgba_onRead(self, *args)

    def __init__(self):
        r"""__init__(TypedReaderCallbackImageRgba self) -> TypedReaderCallbackImageRgba"""
        _yarp.TypedReaderCallbackImageRgba_swiginit(self, _yarp.new_TypedReaderCallbackImageRgba())

# Register TypedReaderCallbackImageRgba in _yarp:
_yarp.TypedReaderCallbackImageRgba_swigregister(TypedReaderCallbackImageRgba)

class BufferedPortImageRgba(Contactable, TypedReaderImageRgba, TypedReaderCallbackImageRgba):
    r"""Proxy of C++ yarp::os::BufferedPort< yarp::sig::ImageOf< yarp::sig::PixelRgba > > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        __init__(BufferedPortImageRgba self) -> BufferedPortImageRgba
        __init__(BufferedPortImageRgba self, Port port) -> BufferedPortImageRgba
        """
        _yarp.BufferedPortImageRgba_swiginit(self, _yarp.new_BufferedPortImageRgba(*args))
    __swig_destroy__ = _yarp.delete_BufferedPortImageRgba

    def addOutput(self, *args):
        r"""
        addOutput(BufferedPortImageRgba self, std::string const & name) -> bool
        addOutput(BufferedPortImageRgba self, std::string const & name, std::string const & carrier) -> bool
        addOutput(BufferedPortImageRgba self, Contact contact) -> bool
        """
        return _yarp.BufferedPortImageRgba_addOutput(self, *args)

    def close(self):
        r"""close(BufferedPortImageRgba self)"""
        return _yarp.BufferedPortImageRgba_close(self)

    def interrupt(self):
        r"""interrupt(BufferedPortImageRgba self)"""
        return _yarp.BufferedPortImageRgba_interrupt(self)

    def resume(self):
        r"""resume(BufferedPortImageRgba self)"""
        return _yarp.BufferedPortImageRgba_resume(self)

    def getPendingReads(self):
        r"""getPendingReads(BufferedPortImageRgba self) -> int"""
        return _yarp.BufferedPortImageRgba_getPendingReads(self)

    def where(self):
        r"""where(BufferedPortImageRgba self) -> Contact"""
        return _yarp.BufferedPortImageRgba_where(self)

    def getName(self):
        r"""getName(BufferedPortImageRgba self) -> std::string"""
        return _yarp.BufferedPortImageRgba_getName(self)

    def prepare(self):
        r"""prepare(BufferedPortImageRgba self) -> ImageRgba"""
        return _yarp.BufferedPortImageRgba_prepare(self)

    def unprepare(self):
        r"""unprepare(BufferedPortImageRgba self) -> bool"""
        return _yarp.BufferedPortImageRgba_unprepare(self)

    def write(self, forceStrict=False):
        r"""write(BufferedPortImageRgba self, bool forceStrict=False)"""
        return _yarp.BufferedPortImageRgba_write(self, forceStrict)

    def writeStrict(self):
        r"""writeStrict(BufferedPortImageRgba self)"""
        return _yarp.BufferedPortImageRgba_writeStrict(self)

    def waitForWrite(self):
        r"""waitForWrite(BufferedPortImageRgba self)"""
        return _yarp.BufferedPortImageRgba_waitForWrite(self)

    def setStrict(self, strict=True):
        r"""setStrict(BufferedPortImageRgba self, bool strict=True)"""
        return _yarp.BufferedPortImageRgba_setStrict(self, strict)

    def read(self, shouldWait=True):
        r"""read(BufferedPortImageRgba self, bool shouldWait=True) -> ImageRgba"""
        return _yarp.BufferedPortImageRgba_read(self, shouldWait)

    def lastRead(self):
        r"""lastRead(BufferedPortImageRgba self) -> ImageRgba"""
        return _yarp.BufferedPortImageRgba_lastRead(self)

    def isClosed(self):
        r"""isClosed(BufferedPortImageRgba self) -> bool"""
        return _yarp.BufferedPortImageRgba_isClosed(self)

    def setReplier(self, reader):
        r"""setReplier(BufferedPortImageRgba self, PortReader reader)"""
        return _yarp.BufferedPortImageRgba_setReplier(self, reader)

    def setReader(self, reader):
        r"""setReader(BufferedPortImageRgba self, PortReader reader)"""
        return _yarp.BufferedPortImageRgba_setReader(self, reader)

    def setAdminReader(self, reader):
        r"""setAdminReader(BufferedPortImageRgba self, PortReader reader)"""
        return _yarp.BufferedPortImageRgba_setAdminReader(self, reader)

    def onRead(self, *args):
        r"""
        onRead(BufferedPortImageRgba self, ImageRgba datum, TypedReaderImageRgba reader)
        onRead(BufferedPortImageRgba self, ImageRgba datum)
        """
        return _yarp.BufferedPortImageRgba_onRead(self, *args)

    def useCallback(self, *args):
        r"""
        useCallback(BufferedPortImageRgba self, TypedReaderCallbackImageRgba callback)
        useCallback(BufferedPortImageRgba self)
        """
        return _yarp.BufferedPortImageRgba_useCallback(self, *args)

    def disableCallback(self):
        r"""disableCallback(BufferedPortImageRgba self)"""
        return _yarp.BufferedPortImageRgba_disableCallback(self)

    def setEnvelope(self, envelope):
        r"""setEnvelope(BufferedPortImageRgba self, PortWriter envelope) -> bool"""
        return _yarp.BufferedPortImageRgba_setEnvelope(self, envelope)

    def getEnvelope(self, envelope):
        r"""getEnvelope(BufferedPortImageRgba self, PortReader envelope) -> bool"""
        return _yarp.BufferedPortImageRgba_getEnvelope(self, envelope)

    def getInputCount(self):
        r"""getInputCount(BufferedPortImageRgba self) -> int"""
        return _yarp.BufferedPortImageRgba_getInputCount(self)

    def getOutputCount(self):
        r"""getOutputCount(BufferedPortImageRgba self) -> int"""
        return _yarp.BufferedPortImageRgba_getOutputCount(self)

    def isWriting(self):
        r"""isWriting(BufferedPortImageRgba self) -> bool"""
        return _yarp.BufferedPortImageRgba_isWriting(self)

    def getReport(self, reporter):
        r"""getReport(BufferedPortImageRgba self, PortReport reporter)"""
        return _yarp.BufferedPortImageRgba_getReport(self, reporter)

    def setReporter(self, reporter):
        r"""setReporter(BufferedPortImageRgba self, PortReport reporter)"""
        return _yarp.BufferedPortImageRgba_setReporter(self, reporter)

    def resetReporter(self):
        r"""resetReporter(BufferedPortImageRgba self)"""
        return _yarp.BufferedPortImageRgba_resetReporter(self)

    def acquire(self):
        r"""acquire(BufferedPortImageRgba self) -> void *"""
        return _yarp.BufferedPortImageRgba_acquire(self)

    def release(self, handle):
        r"""release(BufferedPortImageRgba self, void * handle)"""
        return _yarp.BufferedPortImageRgba_release(self, handle)

    def setTargetPeriod(self, period):
        r"""setTargetPeriod(BufferedPortImageRgba self, double period)"""
        return _yarp.BufferedPortImageRgba_setTargetPeriod(self, period)

    def getType(self):
        r"""getType(BufferedPortImageRgba self) -> yarp::os::Type"""
        return _yarp.BufferedPortImageRgba_getType(self)

    def promiseType(self, typ):
        r"""promiseType(BufferedPortImageRgba self, yarp::os::Type const & typ)"""
        return _yarp.BufferedPortImageRgba_promiseType(self, typ)

    def setInputMode(self, expectInput):
        r"""setInputMode(BufferedPortImageRgba self, bool expectInput)"""
        return _yarp.BufferedPortImageRgba_setInputMode(self, expectInput)

    def setOutputMode(self, expectOutput):
        r"""setOutputMode(BufferedPortImageRgba self, bool expectOutput)"""
        return _yarp.BufferedPortImageRgba_setOutputMode(self, expectOutput)

    def setRpcMode(self, expectRpc):
        r"""setRpcMode(BufferedPortImageRgba self, bool expectRpc)"""
        return _yarp.BufferedPortImageRgba_setRpcMode(self, expectRpc)

    def acquireProperties(self, readOnly):
        r"""acquireProperties(BufferedPortImageRgba self, bool readOnly) -> Property"""
        return _yarp.BufferedPortImageRgba_acquireProperties(self, readOnly)

    def releaseProperties(self, prop):
        r"""releaseProperties(BufferedPortImageRgba self, Property prop)"""
        return _yarp.BufferedPortImageRgba_releaseProperties(self, prop)

    def includeNodeInName(self, flag):
        r"""includeNodeInName(BufferedPortImageRgba self, bool flag)"""
        return _yarp.BufferedPortImageRgba_includeNodeInName(self, flag)

    def setCallbackLock(self, *args):
        r"""
        setCallbackLock(BufferedPortImageRgba self, yarp::os::Mutex * mutex) -> bool
        setCallbackLock(BufferedPortImageRgba self, std::mutex * mutex) -> bool
        """
        return _yarp.BufferedPortImageRgba_setCallbackLock(self, *args)

    def removeCallbackLock(self):
        r"""removeCallbackLock(BufferedPortImageRgba self) -> bool"""
        return _yarp.BufferedPortImageRgba_removeCallbackLock(self)

    def lockCallback(self):
        r"""lockCallback(BufferedPortImageRgba self) -> bool"""
        return _yarp.BufferedPortImageRgba_lockCallback(self)

    def tryLockCallback(self):
        r"""tryLockCallback(BufferedPortImageRgba self) -> bool"""
        return _yarp.BufferedPortImageRgba_tryLockCallback(self)

    def unlockCallback(self):
        r"""unlockCallback(BufferedPortImageRgba self)"""
        return _yarp.BufferedPortImageRgba_unlockCallback(self)

# Register BufferedPortImageRgba in _yarp:
_yarp.BufferedPortImageRgba_swigregister(BufferedPortImageRgba)

class ImageMono(Image):
    r"""Proxy of C++ yarp::sig::ImageOf< yarp::sig::PixelMono > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        r"""__init__(ImageMono self) -> ImageMono"""
        _yarp.ImageMono_swiginit(self, _yarp.new_ImageMono())

    def getPixelSize(self):
        r"""getPixelSize(ImageMono self) -> size_t"""
        return _yarp.ImageMono_getPixelSize(self)

    def getPixelCode(self):
        r"""getPixelCode(ImageMono self) -> int"""
        return _yarp.ImageMono_getPixelCode(self)

    def pixel(self, *args):
        r"""
        pixel(ImageMono self, size_t x, size_t y) -> unsigned char
        pixel(ImageMono self, size_t x, size_t y) -> unsigned char &
        """
        return _yarp.ImageMono_pixel(self, *args)

    def access(self, *args):
        r"""
        access(ImageMono self, size_t x, size_t y) -> unsigned char const
        access(ImageMono self, size_t x, size_t y) -> unsigned char &
        """
        return _yarp.ImageMono_access(self, *args)

    def safePixel(self, *args):
        r"""
        safePixel(ImageMono self, size_t x, size_t y) -> unsigned char
        safePixel(ImageMono self, size_t x, size_t y) -> unsigned char const &
        """
        return _yarp.ImageMono_safePixel(self, *args)
    __swig_destroy__ = _yarp.delete_ImageMono

# Register ImageMono in _yarp:
_yarp.ImageMono_swigregister(ImageMono)

class TypedReaderImageMono(object):
    r"""Proxy of C++ yarp::os::TypedReader< yarp::sig::ImageOf< yarp::sig::PixelMono > > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def setStrict(self, strict=True):
        r"""setStrict(TypedReaderImageMono self, bool strict=True)"""
        return _yarp.TypedReaderImageMono_setStrict(self, strict)

    def read(self, shouldWait=True):
        r"""read(TypedReaderImageMono self, bool shouldWait=True) -> ImageMono"""
        return _yarp.TypedReaderImageMono_read(self, shouldWait)

    def interrupt(self):
        r"""interrupt(TypedReaderImageMono self)"""
        return _yarp.TypedReaderImageMono_interrupt(self)

    def lastRead(self):
        r"""lastRead(TypedReaderImageMono self) -> ImageMono"""
        return _yarp.TypedReaderImageMono_lastRead(self)

    def isClosed(self):
        r"""isClosed(TypedReaderImageMono self) -> bool"""
        return _yarp.TypedReaderImageMono_isClosed(self)

    def useCallback(self, callback):
        r"""useCallback(TypedReaderImageMono self, TypedReaderCallbackImageMono callback)"""
        return _yarp.TypedReaderImageMono_useCallback(self, callback)

    def disableCallback(self):
        r"""disableCallback(TypedReaderImageMono self)"""
        return _yarp.TypedReaderImageMono_disableCallback(self)

    def getPendingReads(self):
        r"""getPendingReads(TypedReaderImageMono self) -> int"""
        return _yarp.TypedReaderImageMono_getPendingReads(self)
    __swig_destroy__ = _yarp.delete_TypedReaderImageMono

    def getName(self):
        r"""getName(TypedReaderImageMono self) -> std::string"""
        return _yarp.TypedReaderImageMono_getName(self)

    def setReplier(self, reader):
        r"""setReplier(TypedReaderImageMono self, PortReader reader)"""
        return _yarp.TypedReaderImageMono_setReplier(self, reader)

    def acquire(self):
        r"""acquire(TypedReaderImageMono self) -> void *"""
        return _yarp.TypedReaderImageMono_acquire(self)

    def release(self, handle):
        r"""release(TypedReaderImageMono self, void * handle)"""
        return _yarp.TypedReaderImageMono_release(self, handle)

    def setTargetPeriod(self, period):
        r"""setTargetPeriod(TypedReaderImageMono self, double period)"""
        return _yarp.TypedReaderImageMono_setTargetPeriod(self, period)

# Register TypedReaderImageMono in _yarp:
_yarp.TypedReaderImageMono_swigregister(TypedReaderImageMono)

class TypedReaderCallbackImageMono(object):
    r"""Proxy of C++ yarp::os::TypedReaderCallback< yarp::sig::ImageOf< yarp::sig::PixelMono > > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _yarp.delete_TypedReaderCallbackImageMono

    def onRead(self, *args):
        r"""
        onRead(TypedReaderCallbackImageMono self, ImageMono datum)
        onRead(TypedReaderCallbackImageMono self, ImageMono datum, TypedReaderImageMono reader)
        """
        return _yarp.TypedReaderCallbackImageMono_onRead(self, *args)

    def __init__(self):
        r"""__init__(TypedReaderCallbackImageMono self) -> TypedReaderCallbackImageMono"""
        _yarp.TypedReaderCallbackImageMono_swiginit(self, _yarp.new_TypedReaderCallbackImageMono())

# Register TypedReaderCallbackImageMono in _yarp:
_yarp.TypedReaderCallbackImageMono_swigregister(TypedReaderCallbackImageMono)

class BufferedPortImageMono(Contactable, TypedReaderImageMono, TypedReaderCallbackImageMono):
    r"""Proxy of C++ yarp::os::BufferedPort< yarp::sig::ImageOf< yarp::sig::PixelMono > > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        __init__(BufferedPortImageMono self) -> BufferedPortImageMono
        __init__(BufferedPortImageMono self, Port port) -> BufferedPortImageMono
        """
        _yarp.BufferedPortImageMono_swiginit(self, _yarp.new_BufferedPortImageMono(*args))
    __swig_destroy__ = _yarp.delete_BufferedPortImageMono

    def addOutput(self, *args):
        r"""
        addOutput(BufferedPortImageMono self, std::string const & name) -> bool
        addOutput(BufferedPortImageMono self, std::string const & name, std::string const & carrier) -> bool
        addOutput(BufferedPortImageMono self, Contact contact) -> bool
        """
        return _yarp.BufferedPortImageMono_addOutput(self, *args)

    def close(self):
        r"""close(BufferedPortImageMono self)"""
        return _yarp.BufferedPortImageMono_close(self)

    def interrupt(self):
        r"""interrupt(BufferedPortImageMono self)"""
        return _yarp.BufferedPortImageMono_interrupt(self)

    def resume(self):
        r"""resume(BufferedPortImageMono self)"""
        return _yarp.BufferedPortImageMono_resume(self)

    def getPendingReads(self):
        r"""getPendingReads(BufferedPortImageMono self) -> int"""
        return _yarp.BufferedPortImageMono_getPendingReads(self)

    def where(self):
        r"""where(BufferedPortImageMono self) -> Contact"""
        return _yarp.BufferedPortImageMono_where(self)

    def getName(self):
        r"""getName(BufferedPortImageMono self) -> std::string"""
        return _yarp.BufferedPortImageMono_getName(self)

    def prepare(self):
        r"""prepare(BufferedPortImageMono self) -> ImageMono"""
        return _yarp.BufferedPortImageMono_prepare(self)

    def unprepare(self):
        r"""unprepare(BufferedPortImageMono self) -> bool"""
        return _yarp.BufferedPortImageMono_unprepare(self)

    def write(self, forceStrict=False):
        r"""write(BufferedPortImageMono self, bool forceStrict=False)"""
        return _yarp.BufferedPortImageMono_write(self, forceStrict)

    def writeStrict(self):
        r"""writeStrict(BufferedPortImageMono self)"""
        return _yarp.BufferedPortImageMono_writeStrict(self)

    def waitForWrite(self):
        r"""waitForWrite(BufferedPortImageMono self)"""
        return _yarp.BufferedPortImageMono_waitForWrite(self)

    def setStrict(self, strict=True):
        r"""setStrict(BufferedPortImageMono self, bool strict=True)"""
        return _yarp.BufferedPortImageMono_setStrict(self, strict)

    def read(self, shouldWait=True):
        r"""read(BufferedPortImageMono self, bool shouldWait=True) -> ImageMono"""
        return _yarp.BufferedPortImageMono_read(self, shouldWait)

    def lastRead(self):
        r"""lastRead(BufferedPortImageMono self) -> ImageMono"""
        return _yarp.BufferedPortImageMono_lastRead(self)

    def isClosed(self):
        r"""isClosed(BufferedPortImageMono self) -> bool"""
        return _yarp.BufferedPortImageMono_isClosed(self)

    def setReplier(self, reader):
        r"""setReplier(BufferedPortImageMono self, PortReader reader)"""
        return _yarp.BufferedPortImageMono_setReplier(self, reader)

    def setReader(self, reader):
        r"""setReader(BufferedPortImageMono self, PortReader reader)"""
        return _yarp.BufferedPortImageMono_setReader(self, reader)

    def setAdminReader(self, reader):
        r"""setAdminReader(BufferedPortImageMono self, PortReader reader)"""
        return _yarp.BufferedPortImageMono_setAdminReader(self, reader)

    def onRead(self, *args):
        r"""
        onRead(BufferedPortImageMono self, ImageMono datum, TypedReaderImageMono reader)
        onRead(BufferedPortImageMono self, ImageMono datum)
        """
        return _yarp.BufferedPortImageMono_onRead(self, *args)

    def useCallback(self, *args):
        r"""
        useCallback(BufferedPortImageMono self, TypedReaderCallbackImageMono callback)
        useCallback(BufferedPortImageMono self)
        """
        return _yarp.BufferedPortImageMono_useCallback(self, *args)

    def disableCallback(self):
        r"""disableCallback(BufferedPortImageMono self)"""
        return _yarp.BufferedPortImageMono_disableCallback(self)

    def setEnvelope(self, envelope):
        r"""setEnvelope(BufferedPortImageMono self, PortWriter envelope) -> bool"""
        return _yarp.BufferedPortImageMono_setEnvelope(self, envelope)

    def getEnvelope(self, envelope):
        r"""getEnvelope(BufferedPortImageMono self, PortReader envelope) -> bool"""
        return _yarp.BufferedPortImageMono_getEnvelope(self, envelope)

    def getInputCount(self):
        r"""getInputCount(BufferedPortImageMono self) -> int"""
        return _yarp.BufferedPortImageMono_getInputCount(self)

    def getOutputCount(self):
        r"""getOutputCount(BufferedPortImageMono self) -> int"""
        return _yarp.BufferedPortImageMono_getOutputCount(self)

    def isWriting(self):
        r"""isWriting(BufferedPortImageMono self) -> bool"""
        return _yarp.BufferedPortImageMono_isWriting(self)

    def getReport(self, reporter):
        r"""getReport(BufferedPortImageMono self, PortReport reporter)"""
        return _yarp.BufferedPortImageMono_getReport(self, reporter)

    def setReporter(self, reporter):
        r"""setReporter(BufferedPortImageMono self, PortReport reporter)"""
        return _yarp.BufferedPortImageMono_setReporter(self, reporter)

    def resetReporter(self):
        r"""resetReporter(BufferedPortImageMono self)"""
        return _yarp.BufferedPortImageMono_resetReporter(self)

    def acquire(self):
        r"""acquire(BufferedPortImageMono self) -> void *"""
        return _yarp.BufferedPortImageMono_acquire(self)

    def release(self, handle):
        r"""release(BufferedPortImageMono self, void * handle)"""
        return _yarp.BufferedPortImageMono_release(self, handle)

    def setTargetPeriod(self, period):
        r"""setTargetPeriod(BufferedPortImageMono self, double period)"""
        return _yarp.BufferedPortImageMono_setTargetPeriod(self, period)

    def getType(self):
        r"""getType(BufferedPortImageMono self) -> yarp::os::Type"""
        return _yarp.BufferedPortImageMono_getType(self)

    def promiseType(self, typ):
        r"""promiseType(BufferedPortImageMono self, yarp::os::Type const & typ)"""
        return _yarp.BufferedPortImageMono_promiseType(self, typ)

    def setInputMode(self, expectInput):
        r"""setInputMode(BufferedPortImageMono self, bool expectInput)"""
        return _yarp.BufferedPortImageMono_setInputMode(self, expectInput)

    def setOutputMode(self, expectOutput):
        r"""setOutputMode(BufferedPortImageMono self, bool expectOutput)"""
        return _yarp.BufferedPortImageMono_setOutputMode(self, expectOutput)

    def setRpcMode(self, expectRpc):
        r"""setRpcMode(BufferedPortImageMono self, bool expectRpc)"""
        return _yarp.BufferedPortImageMono_setRpcMode(self, expectRpc)

    def acquireProperties(self, readOnly):
        r"""acquireProperties(BufferedPortImageMono self, bool readOnly) -> Property"""
        return _yarp.BufferedPortImageMono_acquireProperties(self, readOnly)

    def releaseProperties(self, prop):
        r"""releaseProperties(BufferedPortImageMono self, Property prop)"""
        return _yarp.BufferedPortImageMono_releaseProperties(self, prop)

    def includeNodeInName(self, flag):
        r"""includeNodeInName(BufferedPortImageMono self, bool flag)"""
        return _yarp.BufferedPortImageMono_includeNodeInName(self, flag)

    def setCallbackLock(self, *args):
        r"""
        setCallbackLock(BufferedPortImageMono self, yarp::os::Mutex * mutex) -> bool
        setCallbackLock(BufferedPortImageMono self, std::mutex * mutex) -> bool
        """
        return _yarp.BufferedPortImageMono_setCallbackLock(self, *args)

    def removeCallbackLock(self):
        r"""removeCallbackLock(BufferedPortImageMono self) -> bool"""
        return _yarp.BufferedPortImageMono_removeCallbackLock(self)

    def lockCallback(self):
        r"""lockCallback(BufferedPortImageMono self) -> bool"""
        return _yarp.BufferedPortImageMono_lockCallback(self)

    def tryLockCallback(self):
        r"""tryLockCallback(BufferedPortImageMono self) -> bool"""
        return _yarp.BufferedPortImageMono_tryLockCallback(self)

    def unlockCallback(self):
        r"""unlockCallback(BufferedPortImageMono self)"""
        return _yarp.BufferedPortImageMono_unlockCallback(self)

# Register BufferedPortImageMono in _yarp:
_yarp.BufferedPortImageMono_swigregister(BufferedPortImageMono)

class ImageMono16(Image):
    r"""Proxy of C++ yarp::sig::ImageOf< yarp::sig::PixelMono16 > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        r"""__init__(ImageMono16 self) -> ImageMono16"""
        _yarp.ImageMono16_swiginit(self, _yarp.new_ImageMono16())

    def getPixelSize(self):
        r"""getPixelSize(ImageMono16 self) -> size_t"""
        return _yarp.ImageMono16_getPixelSize(self)

    def getPixelCode(self):
        r"""getPixelCode(ImageMono16 self) -> int"""
        return _yarp.ImageMono16_getPixelCode(self)

    def pixel(self, *args):
        r"""
        pixel(ImageMono16 self, size_t x, size_t y) -> yarp::os::NetUint16
        pixel(ImageMono16 self, size_t x, size_t y) -> yarp::os::NetUint16 &
        """
        return _yarp.ImageMono16_pixel(self, *args)

    def access(self, *args):
        r"""
        access(ImageMono16 self, size_t x, size_t y) -> yarp::os::NetUint16 const
        access(ImageMono16 self, size_t x, size_t y) -> yarp::os::NetUint16 &
        """
        return _yarp.ImageMono16_access(self, *args)

    def safePixel(self, *args):
        r"""
        safePixel(ImageMono16 self, size_t x, size_t y) -> yarp::os::NetUint16
        safePixel(ImageMono16 self, size_t x, size_t y) -> yarp::os::NetUint16 const &
        """
        return _yarp.ImageMono16_safePixel(self, *args)
    __swig_destroy__ = _yarp.delete_ImageMono16

# Register ImageMono16 in _yarp:
_yarp.ImageMono16_swigregister(ImageMono16)

class TypedReaderImageMono16(object):
    r"""Proxy of C++ yarp::os::TypedReader< yarp::sig::ImageOf< yarp::sig::PixelMono16 > > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def setStrict(self, strict=True):
        r"""setStrict(TypedReaderImageMono16 self, bool strict=True)"""
        return _yarp.TypedReaderImageMono16_setStrict(self, strict)

    def read(self, shouldWait=True):
        r"""read(TypedReaderImageMono16 self, bool shouldWait=True) -> ImageMono16"""
        return _yarp.TypedReaderImageMono16_read(self, shouldWait)

    def interrupt(self):
        r"""interrupt(TypedReaderImageMono16 self)"""
        return _yarp.TypedReaderImageMono16_interrupt(self)

    def lastRead(self):
        r"""lastRead(TypedReaderImageMono16 self) -> ImageMono16"""
        return _yarp.TypedReaderImageMono16_lastRead(self)

    def isClosed(self):
        r"""isClosed(TypedReaderImageMono16 self) -> bool"""
        return _yarp.TypedReaderImageMono16_isClosed(self)

    def useCallback(self, callback):
        r"""useCallback(TypedReaderImageMono16 self, TypedReaderCallbackImageMono16 callback)"""
        return _yarp.TypedReaderImageMono16_useCallback(self, callback)

    def disableCallback(self):
        r"""disableCallback(TypedReaderImageMono16 self)"""
        return _yarp.TypedReaderImageMono16_disableCallback(self)

    def getPendingReads(self):
        r"""getPendingReads(TypedReaderImageMono16 self) -> int"""
        return _yarp.TypedReaderImageMono16_getPendingReads(self)
    __swig_destroy__ = _yarp.delete_TypedReaderImageMono16

    def getName(self):
        r"""getName(TypedReaderImageMono16 self) -> std::string"""
        return _yarp.TypedReaderImageMono16_getName(self)

    def setReplier(self, reader):
        r"""setReplier(TypedReaderImageMono16 self, PortReader reader)"""
        return _yarp.TypedReaderImageMono16_setReplier(self, reader)

    def acquire(self):
        r"""acquire(TypedReaderImageMono16 self) -> void *"""
        return _yarp.TypedReaderImageMono16_acquire(self)

    def release(self, handle):
        r"""release(TypedReaderImageMono16 self, void * handle)"""
        return _yarp.TypedReaderImageMono16_release(self, handle)

    def setTargetPeriod(self, period):
        r"""setTargetPeriod(TypedReaderImageMono16 self, double period)"""
        return _yarp.TypedReaderImageMono16_setTargetPeriod(self, period)

# Register TypedReaderImageMono16 in _yarp:
_yarp.TypedReaderImageMono16_swigregister(TypedReaderImageMono16)

class TypedReaderCallbackImageMono16(object):
    r"""Proxy of C++ yarp::os::TypedReaderCallback< yarp::sig::ImageOf< yarp::sig::PixelMono16 > > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _yarp.delete_TypedReaderCallbackImageMono16

    def onRead(self, *args):
        r"""
        onRead(TypedReaderCallbackImageMono16 self, ImageMono16 datum)
        onRead(TypedReaderCallbackImageMono16 self, ImageMono16 datum, TypedReaderImageMono16 reader)
        """
        return _yarp.TypedReaderCallbackImageMono16_onRead(self, *args)

    def __init__(self):
        r"""__init__(TypedReaderCallbackImageMono16 self) -> TypedReaderCallbackImageMono16"""
        _yarp.TypedReaderCallbackImageMono16_swiginit(self, _yarp.new_TypedReaderCallbackImageMono16())

# Register TypedReaderCallbackImageMono16 in _yarp:
_yarp.TypedReaderCallbackImageMono16_swigregister(TypedReaderCallbackImageMono16)

class BufferedPortImageMono16(Contactable, TypedReaderImageMono16, TypedReaderCallbackImageMono16):
    r"""Proxy of C++ yarp::os::BufferedPort< yarp::sig::ImageOf< yarp::sig::PixelMono16 > > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        __init__(BufferedPortImageMono16 self) -> BufferedPortImageMono16
        __init__(BufferedPortImageMono16 self, Port port) -> BufferedPortImageMono16
        """
        _yarp.BufferedPortImageMono16_swiginit(self, _yarp.new_BufferedPortImageMono16(*args))
    __swig_destroy__ = _yarp.delete_BufferedPortImageMono16

    def addOutput(self, *args):
        r"""
        addOutput(BufferedPortImageMono16 self, std::string const & name) -> bool
        addOutput(BufferedPortImageMono16 self, std::string const & name, std::string const & carrier) -> bool
        addOutput(BufferedPortImageMono16 self, Contact contact) -> bool
        """
        return _yarp.BufferedPortImageMono16_addOutput(self, *args)

    def close(self):
        r"""close(BufferedPortImageMono16 self)"""
        return _yarp.BufferedPortImageMono16_close(self)

    def interrupt(self):
        r"""interrupt(BufferedPortImageMono16 self)"""
        return _yarp.BufferedPortImageMono16_interrupt(self)

    def resume(self):
        r"""resume(BufferedPortImageMono16 self)"""
        return _yarp.BufferedPortImageMono16_resume(self)

    def getPendingReads(self):
        r"""getPendingReads(BufferedPortImageMono16 self) -> int"""
        return _yarp.BufferedPortImageMono16_getPendingReads(self)

    def where(self):
        r"""where(BufferedPortImageMono16 self) -> Contact"""
        return _yarp.BufferedPortImageMono16_where(self)

    def getName(self):
        r"""getName(BufferedPortImageMono16 self) -> std::string"""
        return _yarp.BufferedPortImageMono16_getName(self)

    def prepare(self):
        r"""prepare(BufferedPortImageMono16 self) -> ImageMono16"""
        return _yarp.BufferedPortImageMono16_prepare(self)

    def unprepare(self):
        r"""unprepare(BufferedPortImageMono16 self) -> bool"""
        return _yarp.BufferedPortImageMono16_unprepare(self)

    def write(self, forceStrict=False):
        r"""write(BufferedPortImageMono16 self, bool forceStrict=False)"""
        return _yarp.BufferedPortImageMono16_write(self, forceStrict)

    def writeStrict(self):
        r"""writeStrict(BufferedPortImageMono16 self)"""
        return _yarp.BufferedPortImageMono16_writeStrict(self)

    def waitForWrite(self):
        r"""waitForWrite(BufferedPortImageMono16 self)"""
        return _yarp.BufferedPortImageMono16_waitForWrite(self)

    def setStrict(self, strict=True):
        r"""setStrict(BufferedPortImageMono16 self, bool strict=True)"""
        return _yarp.BufferedPortImageMono16_setStrict(self, strict)

    def read(self, shouldWait=True):
        r"""read(BufferedPortImageMono16 self, bool shouldWait=True) -> ImageMono16"""
        return _yarp.BufferedPortImageMono16_read(self, shouldWait)

    def lastRead(self):
        r"""lastRead(BufferedPortImageMono16 self) -> ImageMono16"""
        return _yarp.BufferedPortImageMono16_lastRead(self)

    def isClosed(self):
        r"""isClosed(BufferedPortImageMono16 self) -> bool"""
        return _yarp.BufferedPortImageMono16_isClosed(self)

    def setReplier(self, reader):
        r"""setReplier(BufferedPortImageMono16 self, PortReader reader)"""
        return _yarp.BufferedPortImageMono16_setReplier(self, reader)

    def setReader(self, reader):
        r"""setReader(BufferedPortImageMono16 self, PortReader reader)"""
        return _yarp.BufferedPortImageMono16_setReader(self, reader)

    def setAdminReader(self, reader):
        r"""setAdminReader(BufferedPortImageMono16 self, PortReader reader)"""
        return _yarp.BufferedPortImageMono16_setAdminReader(self, reader)

    def onRead(self, *args):
        r"""
        onRead(BufferedPortImageMono16 self, ImageMono16 datum, TypedReaderImageMono16 reader)
        onRead(BufferedPortImageMono16 self, ImageMono16 datum)
        """
        return _yarp.BufferedPortImageMono16_onRead(self, *args)

    def useCallback(self, *args):
        r"""
        useCallback(BufferedPortImageMono16 self, TypedReaderCallbackImageMono16 callback)
        useCallback(BufferedPortImageMono16 self)
        """
        return _yarp.BufferedPortImageMono16_useCallback(self, *args)

    def disableCallback(self):
        r"""disableCallback(BufferedPortImageMono16 self)"""
        return _yarp.BufferedPortImageMono16_disableCallback(self)

    def setEnvelope(self, envelope):
        r"""setEnvelope(BufferedPortImageMono16 self, PortWriter envelope) -> bool"""
        return _yarp.BufferedPortImageMono16_setEnvelope(self, envelope)

    def getEnvelope(self, envelope):
        r"""getEnvelope(BufferedPortImageMono16 self, PortReader envelope) -> bool"""
        return _yarp.BufferedPortImageMono16_getEnvelope(self, envelope)

    def getInputCount(self):
        r"""getInputCount(BufferedPortImageMono16 self) -> int"""
        return _yarp.BufferedPortImageMono16_getInputCount(self)

    def getOutputCount(self):
        r"""getOutputCount(BufferedPortImageMono16 self) -> int"""
        return _yarp.BufferedPortImageMono16_getOutputCount(self)

    def isWriting(self):
        r"""isWriting(BufferedPortImageMono16 self) -> bool"""
        return _yarp.BufferedPortImageMono16_isWriting(self)

    def getReport(self, reporter):
        r"""getReport(BufferedPortImageMono16 self, PortReport reporter)"""
        return _yarp.BufferedPortImageMono16_getReport(self, reporter)

    def setReporter(self, reporter):
        r"""setReporter(BufferedPortImageMono16 self, PortReport reporter)"""
        return _yarp.BufferedPortImageMono16_setReporter(self, reporter)

    def resetReporter(self):
        r"""resetReporter(BufferedPortImageMono16 self)"""
        return _yarp.BufferedPortImageMono16_resetReporter(self)

    def acquire(self):
        r"""acquire(BufferedPortImageMono16 self) -> void *"""
        return _yarp.BufferedPortImageMono16_acquire(self)

    def release(self, handle):
        r"""release(BufferedPortImageMono16 self, void * handle)"""
        return _yarp.BufferedPortImageMono16_release(self, handle)

    def setTargetPeriod(self, period):
        r"""setTargetPeriod(BufferedPortImageMono16 self, double period)"""
        return _yarp.BufferedPortImageMono16_setTargetPeriod(self, period)

    def getType(self):
        r"""getType(BufferedPortImageMono16 self) -> yarp::os::Type"""
        return _yarp.BufferedPortImageMono16_getType(self)

    def promiseType(self, typ):
        r"""promiseType(BufferedPortImageMono16 self, yarp::os::Type const & typ)"""
        return _yarp.BufferedPortImageMono16_promiseType(self, typ)

    def setInputMode(self, expectInput):
        r"""setInputMode(BufferedPortImageMono16 self, bool expectInput)"""
        return _yarp.BufferedPortImageMono16_setInputMode(self, expectInput)

    def setOutputMode(self, expectOutput):
        r"""setOutputMode(BufferedPortImageMono16 self, bool expectOutput)"""
        return _yarp.BufferedPortImageMono16_setOutputMode(self, expectOutput)

    def setRpcMode(self, expectRpc):
        r"""setRpcMode(BufferedPortImageMono16 self, bool expectRpc)"""
        return _yarp.BufferedPortImageMono16_setRpcMode(self, expectRpc)

    def acquireProperties(self, readOnly):
        r"""acquireProperties(BufferedPortImageMono16 self, bool readOnly) -> Property"""
        return _yarp.BufferedPortImageMono16_acquireProperties(self, readOnly)

    def releaseProperties(self, prop):
        r"""releaseProperties(BufferedPortImageMono16 self, Property prop)"""
        return _yarp.BufferedPortImageMono16_releaseProperties(self, prop)

    def includeNodeInName(self, flag):
        r"""includeNodeInName(BufferedPortImageMono16 self, bool flag)"""
        return _yarp.BufferedPortImageMono16_includeNodeInName(self, flag)

    def setCallbackLock(self, *args):
        r"""
        setCallbackLock(BufferedPortImageMono16 self, yarp::os::Mutex * mutex) -> bool
        setCallbackLock(BufferedPortImageMono16 self, std::mutex * mutex) -> bool
        """
        return _yarp.BufferedPortImageMono16_setCallbackLock(self, *args)

    def removeCallbackLock(self):
        r"""removeCallbackLock(BufferedPortImageMono16 self) -> bool"""
        return _yarp.BufferedPortImageMono16_removeCallbackLock(self)

    def lockCallback(self):
        r"""lockCallback(BufferedPortImageMono16 self) -> bool"""
        return _yarp.BufferedPortImageMono16_lockCallback(self)

    def tryLockCallback(self):
        r"""tryLockCallback(BufferedPortImageMono16 self) -> bool"""
        return _yarp.BufferedPortImageMono16_tryLockCallback(self)

    def unlockCallback(self):
        r"""unlockCallback(BufferedPortImageMono16 self)"""
        return _yarp.BufferedPortImageMono16_unlockCallback(self)

# Register BufferedPortImageMono16 in _yarp:
_yarp.BufferedPortImageMono16_swigregister(BufferedPortImageMono16)

class ImageInt(Image):
    r"""Proxy of C++ yarp::sig::ImageOf< yarp::sig::PixelInt > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        r"""__init__(ImageInt self) -> ImageInt"""
        _yarp.ImageInt_swiginit(self, _yarp.new_ImageInt())

    def getPixelSize(self):
        r"""getPixelSize(ImageInt self) -> size_t"""
        return _yarp.ImageInt_getPixelSize(self)

    def getPixelCode(self):
        r"""getPixelCode(ImageInt self) -> int"""
        return _yarp.ImageInt_getPixelCode(self)

    def pixel(self, *args):
        r"""
        pixel(ImageInt self, size_t x, size_t y) -> std::int32_t
        pixel(ImageInt self, size_t x, size_t y) -> std::int32_t &
        """
        return _yarp.ImageInt_pixel(self, *args)

    def access(self, *args):
        r"""
        access(ImageInt self, size_t x, size_t y) -> std::int32_t const
        access(ImageInt self, size_t x, size_t y) -> std::int32_t &
        """
        return _yarp.ImageInt_access(self, *args)

    def safePixel(self, *args):
        r"""
        safePixel(ImageInt self, size_t x, size_t y) -> std::int32_t
        safePixel(ImageInt self, size_t x, size_t y) -> std::int32_t const &
        """
        return _yarp.ImageInt_safePixel(self, *args)

    def getPixel(self, x, y):
        r"""getPixel(ImageInt self, int x, int y) -> int"""
        return _yarp.ImageInt_getPixel(self, x, y)

    def setPixel(self, x, y, v):
        r"""setPixel(ImageInt self, int x, int y, int v)"""
        return _yarp.ImageInt_setPixel(self, x, y, v)
    __swig_destroy__ = _yarp.delete_ImageInt

# Register ImageInt in _yarp:
_yarp.ImageInt_swigregister(ImageInt)

class TypedReaderImageInt(object):
    r"""Proxy of C++ yarp::os::TypedReader< yarp::sig::ImageOf< yarp::sig::PixelInt > > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def setStrict(self, strict=True):
        r"""setStrict(TypedReaderImageInt self, bool strict=True)"""
        return _yarp.TypedReaderImageInt_setStrict(self, strict)

    def read(self, shouldWait=True):
        r"""read(TypedReaderImageInt self, bool shouldWait=True) -> ImageInt"""
        return _yarp.TypedReaderImageInt_read(self, shouldWait)

    def interrupt(self):
        r"""interrupt(TypedReaderImageInt self)"""
        return _yarp.TypedReaderImageInt_interrupt(self)

    def lastRead(self):
        r"""lastRead(TypedReaderImageInt self) -> ImageInt"""
        return _yarp.TypedReaderImageInt_lastRead(self)

    def isClosed(self):
        r"""isClosed(TypedReaderImageInt self) -> bool"""
        return _yarp.TypedReaderImageInt_isClosed(self)

    def useCallback(self, callback):
        r"""useCallback(TypedReaderImageInt self, TypedReaderCallbackImageInt callback)"""
        return _yarp.TypedReaderImageInt_useCallback(self, callback)

    def disableCallback(self):
        r"""disableCallback(TypedReaderImageInt self)"""
        return _yarp.TypedReaderImageInt_disableCallback(self)

    def getPendingReads(self):
        r"""getPendingReads(TypedReaderImageInt self) -> int"""
        return _yarp.TypedReaderImageInt_getPendingReads(self)
    __swig_destroy__ = _yarp.delete_TypedReaderImageInt

    def getName(self):
        r"""getName(TypedReaderImageInt self) -> std::string"""
        return _yarp.TypedReaderImageInt_getName(self)

    def setReplier(self, reader):
        r"""setReplier(TypedReaderImageInt self, PortReader reader)"""
        return _yarp.TypedReaderImageInt_setReplier(self, reader)

    def acquire(self):
        r"""acquire(TypedReaderImageInt self) -> void *"""
        return _yarp.TypedReaderImageInt_acquire(self)

    def release(self, handle):
        r"""release(TypedReaderImageInt self, void * handle)"""
        return _yarp.TypedReaderImageInt_release(self, handle)

    def setTargetPeriod(self, period):
        r"""setTargetPeriod(TypedReaderImageInt self, double period)"""
        return _yarp.TypedReaderImageInt_setTargetPeriod(self, period)

# Register TypedReaderImageInt in _yarp:
_yarp.TypedReaderImageInt_swigregister(TypedReaderImageInt)

class TypedReaderCallbackImageInt(object):
    r"""Proxy of C++ yarp::os::TypedReaderCallback< yarp::sig::ImageOf< yarp::sig::PixelInt > > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _yarp.delete_TypedReaderCallbackImageInt

    def onRead(self, *args):
        r"""
        onRead(TypedReaderCallbackImageInt self, ImageInt datum)
        onRead(TypedReaderCallbackImageInt self, ImageInt datum, TypedReaderImageInt reader)
        """
        return _yarp.TypedReaderCallbackImageInt_onRead(self, *args)

    def __init__(self):
        r"""__init__(TypedReaderCallbackImageInt self) -> TypedReaderCallbackImageInt"""
        _yarp.TypedReaderCallbackImageInt_swiginit(self, _yarp.new_TypedReaderCallbackImageInt())

# Register TypedReaderCallbackImageInt in _yarp:
_yarp.TypedReaderCallbackImageInt_swigregister(TypedReaderCallbackImageInt)

class BufferedPortImageInt(Contactable, TypedReaderImageInt, TypedReaderCallbackImageInt):
    r"""Proxy of C++ yarp::os::BufferedPort< yarp::sig::ImageOf< yarp::sig::PixelInt > > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        __init__(BufferedPortImageInt self) -> BufferedPortImageInt
        __init__(BufferedPortImageInt self, Port port) -> BufferedPortImageInt
        """
        _yarp.BufferedPortImageInt_swiginit(self, _yarp.new_BufferedPortImageInt(*args))
    __swig_destroy__ = _yarp.delete_BufferedPortImageInt

    def addOutput(self, *args):
        r"""
        addOutput(BufferedPortImageInt self, std::string const & name) -> bool
        addOutput(BufferedPortImageInt self, std::string const & name, std::string const & carrier) -> bool
        addOutput(BufferedPortImageInt self, Contact contact) -> bool
        """
        return _yarp.BufferedPortImageInt_addOutput(self, *args)

    def close(self):
        r"""close(BufferedPortImageInt self)"""
        return _yarp.BufferedPortImageInt_close(self)

    def interrupt(self):
        r"""interrupt(BufferedPortImageInt self)"""
        return _yarp.BufferedPortImageInt_interrupt(self)

    def resume(self):
        r"""resume(BufferedPortImageInt self)"""
        return _yarp.BufferedPortImageInt_resume(self)

    def getPendingReads(self):
        r"""getPendingReads(BufferedPortImageInt self) -> int"""
        return _yarp.BufferedPortImageInt_getPendingReads(self)

    def where(self):
        r"""where(BufferedPortImageInt self) -> Contact"""
        return _yarp.BufferedPortImageInt_where(self)

    def getName(self):
        r"""getName(BufferedPortImageInt self) -> std::string"""
        return _yarp.BufferedPortImageInt_getName(self)

    def prepare(self):
        r"""prepare(BufferedPortImageInt self) -> ImageInt"""
        return _yarp.BufferedPortImageInt_prepare(self)

    def unprepare(self):
        r"""unprepare(BufferedPortImageInt self) -> bool"""
        return _yarp.BufferedPortImageInt_unprepare(self)

    def write(self, forceStrict=False):
        r"""write(BufferedPortImageInt self, bool forceStrict=False)"""
        return _yarp.BufferedPortImageInt_write(self, forceStrict)

    def writeStrict(self):
        r"""writeStrict(BufferedPortImageInt self)"""
        return _yarp.BufferedPortImageInt_writeStrict(self)

    def waitForWrite(self):
        r"""waitForWrite(BufferedPortImageInt self)"""
        return _yarp.BufferedPortImageInt_waitForWrite(self)

    def setStrict(self, strict=True):
        r"""setStrict(BufferedPortImageInt self, bool strict=True)"""
        return _yarp.BufferedPortImageInt_setStrict(self, strict)

    def read(self, shouldWait=True):
        r"""read(BufferedPortImageInt self, bool shouldWait=True) -> ImageInt"""
        return _yarp.BufferedPortImageInt_read(self, shouldWait)

    def lastRead(self):
        r"""lastRead(BufferedPortImageInt self) -> ImageInt"""
        return _yarp.BufferedPortImageInt_lastRead(self)

    def isClosed(self):
        r"""isClosed(BufferedPortImageInt self) -> bool"""
        return _yarp.BufferedPortImageInt_isClosed(self)

    def setReplier(self, reader):
        r"""setReplier(BufferedPortImageInt self, PortReader reader)"""
        return _yarp.BufferedPortImageInt_setReplier(self, reader)

    def setReader(self, reader):
        r"""setReader(BufferedPortImageInt self, PortReader reader)"""
        return _yarp.BufferedPortImageInt_setReader(self, reader)

    def setAdminReader(self, reader):
        r"""setAdminReader(BufferedPortImageInt self, PortReader reader)"""
        return _yarp.BufferedPortImageInt_setAdminReader(self, reader)

    def onRead(self, *args):
        r"""
        onRead(BufferedPortImageInt self, ImageInt datum, TypedReaderImageInt reader)
        onRead(BufferedPortImageInt self, ImageInt datum)
        """
        return _yarp.BufferedPortImageInt_onRead(self, *args)

    def useCallback(self, *args):
        r"""
        useCallback(BufferedPortImageInt self, TypedReaderCallbackImageInt callback)
        useCallback(BufferedPortImageInt self)
        """
        return _yarp.BufferedPortImageInt_useCallback(self, *args)

    def disableCallback(self):
        r"""disableCallback(BufferedPortImageInt self)"""
        return _yarp.BufferedPortImageInt_disableCallback(self)

    def setEnvelope(self, envelope):
        r"""setEnvelope(BufferedPortImageInt self, PortWriter envelope) -> bool"""
        return _yarp.BufferedPortImageInt_setEnvelope(self, envelope)

    def getEnvelope(self, envelope):
        r"""getEnvelope(BufferedPortImageInt self, PortReader envelope) -> bool"""
        return _yarp.BufferedPortImageInt_getEnvelope(self, envelope)

    def getInputCount(self):
        r"""getInputCount(BufferedPortImageInt self) -> int"""
        return _yarp.BufferedPortImageInt_getInputCount(self)

    def getOutputCount(self):
        r"""getOutputCount(BufferedPortImageInt self) -> int"""
        return _yarp.BufferedPortImageInt_getOutputCount(self)

    def isWriting(self):
        r"""isWriting(BufferedPortImageInt self) -> bool"""
        return _yarp.BufferedPortImageInt_isWriting(self)

    def getReport(self, reporter):
        r"""getReport(BufferedPortImageInt self, PortReport reporter)"""
        return _yarp.BufferedPortImageInt_getReport(self, reporter)

    def setReporter(self, reporter):
        r"""setReporter(BufferedPortImageInt self, PortReport reporter)"""
        return _yarp.BufferedPortImageInt_setReporter(self, reporter)

    def resetReporter(self):
        r"""resetReporter(BufferedPortImageInt self)"""
        return _yarp.BufferedPortImageInt_resetReporter(self)

    def acquire(self):
        r"""acquire(BufferedPortImageInt self) -> void *"""
        return _yarp.BufferedPortImageInt_acquire(self)

    def release(self, handle):
        r"""release(BufferedPortImageInt self, void * handle)"""
        return _yarp.BufferedPortImageInt_release(self, handle)

    def setTargetPeriod(self, period):
        r"""setTargetPeriod(BufferedPortImageInt self, double period)"""
        return _yarp.BufferedPortImageInt_setTargetPeriod(self, period)

    def getType(self):
        r"""getType(BufferedPortImageInt self) -> yarp::os::Type"""
        return _yarp.BufferedPortImageInt_getType(self)

    def promiseType(self, typ):
        r"""promiseType(BufferedPortImageInt self, yarp::os::Type const & typ)"""
        return _yarp.BufferedPortImageInt_promiseType(self, typ)

    def setInputMode(self, expectInput):
        r"""setInputMode(BufferedPortImageInt self, bool expectInput)"""
        return _yarp.BufferedPortImageInt_setInputMode(self, expectInput)

    def setOutputMode(self, expectOutput):
        r"""setOutputMode(BufferedPortImageInt self, bool expectOutput)"""
        return _yarp.BufferedPortImageInt_setOutputMode(self, expectOutput)

    def setRpcMode(self, expectRpc):
        r"""setRpcMode(BufferedPortImageInt self, bool expectRpc)"""
        return _yarp.BufferedPortImageInt_setRpcMode(self, expectRpc)

    def acquireProperties(self, readOnly):
        r"""acquireProperties(BufferedPortImageInt self, bool readOnly) -> Property"""
        return _yarp.BufferedPortImageInt_acquireProperties(self, readOnly)

    def releaseProperties(self, prop):
        r"""releaseProperties(BufferedPortImageInt self, Property prop)"""
        return _yarp.BufferedPortImageInt_releaseProperties(self, prop)

    def includeNodeInName(self, flag):
        r"""includeNodeInName(BufferedPortImageInt self, bool flag)"""
        return _yarp.BufferedPortImageInt_includeNodeInName(self, flag)

    def setCallbackLock(self, *args):
        r"""
        setCallbackLock(BufferedPortImageInt self, yarp::os::Mutex * mutex) -> bool
        setCallbackLock(BufferedPortImageInt self, std::mutex * mutex) -> bool
        """
        return _yarp.BufferedPortImageInt_setCallbackLock(self, *args)

    def removeCallbackLock(self):
        r"""removeCallbackLock(BufferedPortImageInt self) -> bool"""
        return _yarp.BufferedPortImageInt_removeCallbackLock(self)

    def lockCallback(self):
        r"""lockCallback(BufferedPortImageInt self) -> bool"""
        return _yarp.BufferedPortImageInt_lockCallback(self)

    def tryLockCallback(self):
        r"""tryLockCallback(BufferedPortImageInt self) -> bool"""
        return _yarp.BufferedPortImageInt_tryLockCallback(self)

    def unlockCallback(self):
        r"""unlockCallback(BufferedPortImageInt self)"""
        return _yarp.BufferedPortImageInt_unlockCallback(self)

# Register BufferedPortImageInt in _yarp:
_yarp.BufferedPortImageInt_swigregister(BufferedPortImageInt)

class TypedReaderSound(object):
    r"""Proxy of C++ yarp::os::TypedReader< yarp::sig::Sound > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def setStrict(self, strict=True):
        r"""setStrict(TypedReaderSound self, bool strict=True)"""
        return _yarp.TypedReaderSound_setStrict(self, strict)

    def read(self, shouldWait=True):
        r"""read(TypedReaderSound self, bool shouldWait=True) -> Sound"""
        return _yarp.TypedReaderSound_read(self, shouldWait)

    def interrupt(self):
        r"""interrupt(TypedReaderSound self)"""
        return _yarp.TypedReaderSound_interrupt(self)

    def lastRead(self):
        r"""lastRead(TypedReaderSound self) -> Sound"""
        return _yarp.TypedReaderSound_lastRead(self)

    def isClosed(self):
        r"""isClosed(TypedReaderSound self) -> bool"""
        return _yarp.TypedReaderSound_isClosed(self)

    def useCallback(self, callback):
        r"""useCallback(TypedReaderSound self, TypedReaderCallbackSound callback)"""
        return _yarp.TypedReaderSound_useCallback(self, callback)

    def disableCallback(self):
        r"""disableCallback(TypedReaderSound self)"""
        return _yarp.TypedReaderSound_disableCallback(self)

    def getPendingReads(self):
        r"""getPendingReads(TypedReaderSound self) -> int"""
        return _yarp.TypedReaderSound_getPendingReads(self)
    __swig_destroy__ = _yarp.delete_TypedReaderSound

    def getName(self):
        r"""getName(TypedReaderSound self) -> std::string"""
        return _yarp.TypedReaderSound_getName(self)

    def setReplier(self, reader):
        r"""setReplier(TypedReaderSound self, PortReader reader)"""
        return _yarp.TypedReaderSound_setReplier(self, reader)

    def acquire(self):
        r"""acquire(TypedReaderSound self) -> void *"""
        return _yarp.TypedReaderSound_acquire(self)

    def release(self, handle):
        r"""release(TypedReaderSound self, void * handle)"""
        return _yarp.TypedReaderSound_release(self, handle)

    def setTargetPeriod(self, period):
        r"""setTargetPeriod(TypedReaderSound self, double period)"""
        return _yarp.TypedReaderSound_setTargetPeriod(self, period)

# Register TypedReaderSound in _yarp:
_yarp.TypedReaderSound_swigregister(TypedReaderSound)

class TypedReaderCallbackSound(object):
    r"""Proxy of C++ yarp::os::TypedReaderCallback< yarp::sig::Sound > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _yarp.delete_TypedReaderCallbackSound

    def onRead(self, *args):
        r"""
        onRead(TypedReaderCallbackSound self, Sound datum)
        onRead(TypedReaderCallbackSound self, Sound datum, TypedReaderSound reader)
        """
        return _yarp.TypedReaderCallbackSound_onRead(self, *args)

    def __init__(self):
        r"""__init__(TypedReaderCallbackSound self) -> TypedReaderCallbackSound"""
        if self.__class__ == TypedReaderCallbackSound:
            _self = None
        else:
            _self = self
        _yarp.TypedReaderCallbackSound_swiginit(self, _yarp.new_TypedReaderCallbackSound(_self, ))
    def __disown__(self):
        self.this.disown()
        _yarp.disown_TypedReaderCallbackSound(self)
        return weakref.proxy(self)

# Register TypedReaderCallbackSound in _yarp:
_yarp.TypedReaderCallbackSound_swigregister(TypedReaderCallbackSound)

class BufferedPortSound(Contactable, TypedReaderSound, TypedReaderCallbackSound):
    r"""Proxy of C++ yarp::os::BufferedPort< yarp::sig::Sound > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        __init__(BufferedPortSound self) -> BufferedPortSound
        __init__(BufferedPortSound self, Port port) -> BufferedPortSound
        """
        _yarp.BufferedPortSound_swiginit(self, _yarp.new_BufferedPortSound(*args))
    __swig_destroy__ = _yarp.delete_BufferedPortSound

    def addOutput(self, *args):
        r"""
        addOutput(BufferedPortSound self, std::string const & name) -> bool
        addOutput(BufferedPortSound self, std::string const & name, std::string const & carrier) -> bool
        addOutput(BufferedPortSound self, Contact contact) -> bool
        """
        return _yarp.BufferedPortSound_addOutput(self, *args)

    def close(self):
        r"""close(BufferedPortSound self)"""
        return _yarp.BufferedPortSound_close(self)

    def interrupt(self):
        r"""interrupt(BufferedPortSound self)"""
        return _yarp.BufferedPortSound_interrupt(self)

    def resume(self):
        r"""resume(BufferedPortSound self)"""
        return _yarp.BufferedPortSound_resume(self)

    def getPendingReads(self):
        r"""getPendingReads(BufferedPortSound self) -> int"""
        return _yarp.BufferedPortSound_getPendingReads(self)

    def where(self):
        r"""where(BufferedPortSound self) -> Contact"""
        return _yarp.BufferedPortSound_where(self)

    def getName(self):
        r"""getName(BufferedPortSound self) -> std::string"""
        return _yarp.BufferedPortSound_getName(self)

    def prepare(self):
        r"""prepare(BufferedPortSound self) -> Sound"""
        return _yarp.BufferedPortSound_prepare(self)

    def unprepare(self):
        r"""unprepare(BufferedPortSound self) -> bool"""
        return _yarp.BufferedPortSound_unprepare(self)

    def write(self, forceStrict=False):
        r"""write(BufferedPortSound self, bool forceStrict=False)"""
        return _yarp.BufferedPortSound_write(self, forceStrict)

    def writeStrict(self):
        r"""writeStrict(BufferedPortSound self)"""
        return _yarp.BufferedPortSound_writeStrict(self)

    def waitForWrite(self):
        r"""waitForWrite(BufferedPortSound self)"""
        return _yarp.BufferedPortSound_waitForWrite(self)

    def setStrict(self, strict=True):
        r"""setStrict(BufferedPortSound self, bool strict=True)"""
        return _yarp.BufferedPortSound_setStrict(self, strict)

    def read(self, shouldWait=True):
        r"""read(BufferedPortSound self, bool shouldWait=True) -> Sound"""
        return _yarp.BufferedPortSound_read(self, shouldWait)

    def lastRead(self):
        r"""lastRead(BufferedPortSound self) -> Sound"""
        return _yarp.BufferedPortSound_lastRead(self)

    def isClosed(self):
        r"""isClosed(BufferedPortSound self) -> bool"""
        return _yarp.BufferedPortSound_isClosed(self)

    def setReplier(self, reader):
        r"""setReplier(BufferedPortSound self, PortReader reader)"""
        return _yarp.BufferedPortSound_setReplier(self, reader)

    def setReader(self, reader):
        r"""setReader(BufferedPortSound self, PortReader reader)"""
        return _yarp.BufferedPortSound_setReader(self, reader)

    def setAdminReader(self, reader):
        r"""setAdminReader(BufferedPortSound self, PortReader reader)"""
        return _yarp.BufferedPortSound_setAdminReader(self, reader)

    def onRead(self, *args):
        r"""
        onRead(BufferedPortSound self, Sound datum, TypedReaderSound reader)
        onRead(BufferedPortSound self, Sound datum)
        """
        return _yarp.BufferedPortSound_onRead(self, *args)

    def useCallback(self, *args):
        r"""
        useCallback(BufferedPortSound self, TypedReaderCallbackSound callback)
        useCallback(BufferedPortSound self)
        """
        return _yarp.BufferedPortSound_useCallback(self, *args)

    def disableCallback(self):
        r"""disableCallback(BufferedPortSound self)"""
        return _yarp.BufferedPortSound_disableCallback(self)

    def setEnvelope(self, envelope):
        r"""setEnvelope(BufferedPortSound self, PortWriter envelope) -> bool"""
        return _yarp.BufferedPortSound_setEnvelope(self, envelope)

    def getEnvelope(self, envelope):
        r"""getEnvelope(BufferedPortSound self, PortReader envelope) -> bool"""
        return _yarp.BufferedPortSound_getEnvelope(self, envelope)

    def getInputCount(self):
        r"""getInputCount(BufferedPortSound self) -> int"""
        return _yarp.BufferedPortSound_getInputCount(self)

    def getOutputCount(self):
        r"""getOutputCount(BufferedPortSound self) -> int"""
        return _yarp.BufferedPortSound_getOutputCount(self)

    def isWriting(self):
        r"""isWriting(BufferedPortSound self) -> bool"""
        return _yarp.BufferedPortSound_isWriting(self)

    def getReport(self, reporter):
        r"""getReport(BufferedPortSound self, PortReport reporter)"""
        return _yarp.BufferedPortSound_getReport(self, reporter)

    def setReporter(self, reporter):
        r"""setReporter(BufferedPortSound self, PortReport reporter)"""
        return _yarp.BufferedPortSound_setReporter(self, reporter)

    def resetReporter(self):
        r"""resetReporter(BufferedPortSound self)"""
        return _yarp.BufferedPortSound_resetReporter(self)

    def acquire(self):
        r"""acquire(BufferedPortSound self) -> void *"""
        return _yarp.BufferedPortSound_acquire(self)

    def release(self, handle):
        r"""release(BufferedPortSound self, void * handle)"""
        return _yarp.BufferedPortSound_release(self, handle)

    def setTargetPeriod(self, period):
        r"""setTargetPeriod(BufferedPortSound self, double period)"""
        return _yarp.BufferedPortSound_setTargetPeriod(self, period)

    def getType(self):
        r"""getType(BufferedPortSound self) -> yarp::os::Type"""
        return _yarp.BufferedPortSound_getType(self)

    def promiseType(self, typ):
        r"""promiseType(BufferedPortSound self, yarp::os::Type const & typ)"""
        return _yarp.BufferedPortSound_promiseType(self, typ)

    def setInputMode(self, expectInput):
        r"""setInputMode(BufferedPortSound self, bool expectInput)"""
        return _yarp.BufferedPortSound_setInputMode(self, expectInput)

    def setOutputMode(self, expectOutput):
        r"""setOutputMode(BufferedPortSound self, bool expectOutput)"""
        return _yarp.BufferedPortSound_setOutputMode(self, expectOutput)

    def setRpcMode(self, expectRpc):
        r"""setRpcMode(BufferedPortSound self, bool expectRpc)"""
        return _yarp.BufferedPortSound_setRpcMode(self, expectRpc)

    def acquireProperties(self, readOnly):
        r"""acquireProperties(BufferedPortSound self, bool readOnly) -> Property"""
        return _yarp.BufferedPortSound_acquireProperties(self, readOnly)

    def releaseProperties(self, prop):
        r"""releaseProperties(BufferedPortSound self, Property prop)"""
        return _yarp.BufferedPortSound_releaseProperties(self, prop)

    def includeNodeInName(self, flag):
        r"""includeNodeInName(BufferedPortSound self, bool flag)"""
        return _yarp.BufferedPortSound_includeNodeInName(self, flag)

    def setCallbackLock(self, *args):
        r"""
        setCallbackLock(BufferedPortSound self, yarp::os::Mutex * mutex) -> bool
        setCallbackLock(BufferedPortSound self, std::mutex * mutex) -> bool
        """
        return _yarp.BufferedPortSound_setCallbackLock(self, *args)

    def removeCallbackLock(self):
        r"""removeCallbackLock(BufferedPortSound self) -> bool"""
        return _yarp.BufferedPortSound_removeCallbackLock(self)

    def lockCallback(self):
        r"""lockCallback(BufferedPortSound self) -> bool"""
        return _yarp.BufferedPortSound_lockCallback(self)

    def tryLockCallback(self):
        r"""tryLockCallback(BufferedPortSound self) -> bool"""
        return _yarp.BufferedPortSound_tryLockCallback(self)

    def unlockCallback(self):
        r"""unlockCallback(BufferedPortSound self)"""
        return _yarp.BufferedPortSound_unlockCallback(self)

# Register BufferedPortSound in _yarp:
_yarp.BufferedPortSound_swigregister(BufferedPortSound)

class Vector(VectorBase):
    r"""Proxy of C++ yarp::sig::VectorOf< double > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _yarp.delete_Vector

    def getElementSize(self):
        r"""getElementSize(Vector self) -> size_t"""
        return _yarp.Vector_getElementSize(self)

    def getBottleTag(self):
        r"""getBottleTag(Vector self) -> int"""
        return _yarp.Vector_getBottleTag(self)

    def getListSize(self):
        r"""getListSize(Vector self) -> size_t"""
        return _yarp.Vector_getListSize(self)

    def getMemoryBlock(self, *args):
        r"""
        getMemoryBlock(Vector self) -> char const
        getMemoryBlock(Vector self) -> char *
        """
        return _yarp.Vector_getMemoryBlock(self, *args)

    def getFirst(self, *args):
        r"""
        getFirst(Vector self) -> double const
        getFirst(Vector self) -> double *
        """
        return _yarp.Vector_getFirst(self, *args)

    def data(self, *args):
        r"""
        data(Vector self) -> double
        data(Vector self) -> double const *
        """
        return _yarp.Vector_data(self, *args)

    def resize(self, *args):
        r"""
        resize(Vector self, size_t size)
        resize(Vector self, size_t size, double const & _def)
        """
        return _yarp.Vector_resize(self, *args)

    def reserve(self, size):
        r"""reserve(Vector self, size_t size)"""
        return _yarp.Vector_reserve(self, size)

    def push_back(self, *args):
        r"""
        push_back(Vector self, double const & elem)
        push_back(Vector self, double && elem)
        """
        return _yarp.Vector_push_back(self, *args)

    def pop_back(self):
        r"""pop_back(Vector self)"""
        return _yarp.Vector_pop_back(self)

    def access(self, *args):
        r"""
        access(Vector self, size_t i) -> double
        access(Vector self, size_t i) -> double const &
        """
        return _yarp.Vector_access(self, *args)

    def size(self):
        r"""size(Vector self) -> size_t"""
        return _yarp.Vector_size(self)

    def length(self):
        r"""length(Vector self) -> size_t"""
        return _yarp.Vector_length(self)

    def capacity(self):
        r"""capacity(Vector self) -> size_t"""
        return _yarp.Vector_capacity(self)

    def zero(self):
        r"""zero(Vector self)"""
        return _yarp.Vector_zero(self)

    def toString(self, precision=-1, width=-1):
        r"""toString(Vector self, int precision=-1, int width=-1) -> std::string"""
        return _yarp.Vector_toString(self, precision, width)

    def toString_c(self, precision=-1, width=-1):
        
        return _yarp.Vector_toString_c(self, precision, width)

    def subVector(self, first, last):
        r"""subVector(Vector self, unsigned int first, unsigned int last) -> Vector"""
        return _yarp.Vector_subVector(self, first, last)

    def setSubvector(self, position, v):
        r"""setSubvector(Vector self, int position, Vector v) -> bool"""
        return _yarp.Vector_setSubvector(self, position, v)

    def isEqual(self, r):
        r"""isEqual(Vector self, Vector r) -> bool"""
        return _yarp.Vector_isEqual(self, r)

    def begin(self, *args):
        r"""
        begin(Vector self) -> yarp::sig::VectorOf< double >::iterator
        begin(Vector self) -> yarp::sig::VectorOf< double >::const_iterator
        """
        return _yarp.Vector_begin(self, *args)

    def end(self, *args):
        r"""
        end(Vector self) -> yarp::sig::VectorOf< double >::iterator
        end(Vector self) -> yarp::sig::VectorOf< double >::const_iterator
        """
        return _yarp.Vector_end(self, *args)

    def cbegin(self):
        r"""cbegin(Vector self) -> yarp::sig::VectorOf< double >::const_iterator"""
        return _yarp.Vector_cbegin(self)

    def cend(self):
        r"""cend(Vector self) -> yarp::sig::VectorOf< double >::const_iterator"""
        return _yarp.Vector_cend(self)

    def clear(self):
        r"""clear(Vector self)"""
        return _yarp.Vector_clear(self)

    def __init__(self, *args):
        r"""
        __init__(Vector self) -> Vector
        __init__(Vector self, size_t size) -> Vector
        __init__(Vector self, size_t s, double const & _def) -> Vector
        __init__(Vector self, size_t s, double const * p) -> Vector
        __init__(Vector self, Vector r) -> Vector
        __init__(Vector self, Vector other) -> Vector
        __init__(Vector self, DVector values) -> Vector
        """
        _yarp.Vector_swiginit(self, _yarp.new_Vector(*args))

    def get(self, j):
        r"""get(Vector self, int j) -> double"""
        return _yarp.Vector_get(self, j)

    def set(self, j, v):
        r"""set(Vector self, int j, double v)"""
        return _yarp.Vector_set(self, j, v)

    def __setitem__(self, key, value):
        r"""__setitem__(Vector self, int key, double value)"""
        return _yarp.Vector___setitem__(self, key, value)

    def __getitem__(self, key):
        r"""__getitem__(Vector self, int key) -> double"""
        return _yarp.Vector___getitem__(self, key)

    def __len__(self):
        r"""__len__(Vector self) -> double"""
        return _yarp.Vector___len__(self)

# Register Vector in _yarp:
_yarp.Vector_swigregister(Vector)

class TypedReaderVector(object):
    r"""Proxy of C++ yarp::os::TypedReader< yarp::sig::VectorOf< double > > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def setStrict(self, strict=True):
        r"""setStrict(TypedReaderVector self, bool strict=True)"""
        return _yarp.TypedReaderVector_setStrict(self, strict)

    def read(self, shouldWait=True):
        r"""read(TypedReaderVector self, bool shouldWait=True) -> Vector"""
        return _yarp.TypedReaderVector_read(self, shouldWait)

    def interrupt(self):
        r"""interrupt(TypedReaderVector self)"""
        return _yarp.TypedReaderVector_interrupt(self)

    def lastRead(self):
        r"""lastRead(TypedReaderVector self) -> Vector"""
        return _yarp.TypedReaderVector_lastRead(self)

    def isClosed(self):
        r"""isClosed(TypedReaderVector self) -> bool"""
        return _yarp.TypedReaderVector_isClosed(self)

    def useCallback(self, callback):
        r"""useCallback(TypedReaderVector self, TypedReaderCallbackVector callback)"""
        return _yarp.TypedReaderVector_useCallback(self, callback)

    def disableCallback(self):
        r"""disableCallback(TypedReaderVector self)"""
        return _yarp.TypedReaderVector_disableCallback(self)

    def getPendingReads(self):
        r"""getPendingReads(TypedReaderVector self) -> int"""
        return _yarp.TypedReaderVector_getPendingReads(self)
    __swig_destroy__ = _yarp.delete_TypedReaderVector

    def getName(self):
        r"""getName(TypedReaderVector self) -> std::string"""
        return _yarp.TypedReaderVector_getName(self)

    def setReplier(self, reader):
        r"""setReplier(TypedReaderVector self, PortReader reader)"""
        return _yarp.TypedReaderVector_setReplier(self, reader)

    def acquire(self):
        r"""acquire(TypedReaderVector self) -> void *"""
        return _yarp.TypedReaderVector_acquire(self)

    def release(self, handle):
        r"""release(TypedReaderVector self, void * handle)"""
        return _yarp.TypedReaderVector_release(self, handle)

    def setTargetPeriod(self, period):
        r"""setTargetPeriod(TypedReaderVector self, double period)"""
        return _yarp.TypedReaderVector_setTargetPeriod(self, period)

# Register TypedReaderVector in _yarp:
_yarp.TypedReaderVector_swigregister(TypedReaderVector)

class TypedReaderCallbackVector(object):
    r"""Proxy of C++ yarp::os::TypedReaderCallback< yarp::sig::VectorOf< double > > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _yarp.delete_TypedReaderCallbackVector

    def onRead(self, *args):
        r"""
        onRead(TypedReaderCallbackVector self, Vector datum)
        onRead(TypedReaderCallbackVector self, Vector datum, TypedReaderVector reader)
        """
        return _yarp.TypedReaderCallbackVector_onRead(self, *args)

    def __init__(self):
        r"""__init__(TypedReaderCallbackVector self) -> TypedReaderCallbackVector"""
        _yarp.TypedReaderCallbackVector_swiginit(self, _yarp.new_TypedReaderCallbackVector())

# Register TypedReaderCallbackVector in _yarp:
_yarp.TypedReaderCallbackVector_swigregister(TypedReaderCallbackVector)

class BufferedPortVector(Contactable, TypedReaderVector, TypedReaderCallbackVector):
    r"""Proxy of C++ yarp::os::BufferedPort< yarp::sig::VectorOf< double > > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        __init__(BufferedPortVector self) -> BufferedPortVector
        __init__(BufferedPortVector self, Port port) -> BufferedPortVector
        """
        _yarp.BufferedPortVector_swiginit(self, _yarp.new_BufferedPortVector(*args))
    __swig_destroy__ = _yarp.delete_BufferedPortVector

    def addOutput(self, *args):
        r"""
        addOutput(BufferedPortVector self, std::string const & name) -> bool
        addOutput(BufferedPortVector self, std::string const & name, std::string const & carrier) -> bool
        addOutput(BufferedPortVector self, Contact contact) -> bool
        """
        return _yarp.BufferedPortVector_addOutput(self, *args)

    def close(self):
        r"""close(BufferedPortVector self)"""
        return _yarp.BufferedPortVector_close(self)

    def interrupt(self):
        r"""interrupt(BufferedPortVector self)"""
        return _yarp.BufferedPortVector_interrupt(self)

    def resume(self):
        r"""resume(BufferedPortVector self)"""
        return _yarp.BufferedPortVector_resume(self)

    def getPendingReads(self):
        r"""getPendingReads(BufferedPortVector self) -> int"""
        return _yarp.BufferedPortVector_getPendingReads(self)

    def where(self):
        r"""where(BufferedPortVector self) -> Contact"""
        return _yarp.BufferedPortVector_where(self)

    def getName(self):
        r"""getName(BufferedPortVector self) -> std::string"""
        return _yarp.BufferedPortVector_getName(self)

    def prepare(self):
        r"""prepare(BufferedPortVector self) -> Vector"""
        return _yarp.BufferedPortVector_prepare(self)

    def unprepare(self):
        r"""unprepare(BufferedPortVector self) -> bool"""
        return _yarp.BufferedPortVector_unprepare(self)

    def write(self, forceStrict=False):
        r"""write(BufferedPortVector self, bool forceStrict=False)"""
        return _yarp.BufferedPortVector_write(self, forceStrict)

    def writeStrict(self):
        r"""writeStrict(BufferedPortVector self)"""
        return _yarp.BufferedPortVector_writeStrict(self)

    def waitForWrite(self):
        r"""waitForWrite(BufferedPortVector self)"""
        return _yarp.BufferedPortVector_waitForWrite(self)

    def setStrict(self, strict=True):
        r"""setStrict(BufferedPortVector self, bool strict=True)"""
        return _yarp.BufferedPortVector_setStrict(self, strict)

    def read(self, shouldWait=True):
        r"""read(BufferedPortVector self, bool shouldWait=True) -> Vector"""
        return _yarp.BufferedPortVector_read(self, shouldWait)

    def lastRead(self):
        r"""lastRead(BufferedPortVector self) -> Vector"""
        return _yarp.BufferedPortVector_lastRead(self)

    def isClosed(self):
        r"""isClosed(BufferedPortVector self) -> bool"""
        return _yarp.BufferedPortVector_isClosed(self)

    def setReplier(self, reader):
        r"""setReplier(BufferedPortVector self, PortReader reader)"""
        return _yarp.BufferedPortVector_setReplier(self, reader)

    def setReader(self, reader):
        r"""setReader(BufferedPortVector self, PortReader reader)"""
        return _yarp.BufferedPortVector_setReader(self, reader)

    def setAdminReader(self, reader):
        r"""setAdminReader(BufferedPortVector self, PortReader reader)"""
        return _yarp.BufferedPortVector_setAdminReader(self, reader)

    def onRead(self, *args):
        r"""
        onRead(BufferedPortVector self, Vector datum, TypedReaderVector reader)
        onRead(BufferedPortVector self, Vector datum)
        """
        return _yarp.BufferedPortVector_onRead(self, *args)

    def useCallback(self, *args):
        r"""
        useCallback(BufferedPortVector self, TypedReaderCallbackVector callback)
        useCallback(BufferedPortVector self)
        """
        return _yarp.BufferedPortVector_useCallback(self, *args)

    def disableCallback(self):
        r"""disableCallback(BufferedPortVector self)"""
        return _yarp.BufferedPortVector_disableCallback(self)

    def setEnvelope(self, envelope):
        r"""setEnvelope(BufferedPortVector self, PortWriter envelope) -> bool"""
        return _yarp.BufferedPortVector_setEnvelope(self, envelope)

    def getEnvelope(self, envelope):
        r"""getEnvelope(BufferedPortVector self, PortReader envelope) -> bool"""
        return _yarp.BufferedPortVector_getEnvelope(self, envelope)

    def getInputCount(self):
        r"""getInputCount(BufferedPortVector self) -> int"""
        return _yarp.BufferedPortVector_getInputCount(self)

    def getOutputCount(self):
        r"""getOutputCount(BufferedPortVector self) -> int"""
        return _yarp.BufferedPortVector_getOutputCount(self)

    def isWriting(self):
        r"""isWriting(BufferedPortVector self) -> bool"""
        return _yarp.BufferedPortVector_isWriting(self)

    def getReport(self, reporter):
        r"""getReport(BufferedPortVector self, PortReport reporter)"""
        return _yarp.BufferedPortVector_getReport(self, reporter)

    def setReporter(self, reporter):
        r"""setReporter(BufferedPortVector self, PortReport reporter)"""
        return _yarp.BufferedPortVector_setReporter(self, reporter)

    def resetReporter(self):
        r"""resetReporter(BufferedPortVector self)"""
        return _yarp.BufferedPortVector_resetReporter(self)

    def acquire(self):
        r"""acquire(BufferedPortVector self) -> void *"""
        return _yarp.BufferedPortVector_acquire(self)

    def release(self, handle):
        r"""release(BufferedPortVector self, void * handle)"""
        return _yarp.BufferedPortVector_release(self, handle)

    def setTargetPeriod(self, period):
        r"""setTargetPeriod(BufferedPortVector self, double period)"""
        return _yarp.BufferedPortVector_setTargetPeriod(self, period)

    def getType(self):
        r"""getType(BufferedPortVector self) -> yarp::os::Type"""
        return _yarp.BufferedPortVector_getType(self)

    def promiseType(self, typ):
        r"""promiseType(BufferedPortVector self, yarp::os::Type const & typ)"""
        return _yarp.BufferedPortVector_promiseType(self, typ)

    def setInputMode(self, expectInput):
        r"""setInputMode(BufferedPortVector self, bool expectInput)"""
        return _yarp.BufferedPortVector_setInputMode(self, expectInput)

    def setOutputMode(self, expectOutput):
        r"""setOutputMode(BufferedPortVector self, bool expectOutput)"""
        return _yarp.BufferedPortVector_setOutputMode(self, expectOutput)

    def setRpcMode(self, expectRpc):
        r"""setRpcMode(BufferedPortVector self, bool expectRpc)"""
        return _yarp.BufferedPortVector_setRpcMode(self, expectRpc)

    def acquireProperties(self, readOnly):
        r"""acquireProperties(BufferedPortVector self, bool readOnly) -> Property"""
        return _yarp.BufferedPortVector_acquireProperties(self, readOnly)

    def releaseProperties(self, prop):
        r"""releaseProperties(BufferedPortVector self, Property prop)"""
        return _yarp.BufferedPortVector_releaseProperties(self, prop)

    def includeNodeInName(self, flag):
        r"""includeNodeInName(BufferedPortVector self, bool flag)"""
        return _yarp.BufferedPortVector_includeNodeInName(self, flag)

    def setCallbackLock(self, *args):
        r"""
        setCallbackLock(BufferedPortVector self, yarp::os::Mutex * mutex) -> bool
        setCallbackLock(BufferedPortVector self, std::mutex * mutex) -> bool
        """
        return _yarp.BufferedPortVector_setCallbackLock(self, *args)

    def removeCallbackLock(self):
        r"""removeCallbackLock(BufferedPortVector self) -> bool"""
        return _yarp.BufferedPortVector_removeCallbackLock(self)

    def lockCallback(self):
        r"""lockCallback(BufferedPortVector self) -> bool"""
        return _yarp.BufferedPortVector_lockCallback(self)

    def tryLockCallback(self):
        r"""tryLockCallback(BufferedPortVector self) -> bool"""
        return _yarp.BufferedPortVector_tryLockCallback(self)

    def unlockCallback(self):
        r"""unlockCallback(BufferedPortVector self)"""
        return _yarp.BufferedPortVector_unlockCallback(self)

# Register BufferedPortVector in _yarp:
_yarp.BufferedPortVector_swigregister(BufferedPortVector)

class VectorInt(VectorBase):
    r"""Proxy of C++ yarp::sig::VectorOf< int > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _yarp.delete_VectorInt

    def getElementSize(self):
        r"""getElementSize(VectorInt self) -> size_t"""
        return _yarp.VectorInt_getElementSize(self)

    def getBottleTag(self):
        r"""getBottleTag(VectorInt self) -> int"""
        return _yarp.VectorInt_getBottleTag(self)

    def getListSize(self):
        r"""getListSize(VectorInt self) -> size_t"""
        return _yarp.VectorInt_getListSize(self)

    def getMemoryBlock(self, *args):
        r"""
        getMemoryBlock(VectorInt self) -> char const
        getMemoryBlock(VectorInt self) -> char *
        """
        return _yarp.VectorInt_getMemoryBlock(self, *args)

    def getFirst(self, *args):
        r"""
        getFirst(VectorInt self) -> int const
        getFirst(VectorInt self) -> int *
        """
        return _yarp.VectorInt_getFirst(self, *args)

    def data(self, *args):
        r"""
        data(VectorInt self) -> int
        data(VectorInt self) -> int const *
        """
        return _yarp.VectorInt_data(self, *args)

    def resize(self, *args):
        r"""
        resize(VectorInt self, size_t size)
        resize(VectorInt self, size_t size, int const & _def)
        """
        return _yarp.VectorInt_resize(self, *args)

    def reserve(self, size):
        r"""reserve(VectorInt self, size_t size)"""
        return _yarp.VectorInt_reserve(self, size)

    def push_back(self, *args):
        r"""
        push_back(VectorInt self, int const & elem)
        push_back(VectorInt self, int && elem)
        """
        return _yarp.VectorInt_push_back(self, *args)

    def pop_back(self):
        r"""pop_back(VectorInt self)"""
        return _yarp.VectorInt_pop_back(self)

    def access(self, *args):
        r"""
        access(VectorInt self, size_t i) -> int
        access(VectorInt self, size_t i) -> int const &
        """
        return _yarp.VectorInt_access(self, *args)

    def size(self):
        r"""size(VectorInt self) -> size_t"""
        return _yarp.VectorInt_size(self)

    def length(self):
        r"""length(VectorInt self) -> size_t"""
        return _yarp.VectorInt_length(self)

    def capacity(self):
        r"""capacity(VectorInt self) -> size_t"""
        return _yarp.VectorInt_capacity(self)

    def zero(self):
        r"""zero(VectorInt self)"""
        return _yarp.VectorInt_zero(self)

    def toString(self, precision=-1, width=-1):
        r"""toString(VectorInt self, int precision=-1, int width=-1) -> std::string"""
        return _yarp.VectorInt_toString(self, precision, width)

    def toString_c(self, precision=-1, width=-1):
        
        return _yarp.VectorInt_toString_c(self, precision, width)

    def subVector(self, first, last):
        r"""subVector(VectorInt self, unsigned int first, unsigned int last) -> VectorInt"""
        return _yarp.VectorInt_subVector(self, first, last)

    def setSubvector(self, position, v):
        r"""setSubvector(VectorInt self, int position, VectorInt v) -> bool"""
        return _yarp.VectorInt_setSubvector(self, position, v)

    def isEqual(self, r):
        r"""isEqual(VectorInt self, VectorInt r) -> bool"""
        return _yarp.VectorInt_isEqual(self, r)

    def begin(self, *args):
        r"""
        begin(VectorInt self) -> yarp::sig::VectorOf< int >::iterator
        begin(VectorInt self) -> yarp::sig::VectorOf< int >::const_iterator
        """
        return _yarp.VectorInt_begin(self, *args)

    def end(self, *args):
        r"""
        end(VectorInt self) -> yarp::sig::VectorOf< int >::iterator
        end(VectorInt self) -> yarp::sig::VectorOf< int >::const_iterator
        """
        return _yarp.VectorInt_end(self, *args)

    def cbegin(self):
        r"""cbegin(VectorInt self) -> yarp::sig::VectorOf< int >::const_iterator"""
        return _yarp.VectorInt_cbegin(self)

    def cend(self):
        r"""cend(VectorInt self) -> yarp::sig::VectorOf< int >::const_iterator"""
        return _yarp.VectorInt_cend(self)

    def clear(self):
        r"""clear(VectorInt self)"""
        return _yarp.VectorInt_clear(self)

    def __init__(self, *args):
        r"""
        __init__(VectorInt self) -> VectorInt
        __init__(VectorInt self, size_t size) -> VectorInt
        __init__(VectorInt self, size_t s, int const & _def) -> VectorInt
        __init__(VectorInt self, size_t s, int const * p) -> VectorInt
        __init__(VectorInt self, VectorInt r) -> VectorInt
        __init__(VectorInt self, VectorInt other) -> VectorInt
        __init__(VectorInt self, IVector values) -> VectorInt
        """
        _yarp.VectorInt_swiginit(self, _yarp.new_VectorInt(*args))

    def get(self, j):
        r"""get(VectorInt self, int j) -> int"""
        return _yarp.VectorInt_get(self, j)

    def set(self, j, v):
        r"""set(VectorInt self, int j, int v)"""
        return _yarp.VectorInt_set(self, j, v)

    def __setitem__(self, key, value):
        r"""__setitem__(VectorInt self, int key, int value)"""
        return _yarp.VectorInt___setitem__(self, key, value)

    def __getitem__(self, key):
        r"""__getitem__(VectorInt self, int key) -> int"""
        return _yarp.VectorInt___getitem__(self, key)

    def __len__(self):
        r"""__len__(VectorInt self) -> int"""
        return _yarp.VectorInt___len__(self)

# Register VectorInt in _yarp:
_yarp.VectorInt_swigregister(VectorInt)

class TypedReaderVectorInt(object):
    r"""Proxy of C++ yarp::os::TypedReader< yarp::sig::VectorOf< int > > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def setStrict(self, strict=True):
        r"""setStrict(TypedReaderVectorInt self, bool strict=True)"""
        return _yarp.TypedReaderVectorInt_setStrict(self, strict)

    def read(self, shouldWait=True):
        r"""read(TypedReaderVectorInt self, bool shouldWait=True) -> VectorInt"""
        return _yarp.TypedReaderVectorInt_read(self, shouldWait)

    def interrupt(self):
        r"""interrupt(TypedReaderVectorInt self)"""
        return _yarp.TypedReaderVectorInt_interrupt(self)

    def lastRead(self):
        r"""lastRead(TypedReaderVectorInt self) -> VectorInt"""
        return _yarp.TypedReaderVectorInt_lastRead(self)

    def isClosed(self):
        r"""isClosed(TypedReaderVectorInt self) -> bool"""
        return _yarp.TypedReaderVectorInt_isClosed(self)

    def useCallback(self, callback):
        r"""useCallback(TypedReaderVectorInt self, TypedReaderCallbackVectorInt callback)"""
        return _yarp.TypedReaderVectorInt_useCallback(self, callback)

    def disableCallback(self):
        r"""disableCallback(TypedReaderVectorInt self)"""
        return _yarp.TypedReaderVectorInt_disableCallback(self)

    def getPendingReads(self):
        r"""getPendingReads(TypedReaderVectorInt self) -> int"""
        return _yarp.TypedReaderVectorInt_getPendingReads(self)
    __swig_destroy__ = _yarp.delete_TypedReaderVectorInt

    def getName(self):
        r"""getName(TypedReaderVectorInt self) -> std::string"""
        return _yarp.TypedReaderVectorInt_getName(self)

    def setReplier(self, reader):
        r"""setReplier(TypedReaderVectorInt self, PortReader reader)"""
        return _yarp.TypedReaderVectorInt_setReplier(self, reader)

    def acquire(self):
        r"""acquire(TypedReaderVectorInt self) -> void *"""
        return _yarp.TypedReaderVectorInt_acquire(self)

    def release(self, handle):
        r"""release(TypedReaderVectorInt self, void * handle)"""
        return _yarp.TypedReaderVectorInt_release(self, handle)

    def setTargetPeriod(self, period):
        r"""setTargetPeriod(TypedReaderVectorInt self, double period)"""
        return _yarp.TypedReaderVectorInt_setTargetPeriod(self, period)

# Register TypedReaderVectorInt in _yarp:
_yarp.TypedReaderVectorInt_swigregister(TypedReaderVectorInt)

class TypedReaderCallbackVectorInt(object):
    r"""Proxy of C++ yarp::os::TypedReaderCallback< yarp::sig::VectorOf< int > > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _yarp.delete_TypedReaderCallbackVectorInt

    def onRead(self, *args):
        r"""
        onRead(TypedReaderCallbackVectorInt self, VectorInt datum)
        onRead(TypedReaderCallbackVectorInt self, VectorInt datum, TypedReaderVectorInt reader)
        """
        return _yarp.TypedReaderCallbackVectorInt_onRead(self, *args)

    def __init__(self):
        r"""__init__(TypedReaderCallbackVectorInt self) -> TypedReaderCallbackVectorInt"""
        _yarp.TypedReaderCallbackVectorInt_swiginit(self, _yarp.new_TypedReaderCallbackVectorInt())

# Register TypedReaderCallbackVectorInt in _yarp:
_yarp.TypedReaderCallbackVectorInt_swigregister(TypedReaderCallbackVectorInt)

class BufferedPortVectorInt(Contactable, TypedReaderVectorInt, TypedReaderCallbackVectorInt):
    r"""Proxy of C++ yarp::os::BufferedPort< yarp::sig::VectorOf< int > > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        __init__(BufferedPortVectorInt self) -> BufferedPortVectorInt
        __init__(BufferedPortVectorInt self, Port port) -> BufferedPortVectorInt
        """
        _yarp.BufferedPortVectorInt_swiginit(self, _yarp.new_BufferedPortVectorInt(*args))
    __swig_destroy__ = _yarp.delete_BufferedPortVectorInt

    def addOutput(self, *args):
        r"""
        addOutput(BufferedPortVectorInt self, std::string const & name) -> bool
        addOutput(BufferedPortVectorInt self, std::string const & name, std::string const & carrier) -> bool
        addOutput(BufferedPortVectorInt self, Contact contact) -> bool
        """
        return _yarp.BufferedPortVectorInt_addOutput(self, *args)

    def close(self):
        r"""close(BufferedPortVectorInt self)"""
        return _yarp.BufferedPortVectorInt_close(self)

    def interrupt(self):
        r"""interrupt(BufferedPortVectorInt self)"""
        return _yarp.BufferedPortVectorInt_interrupt(self)

    def resume(self):
        r"""resume(BufferedPortVectorInt self)"""
        return _yarp.BufferedPortVectorInt_resume(self)

    def getPendingReads(self):
        r"""getPendingReads(BufferedPortVectorInt self) -> int"""
        return _yarp.BufferedPortVectorInt_getPendingReads(self)

    def where(self):
        r"""where(BufferedPortVectorInt self) -> Contact"""
        return _yarp.BufferedPortVectorInt_where(self)

    def getName(self):
        r"""getName(BufferedPortVectorInt self) -> std::string"""
        return _yarp.BufferedPortVectorInt_getName(self)

    def prepare(self):
        r"""prepare(BufferedPortVectorInt self) -> VectorInt"""
        return _yarp.BufferedPortVectorInt_prepare(self)

    def unprepare(self):
        r"""unprepare(BufferedPortVectorInt self) -> bool"""
        return _yarp.BufferedPortVectorInt_unprepare(self)

    def write(self, forceStrict=False):
        r"""write(BufferedPortVectorInt self, bool forceStrict=False)"""
        return _yarp.BufferedPortVectorInt_write(self, forceStrict)

    def writeStrict(self):
        r"""writeStrict(BufferedPortVectorInt self)"""
        return _yarp.BufferedPortVectorInt_writeStrict(self)

    def waitForWrite(self):
        r"""waitForWrite(BufferedPortVectorInt self)"""
        return _yarp.BufferedPortVectorInt_waitForWrite(self)

    def setStrict(self, strict=True):
        r"""setStrict(BufferedPortVectorInt self, bool strict=True)"""
        return _yarp.BufferedPortVectorInt_setStrict(self, strict)

    def read(self, shouldWait=True):
        r"""read(BufferedPortVectorInt self, bool shouldWait=True) -> VectorInt"""
        return _yarp.BufferedPortVectorInt_read(self, shouldWait)

    def lastRead(self):
        r"""lastRead(BufferedPortVectorInt self) -> VectorInt"""
        return _yarp.BufferedPortVectorInt_lastRead(self)

    def isClosed(self):
        r"""isClosed(BufferedPortVectorInt self) -> bool"""
        return _yarp.BufferedPortVectorInt_isClosed(self)

    def setReplier(self, reader):
        r"""setReplier(BufferedPortVectorInt self, PortReader reader)"""
        return _yarp.BufferedPortVectorInt_setReplier(self, reader)

    def setReader(self, reader):
        r"""setReader(BufferedPortVectorInt self, PortReader reader)"""
        return _yarp.BufferedPortVectorInt_setReader(self, reader)

    def setAdminReader(self, reader):
        r"""setAdminReader(BufferedPortVectorInt self, PortReader reader)"""
        return _yarp.BufferedPortVectorInt_setAdminReader(self, reader)

    def onRead(self, *args):
        r"""
        onRead(BufferedPortVectorInt self, VectorInt datum, TypedReaderVectorInt reader)
        onRead(BufferedPortVectorInt self, VectorInt datum)
        """
        return _yarp.BufferedPortVectorInt_onRead(self, *args)

    def useCallback(self, *args):
        r"""
        useCallback(BufferedPortVectorInt self, TypedReaderCallbackVectorInt callback)
        useCallback(BufferedPortVectorInt self)
        """
        return _yarp.BufferedPortVectorInt_useCallback(self, *args)

    def disableCallback(self):
        r"""disableCallback(BufferedPortVectorInt self)"""
        return _yarp.BufferedPortVectorInt_disableCallback(self)

    def setEnvelope(self, envelope):
        r"""setEnvelope(BufferedPortVectorInt self, PortWriter envelope) -> bool"""
        return _yarp.BufferedPortVectorInt_setEnvelope(self, envelope)

    def getEnvelope(self, envelope):
        r"""getEnvelope(BufferedPortVectorInt self, PortReader envelope) -> bool"""
        return _yarp.BufferedPortVectorInt_getEnvelope(self, envelope)

    def getInputCount(self):
        r"""getInputCount(BufferedPortVectorInt self) -> int"""
        return _yarp.BufferedPortVectorInt_getInputCount(self)

    def getOutputCount(self):
        r"""getOutputCount(BufferedPortVectorInt self) -> int"""
        return _yarp.BufferedPortVectorInt_getOutputCount(self)

    def isWriting(self):
        r"""isWriting(BufferedPortVectorInt self) -> bool"""
        return _yarp.BufferedPortVectorInt_isWriting(self)

    def getReport(self, reporter):
        r"""getReport(BufferedPortVectorInt self, PortReport reporter)"""
        return _yarp.BufferedPortVectorInt_getReport(self, reporter)

    def setReporter(self, reporter):
        r"""setReporter(BufferedPortVectorInt self, PortReport reporter)"""
        return _yarp.BufferedPortVectorInt_setReporter(self, reporter)

    def resetReporter(self):
        r"""resetReporter(BufferedPortVectorInt self)"""
        return _yarp.BufferedPortVectorInt_resetReporter(self)

    def acquire(self):
        r"""acquire(BufferedPortVectorInt self) -> void *"""
        return _yarp.BufferedPortVectorInt_acquire(self)

    def release(self, handle):
        r"""release(BufferedPortVectorInt self, void * handle)"""
        return _yarp.BufferedPortVectorInt_release(self, handle)

    def setTargetPeriod(self, period):
        r"""setTargetPeriod(BufferedPortVectorInt self, double period)"""
        return _yarp.BufferedPortVectorInt_setTargetPeriod(self, period)

    def getType(self):
        r"""getType(BufferedPortVectorInt self) -> yarp::os::Type"""
        return _yarp.BufferedPortVectorInt_getType(self)

    def promiseType(self, typ):
        r"""promiseType(BufferedPortVectorInt self, yarp::os::Type const & typ)"""
        return _yarp.BufferedPortVectorInt_promiseType(self, typ)

    def setInputMode(self, expectInput):
        r"""setInputMode(BufferedPortVectorInt self, bool expectInput)"""
        return _yarp.BufferedPortVectorInt_setInputMode(self, expectInput)

    def setOutputMode(self, expectOutput):
        r"""setOutputMode(BufferedPortVectorInt self, bool expectOutput)"""
        return _yarp.BufferedPortVectorInt_setOutputMode(self, expectOutput)

    def setRpcMode(self, expectRpc):
        r"""setRpcMode(BufferedPortVectorInt self, bool expectRpc)"""
        return _yarp.BufferedPortVectorInt_setRpcMode(self, expectRpc)

    def acquireProperties(self, readOnly):
        r"""acquireProperties(BufferedPortVectorInt self, bool readOnly) -> Property"""
        return _yarp.BufferedPortVectorInt_acquireProperties(self, readOnly)

    def releaseProperties(self, prop):
        r"""releaseProperties(BufferedPortVectorInt self, Property prop)"""
        return _yarp.BufferedPortVectorInt_releaseProperties(self, prop)

    def includeNodeInName(self, flag):
        r"""includeNodeInName(BufferedPortVectorInt self, bool flag)"""
        return _yarp.BufferedPortVectorInt_includeNodeInName(self, flag)

    def setCallbackLock(self, *args):
        r"""
        setCallbackLock(BufferedPortVectorInt self, yarp::os::Mutex * mutex) -> bool
        setCallbackLock(BufferedPortVectorInt self, std::mutex * mutex) -> bool
        """
        return _yarp.BufferedPortVectorInt_setCallbackLock(self, *args)

    def removeCallbackLock(self):
        r"""removeCallbackLock(BufferedPortVectorInt self) -> bool"""
        return _yarp.BufferedPortVectorInt_removeCallbackLock(self)

    def lockCallback(self):
        r"""lockCallback(BufferedPortVectorInt self) -> bool"""
        return _yarp.BufferedPortVectorInt_lockCallback(self)

    def tryLockCallback(self):
        r"""tryLockCallback(BufferedPortVectorInt self) -> bool"""
        return _yarp.BufferedPortVectorInt_tryLockCallback(self)

    def unlockCallback(self):
        r"""unlockCallback(BufferedPortVectorInt self)"""
        return _yarp.BufferedPortVectorInt_unlockCallback(self)

# Register BufferedPortVectorInt in _yarp:
_yarp.BufferedPortVectorInt_swigregister(BufferedPortVectorInt)

class ImageFloat(Image):
    r"""Proxy of C++ yarp::sig::ImageOf< yarp::sig::PixelFloat > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        r"""__init__(ImageFloat self) -> ImageFloat"""
        _yarp.ImageFloat_swiginit(self, _yarp.new_ImageFloat())

    def getPixelSize(self):
        r"""getPixelSize(ImageFloat self) -> size_t"""
        return _yarp.ImageFloat_getPixelSize(self)

    def getPixelCode(self):
        r"""getPixelCode(ImageFloat self) -> int"""
        return _yarp.ImageFloat_getPixelCode(self)

    def pixel(self, *args):
        r"""
        pixel(ImageFloat self, size_t x, size_t y) -> float
        pixel(ImageFloat self, size_t x, size_t y) -> float &
        """
        return _yarp.ImageFloat_pixel(self, *args)

    def access(self, *args):
        r"""
        access(ImageFloat self, size_t x, size_t y) -> float const
        access(ImageFloat self, size_t x, size_t y) -> float &
        """
        return _yarp.ImageFloat_access(self, *args)

    def safePixel(self, *args):
        r"""
        safePixel(ImageFloat self, size_t x, size_t y) -> float
        safePixel(ImageFloat self, size_t x, size_t y) -> float const &
        """
        return _yarp.ImageFloat_safePixel(self, *args)

    def getPixel(self, x, y):
        r"""getPixel(ImageFloat self, int x, int y) -> float"""
        return _yarp.ImageFloat_getPixel(self, x, y)

    def setPixel(self, x, y, v):
        r"""setPixel(ImageFloat self, int x, int y, float v)"""
        return _yarp.ImageFloat_setPixel(self, x, y, v)
    __swig_destroy__ = _yarp.delete_ImageFloat

# Register ImageFloat in _yarp:
_yarp.ImageFloat_swigregister(ImageFloat)

class TypedReaderImageFloat(object):
    r"""Proxy of C++ yarp::os::TypedReader< yarp::sig::ImageOf< yarp::sig::PixelFloat > > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def setStrict(self, strict=True):
        r"""setStrict(TypedReaderImageFloat self, bool strict=True)"""
        return _yarp.TypedReaderImageFloat_setStrict(self, strict)

    def read(self, shouldWait=True):
        r"""read(TypedReaderImageFloat self, bool shouldWait=True) -> ImageFloat"""
        return _yarp.TypedReaderImageFloat_read(self, shouldWait)

    def interrupt(self):
        r"""interrupt(TypedReaderImageFloat self)"""
        return _yarp.TypedReaderImageFloat_interrupt(self)

    def lastRead(self):
        r"""lastRead(TypedReaderImageFloat self) -> ImageFloat"""
        return _yarp.TypedReaderImageFloat_lastRead(self)

    def isClosed(self):
        r"""isClosed(TypedReaderImageFloat self) -> bool"""
        return _yarp.TypedReaderImageFloat_isClosed(self)

    def useCallback(self, callback):
        r"""useCallback(TypedReaderImageFloat self, TypedReaderCallbackImageFloat callback)"""
        return _yarp.TypedReaderImageFloat_useCallback(self, callback)

    def disableCallback(self):
        r"""disableCallback(TypedReaderImageFloat self)"""
        return _yarp.TypedReaderImageFloat_disableCallback(self)

    def getPendingReads(self):
        r"""getPendingReads(TypedReaderImageFloat self) -> int"""
        return _yarp.TypedReaderImageFloat_getPendingReads(self)
    __swig_destroy__ = _yarp.delete_TypedReaderImageFloat

    def getName(self):
        r"""getName(TypedReaderImageFloat self) -> std::string"""
        return _yarp.TypedReaderImageFloat_getName(self)

    def setReplier(self, reader):
        r"""setReplier(TypedReaderImageFloat self, PortReader reader)"""
        return _yarp.TypedReaderImageFloat_setReplier(self, reader)

    def acquire(self):
        r"""acquire(TypedReaderImageFloat self) -> void *"""
        return _yarp.TypedReaderImageFloat_acquire(self)

    def release(self, handle):
        r"""release(TypedReaderImageFloat self, void * handle)"""
        return _yarp.TypedReaderImageFloat_release(self, handle)

    def setTargetPeriod(self, period):
        r"""setTargetPeriod(TypedReaderImageFloat self, double period)"""
        return _yarp.TypedReaderImageFloat_setTargetPeriod(self, period)

# Register TypedReaderImageFloat in _yarp:
_yarp.TypedReaderImageFloat_swigregister(TypedReaderImageFloat)

class TypedReaderCallbackImageFloat(object):
    r"""Proxy of C++ yarp::os::TypedReaderCallback< yarp::sig::ImageOf< yarp::sig::PixelFloat > > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _yarp.delete_TypedReaderCallbackImageFloat

    def onRead(self, *args):
        r"""
        onRead(TypedReaderCallbackImageFloat self, ImageFloat datum)
        onRead(TypedReaderCallbackImageFloat self, ImageFloat datum, TypedReaderImageFloat reader)
        """
        return _yarp.TypedReaderCallbackImageFloat_onRead(self, *args)

    def __init__(self):
        r"""__init__(TypedReaderCallbackImageFloat self) -> TypedReaderCallbackImageFloat"""
        _yarp.TypedReaderCallbackImageFloat_swiginit(self, _yarp.new_TypedReaderCallbackImageFloat())

# Register TypedReaderCallbackImageFloat in _yarp:
_yarp.TypedReaderCallbackImageFloat_swigregister(TypedReaderCallbackImageFloat)

class BufferedPortImageFloat(Contactable, TypedReaderImageFloat, TypedReaderCallbackImageFloat):
    r"""Proxy of C++ yarp::os::BufferedPort< yarp::sig::ImageOf< yarp::sig::PixelFloat > > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        __init__(BufferedPortImageFloat self) -> BufferedPortImageFloat
        __init__(BufferedPortImageFloat self, Port port) -> BufferedPortImageFloat
        """
        _yarp.BufferedPortImageFloat_swiginit(self, _yarp.new_BufferedPortImageFloat(*args))
    __swig_destroy__ = _yarp.delete_BufferedPortImageFloat

    def addOutput(self, *args):
        r"""
        addOutput(BufferedPortImageFloat self, std::string const & name) -> bool
        addOutput(BufferedPortImageFloat self, std::string const & name, std::string const & carrier) -> bool
        addOutput(BufferedPortImageFloat self, Contact contact) -> bool
        """
        return _yarp.BufferedPortImageFloat_addOutput(self, *args)

    def close(self):
        r"""close(BufferedPortImageFloat self)"""
        return _yarp.BufferedPortImageFloat_close(self)

    def interrupt(self):
        r"""interrupt(BufferedPortImageFloat self)"""
        return _yarp.BufferedPortImageFloat_interrupt(self)

    def resume(self):
        r"""resume(BufferedPortImageFloat self)"""
        return _yarp.BufferedPortImageFloat_resume(self)

    def getPendingReads(self):
        r"""getPendingReads(BufferedPortImageFloat self) -> int"""
        return _yarp.BufferedPortImageFloat_getPendingReads(self)

    def where(self):
        r"""where(BufferedPortImageFloat self) -> Contact"""
        return _yarp.BufferedPortImageFloat_where(self)

    def getName(self):
        r"""getName(BufferedPortImageFloat self) -> std::string"""
        return _yarp.BufferedPortImageFloat_getName(self)

    def prepare(self):
        r"""prepare(BufferedPortImageFloat self) -> ImageFloat"""
        return _yarp.BufferedPortImageFloat_prepare(self)

    def unprepare(self):
        r"""unprepare(BufferedPortImageFloat self) -> bool"""
        return _yarp.BufferedPortImageFloat_unprepare(self)

    def write(self, forceStrict=False):
        r"""write(BufferedPortImageFloat self, bool forceStrict=False)"""
        return _yarp.BufferedPortImageFloat_write(self, forceStrict)

    def writeStrict(self):
        r"""writeStrict(BufferedPortImageFloat self)"""
        return _yarp.BufferedPortImageFloat_writeStrict(self)

    def waitForWrite(self):
        r"""waitForWrite(BufferedPortImageFloat self)"""
        return _yarp.BufferedPortImageFloat_waitForWrite(self)

    def setStrict(self, strict=True):
        r"""setStrict(BufferedPortImageFloat self, bool strict=True)"""
        return _yarp.BufferedPortImageFloat_setStrict(self, strict)

    def read(self, shouldWait=True):
        r"""read(BufferedPortImageFloat self, bool shouldWait=True) -> ImageFloat"""
        return _yarp.BufferedPortImageFloat_read(self, shouldWait)

    def lastRead(self):
        r"""lastRead(BufferedPortImageFloat self) -> ImageFloat"""
        return _yarp.BufferedPortImageFloat_lastRead(self)

    def isClosed(self):
        r"""isClosed(BufferedPortImageFloat self) -> bool"""
        return _yarp.BufferedPortImageFloat_isClosed(self)

    def setReplier(self, reader):
        r"""setReplier(BufferedPortImageFloat self, PortReader reader)"""
        return _yarp.BufferedPortImageFloat_setReplier(self, reader)

    def setReader(self, reader):
        r"""setReader(BufferedPortImageFloat self, PortReader reader)"""
        return _yarp.BufferedPortImageFloat_setReader(self, reader)

    def setAdminReader(self, reader):
        r"""setAdminReader(BufferedPortImageFloat self, PortReader reader)"""
        return _yarp.BufferedPortImageFloat_setAdminReader(self, reader)

    def onRead(self, *args):
        r"""
        onRead(BufferedPortImageFloat self, ImageFloat datum, TypedReaderImageFloat reader)
        onRead(BufferedPortImageFloat self, ImageFloat datum)
        """
        return _yarp.BufferedPortImageFloat_onRead(self, *args)

    def useCallback(self, *args):
        r"""
        useCallback(BufferedPortImageFloat self, TypedReaderCallbackImageFloat callback)
        useCallback(BufferedPortImageFloat self)
        """
        return _yarp.BufferedPortImageFloat_useCallback(self, *args)

    def disableCallback(self):
        r"""disableCallback(BufferedPortImageFloat self)"""
        return _yarp.BufferedPortImageFloat_disableCallback(self)

    def setEnvelope(self, envelope):
        r"""setEnvelope(BufferedPortImageFloat self, PortWriter envelope) -> bool"""
        return _yarp.BufferedPortImageFloat_setEnvelope(self, envelope)

    def getEnvelope(self, envelope):
        r"""getEnvelope(BufferedPortImageFloat self, PortReader envelope) -> bool"""
        return _yarp.BufferedPortImageFloat_getEnvelope(self, envelope)

    def getInputCount(self):
        r"""getInputCount(BufferedPortImageFloat self) -> int"""
        return _yarp.BufferedPortImageFloat_getInputCount(self)

    def getOutputCount(self):
        r"""getOutputCount(BufferedPortImageFloat self) -> int"""
        return _yarp.BufferedPortImageFloat_getOutputCount(self)

    def isWriting(self):
        r"""isWriting(BufferedPortImageFloat self) -> bool"""
        return _yarp.BufferedPortImageFloat_isWriting(self)

    def getReport(self, reporter):
        r"""getReport(BufferedPortImageFloat self, PortReport reporter)"""
        return _yarp.BufferedPortImageFloat_getReport(self, reporter)

    def setReporter(self, reporter):
        r"""setReporter(BufferedPortImageFloat self, PortReport reporter)"""
        return _yarp.BufferedPortImageFloat_setReporter(self, reporter)

    def resetReporter(self):
        r"""resetReporter(BufferedPortImageFloat self)"""
        return _yarp.BufferedPortImageFloat_resetReporter(self)

    def acquire(self):
        r"""acquire(BufferedPortImageFloat self) -> void *"""
        return _yarp.BufferedPortImageFloat_acquire(self)

    def release(self, handle):
        r"""release(BufferedPortImageFloat self, void * handle)"""
        return _yarp.BufferedPortImageFloat_release(self, handle)

    def setTargetPeriod(self, period):
        r"""setTargetPeriod(BufferedPortImageFloat self, double period)"""
        return _yarp.BufferedPortImageFloat_setTargetPeriod(self, period)

    def getType(self):
        r"""getType(BufferedPortImageFloat self) -> yarp::os::Type"""
        return _yarp.BufferedPortImageFloat_getType(self)

    def promiseType(self, typ):
        r"""promiseType(BufferedPortImageFloat self, yarp::os::Type const & typ)"""
        return _yarp.BufferedPortImageFloat_promiseType(self, typ)

    def setInputMode(self, expectInput):
        r"""setInputMode(BufferedPortImageFloat self, bool expectInput)"""
        return _yarp.BufferedPortImageFloat_setInputMode(self, expectInput)

    def setOutputMode(self, expectOutput):
        r"""setOutputMode(BufferedPortImageFloat self, bool expectOutput)"""
        return _yarp.BufferedPortImageFloat_setOutputMode(self, expectOutput)

    def setRpcMode(self, expectRpc):
        r"""setRpcMode(BufferedPortImageFloat self, bool expectRpc)"""
        return _yarp.BufferedPortImageFloat_setRpcMode(self, expectRpc)

    def acquireProperties(self, readOnly):
        r"""acquireProperties(BufferedPortImageFloat self, bool readOnly) -> Property"""
        return _yarp.BufferedPortImageFloat_acquireProperties(self, readOnly)

    def releaseProperties(self, prop):
        r"""releaseProperties(BufferedPortImageFloat self, Property prop)"""
        return _yarp.BufferedPortImageFloat_releaseProperties(self, prop)

    def includeNodeInName(self, flag):
        r"""includeNodeInName(BufferedPortImageFloat self, bool flag)"""
        return _yarp.BufferedPortImageFloat_includeNodeInName(self, flag)

    def setCallbackLock(self, *args):
        r"""
        setCallbackLock(BufferedPortImageFloat self, yarp::os::Mutex * mutex) -> bool
        setCallbackLock(BufferedPortImageFloat self, std::mutex * mutex) -> bool
        """
        return _yarp.BufferedPortImageFloat_setCallbackLock(self, *args)

    def removeCallbackLock(self):
        r"""removeCallbackLock(BufferedPortImageFloat self) -> bool"""
        return _yarp.BufferedPortImageFloat_removeCallbackLock(self)

    def lockCallback(self):
        r"""lockCallback(BufferedPortImageFloat self) -> bool"""
        return _yarp.BufferedPortImageFloat_lockCallback(self)

    def tryLockCallback(self):
        r"""tryLockCallback(BufferedPortImageFloat self) -> bool"""
        return _yarp.BufferedPortImageFloat_tryLockCallback(self)

    def unlockCallback(self):
        r"""unlockCallback(BufferedPortImageFloat self)"""
        return _yarp.BufferedPortImageFloat_unlockCallback(self)

# Register BufferedPortImageFloat in _yarp:
_yarp.BufferedPortImageFloat_swigregister(BufferedPortImageFloat)

class ImageRgbFloat(Image):
    r"""Proxy of C++ yarp::sig::ImageOf< yarp::sig::PixelRgbFloat > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        r"""__init__(ImageRgbFloat self) -> ImageRgbFloat"""
        _yarp.ImageRgbFloat_swiginit(self, _yarp.new_ImageRgbFloat())

    def getPixelSize(self):
        r"""getPixelSize(ImageRgbFloat self) -> size_t"""
        return _yarp.ImageRgbFloat_getPixelSize(self)

    def getPixelCode(self):
        r"""getPixelCode(ImageRgbFloat self) -> int"""
        return _yarp.ImageRgbFloat_getPixelCode(self)

    def pixel(self, *args):
        r"""
        pixel(ImageRgbFloat self, size_t x, size_t y) -> PixelRgbFloat
        pixel(ImageRgbFloat self, size_t x, size_t y) -> PixelRgbFloat
        """
        return _yarp.ImageRgbFloat_pixel(self, *args)

    def access(self, *args):
        r"""
        access(ImageRgbFloat self, size_t x, size_t y) -> PixelRgbFloat
        access(ImageRgbFloat self, size_t x, size_t y) -> PixelRgbFloat
        """
        return _yarp.ImageRgbFloat_access(self, *args)

    def safePixel(self, *args):
        r"""
        safePixel(ImageRgbFloat self, size_t x, size_t y) -> PixelRgbFloat
        safePixel(ImageRgbFloat self, size_t x, size_t y) -> PixelRgbFloat
        """
        return _yarp.ImageRgbFloat_safePixel(self, *args)
    __swig_destroy__ = _yarp.delete_ImageRgbFloat

# Register ImageRgbFloat in _yarp:
_yarp.ImageRgbFloat_swigregister(ImageRgbFloat)

class TypedReaderImageRgbFloat(object):
    r"""Proxy of C++ yarp::os::TypedReader< yarp::sig::ImageOf< yarp::sig::PixelRgbFloat > > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def setStrict(self, strict=True):
        r"""setStrict(TypedReaderImageRgbFloat self, bool strict=True)"""
        return _yarp.TypedReaderImageRgbFloat_setStrict(self, strict)

    def read(self, shouldWait=True):
        r"""read(TypedReaderImageRgbFloat self, bool shouldWait=True) -> ImageRgbFloat"""
        return _yarp.TypedReaderImageRgbFloat_read(self, shouldWait)

    def interrupt(self):
        r"""interrupt(TypedReaderImageRgbFloat self)"""
        return _yarp.TypedReaderImageRgbFloat_interrupt(self)

    def lastRead(self):
        r"""lastRead(TypedReaderImageRgbFloat self) -> ImageRgbFloat"""
        return _yarp.TypedReaderImageRgbFloat_lastRead(self)

    def isClosed(self):
        r"""isClosed(TypedReaderImageRgbFloat self) -> bool"""
        return _yarp.TypedReaderImageRgbFloat_isClosed(self)

    def useCallback(self, callback):
        r"""useCallback(TypedReaderImageRgbFloat self, TypedReaderCallbackImageRgbFloat callback)"""
        return _yarp.TypedReaderImageRgbFloat_useCallback(self, callback)

    def disableCallback(self):
        r"""disableCallback(TypedReaderImageRgbFloat self)"""
        return _yarp.TypedReaderImageRgbFloat_disableCallback(self)

    def getPendingReads(self):
        r"""getPendingReads(TypedReaderImageRgbFloat self) -> int"""
        return _yarp.TypedReaderImageRgbFloat_getPendingReads(self)
    __swig_destroy__ = _yarp.delete_TypedReaderImageRgbFloat

    def getName(self):
        r"""getName(TypedReaderImageRgbFloat self) -> std::string"""
        return _yarp.TypedReaderImageRgbFloat_getName(self)

    def setReplier(self, reader):
        r"""setReplier(TypedReaderImageRgbFloat self, PortReader reader)"""
        return _yarp.TypedReaderImageRgbFloat_setReplier(self, reader)

    def acquire(self):
        r"""acquire(TypedReaderImageRgbFloat self) -> void *"""
        return _yarp.TypedReaderImageRgbFloat_acquire(self)

    def release(self, handle):
        r"""release(TypedReaderImageRgbFloat self, void * handle)"""
        return _yarp.TypedReaderImageRgbFloat_release(self, handle)

    def setTargetPeriod(self, period):
        r"""setTargetPeriod(TypedReaderImageRgbFloat self, double period)"""
        return _yarp.TypedReaderImageRgbFloat_setTargetPeriod(self, period)

# Register TypedReaderImageRgbFloat in _yarp:
_yarp.TypedReaderImageRgbFloat_swigregister(TypedReaderImageRgbFloat)

class TypedReaderCallbackImageRgbFloat(object):
    r"""Proxy of C++ yarp::os::TypedReaderCallback< yarp::sig::ImageOf< yarp::sig::PixelRgbFloat > > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _yarp.delete_TypedReaderCallbackImageRgbFloat

    def onRead(self, *args):
        r"""
        onRead(TypedReaderCallbackImageRgbFloat self, ImageRgbFloat datum)
        onRead(TypedReaderCallbackImageRgbFloat self, ImageRgbFloat datum, TypedReaderImageRgbFloat reader)
        """
        return _yarp.TypedReaderCallbackImageRgbFloat_onRead(self, *args)

    def __init__(self):
        r"""__init__(TypedReaderCallbackImageRgbFloat self) -> TypedReaderCallbackImageRgbFloat"""
        _yarp.TypedReaderCallbackImageRgbFloat_swiginit(self, _yarp.new_TypedReaderCallbackImageRgbFloat())

# Register TypedReaderCallbackImageRgbFloat in _yarp:
_yarp.TypedReaderCallbackImageRgbFloat_swigregister(TypedReaderCallbackImageRgbFloat)

class BufferedPortImageRgbFloat(Contactable, TypedReaderImageRgbFloat, TypedReaderCallbackImageRgbFloat):
    r"""Proxy of C++ yarp::os::BufferedPort< yarp::sig::ImageOf< yarp::sig::PixelRgbFloat > > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        __init__(BufferedPortImageRgbFloat self) -> BufferedPortImageRgbFloat
        __init__(BufferedPortImageRgbFloat self, Port port) -> BufferedPortImageRgbFloat
        """
        _yarp.BufferedPortImageRgbFloat_swiginit(self, _yarp.new_BufferedPortImageRgbFloat(*args))
    __swig_destroy__ = _yarp.delete_BufferedPortImageRgbFloat

    def addOutput(self, *args):
        r"""
        addOutput(BufferedPortImageRgbFloat self, std::string const & name) -> bool
        addOutput(BufferedPortImageRgbFloat self, std::string const & name, std::string const & carrier) -> bool
        addOutput(BufferedPortImageRgbFloat self, Contact contact) -> bool
        """
        return _yarp.BufferedPortImageRgbFloat_addOutput(self, *args)

    def close(self):
        r"""close(BufferedPortImageRgbFloat self)"""
        return _yarp.BufferedPortImageRgbFloat_close(self)

    def interrupt(self):
        r"""interrupt(BufferedPortImageRgbFloat self)"""
        return _yarp.BufferedPortImageRgbFloat_interrupt(self)

    def resume(self):
        r"""resume(BufferedPortImageRgbFloat self)"""
        return _yarp.BufferedPortImageRgbFloat_resume(self)

    def getPendingReads(self):
        r"""getPendingReads(BufferedPortImageRgbFloat self) -> int"""
        return _yarp.BufferedPortImageRgbFloat_getPendingReads(self)

    def where(self):
        r"""where(BufferedPortImageRgbFloat self) -> Contact"""
        return _yarp.BufferedPortImageRgbFloat_where(self)

    def getName(self):
        r"""getName(BufferedPortImageRgbFloat self) -> std::string"""
        return _yarp.BufferedPortImageRgbFloat_getName(self)

    def prepare(self):
        r"""prepare(BufferedPortImageRgbFloat self) -> ImageRgbFloat"""
        return _yarp.BufferedPortImageRgbFloat_prepare(self)

    def unprepare(self):
        r"""unprepare(BufferedPortImageRgbFloat self) -> bool"""
        return _yarp.BufferedPortImageRgbFloat_unprepare(self)

    def write(self, forceStrict=False):
        r"""write(BufferedPortImageRgbFloat self, bool forceStrict=False)"""
        return _yarp.BufferedPortImageRgbFloat_write(self, forceStrict)

    def writeStrict(self):
        r"""writeStrict(BufferedPortImageRgbFloat self)"""
        return _yarp.BufferedPortImageRgbFloat_writeStrict(self)

    def waitForWrite(self):
        r"""waitForWrite(BufferedPortImageRgbFloat self)"""
        return _yarp.BufferedPortImageRgbFloat_waitForWrite(self)

    def setStrict(self, strict=True):
        r"""setStrict(BufferedPortImageRgbFloat self, bool strict=True)"""
        return _yarp.BufferedPortImageRgbFloat_setStrict(self, strict)

    def read(self, shouldWait=True):
        r"""read(BufferedPortImageRgbFloat self, bool shouldWait=True) -> ImageRgbFloat"""
        return _yarp.BufferedPortImageRgbFloat_read(self, shouldWait)

    def lastRead(self):
        r"""lastRead(BufferedPortImageRgbFloat self) -> ImageRgbFloat"""
        return _yarp.BufferedPortImageRgbFloat_lastRead(self)

    def isClosed(self):
        r"""isClosed(BufferedPortImageRgbFloat self) -> bool"""
        return _yarp.BufferedPortImageRgbFloat_isClosed(self)

    def setReplier(self, reader):
        r"""setReplier(BufferedPortImageRgbFloat self, PortReader reader)"""
        return _yarp.BufferedPortImageRgbFloat_setReplier(self, reader)

    def setReader(self, reader):
        r"""setReader(BufferedPortImageRgbFloat self, PortReader reader)"""
        return _yarp.BufferedPortImageRgbFloat_setReader(self, reader)

    def setAdminReader(self, reader):
        r"""setAdminReader(BufferedPortImageRgbFloat self, PortReader reader)"""
        return _yarp.BufferedPortImageRgbFloat_setAdminReader(self, reader)

    def onRead(self, *args):
        r"""
        onRead(BufferedPortImageRgbFloat self, ImageRgbFloat datum, TypedReaderImageRgbFloat reader)
        onRead(BufferedPortImageRgbFloat self, ImageRgbFloat datum)
        """
        return _yarp.BufferedPortImageRgbFloat_onRead(self, *args)

    def useCallback(self, *args):
        r"""
        useCallback(BufferedPortImageRgbFloat self, TypedReaderCallbackImageRgbFloat callback)
        useCallback(BufferedPortImageRgbFloat self)
        """
        return _yarp.BufferedPortImageRgbFloat_useCallback(self, *args)

    def disableCallback(self):
        r"""disableCallback(BufferedPortImageRgbFloat self)"""
        return _yarp.BufferedPortImageRgbFloat_disableCallback(self)

    def setEnvelope(self, envelope):
        r"""setEnvelope(BufferedPortImageRgbFloat self, PortWriter envelope) -> bool"""
        return _yarp.BufferedPortImageRgbFloat_setEnvelope(self, envelope)

    def getEnvelope(self, envelope):
        r"""getEnvelope(BufferedPortImageRgbFloat self, PortReader envelope) -> bool"""
        return _yarp.BufferedPortImageRgbFloat_getEnvelope(self, envelope)

    def getInputCount(self):
        r"""getInputCount(BufferedPortImageRgbFloat self) -> int"""
        return _yarp.BufferedPortImageRgbFloat_getInputCount(self)

    def getOutputCount(self):
        r"""getOutputCount(BufferedPortImageRgbFloat self) -> int"""
        return _yarp.BufferedPortImageRgbFloat_getOutputCount(self)

    def isWriting(self):
        r"""isWriting(BufferedPortImageRgbFloat self) -> bool"""
        return _yarp.BufferedPortImageRgbFloat_isWriting(self)

    def getReport(self, reporter):
        r"""getReport(BufferedPortImageRgbFloat self, PortReport reporter)"""
        return _yarp.BufferedPortImageRgbFloat_getReport(self, reporter)

    def setReporter(self, reporter):
        r"""setReporter(BufferedPortImageRgbFloat self, PortReport reporter)"""
        return _yarp.BufferedPortImageRgbFloat_setReporter(self, reporter)

    def resetReporter(self):
        r"""resetReporter(BufferedPortImageRgbFloat self)"""
        return _yarp.BufferedPortImageRgbFloat_resetReporter(self)

    def acquire(self):
        r"""acquire(BufferedPortImageRgbFloat self) -> void *"""
        return _yarp.BufferedPortImageRgbFloat_acquire(self)

    def release(self, handle):
        r"""release(BufferedPortImageRgbFloat self, void * handle)"""
        return _yarp.BufferedPortImageRgbFloat_release(self, handle)

    def setTargetPeriod(self, period):
        r"""setTargetPeriod(BufferedPortImageRgbFloat self, double period)"""
        return _yarp.BufferedPortImageRgbFloat_setTargetPeriod(self, period)

    def getType(self):
        r"""getType(BufferedPortImageRgbFloat self) -> yarp::os::Type"""
        return _yarp.BufferedPortImageRgbFloat_getType(self)

    def promiseType(self, typ):
        r"""promiseType(BufferedPortImageRgbFloat self, yarp::os::Type const & typ)"""
        return _yarp.BufferedPortImageRgbFloat_promiseType(self, typ)

    def setInputMode(self, expectInput):
        r"""setInputMode(BufferedPortImageRgbFloat self, bool expectInput)"""
        return _yarp.BufferedPortImageRgbFloat_setInputMode(self, expectInput)

    def setOutputMode(self, expectOutput):
        r"""setOutputMode(BufferedPortImageRgbFloat self, bool expectOutput)"""
        return _yarp.BufferedPortImageRgbFloat_setOutputMode(self, expectOutput)

    def setRpcMode(self, expectRpc):
        r"""setRpcMode(BufferedPortImageRgbFloat self, bool expectRpc)"""
        return _yarp.BufferedPortImageRgbFloat_setRpcMode(self, expectRpc)

    def acquireProperties(self, readOnly):
        r"""acquireProperties(BufferedPortImageRgbFloat self, bool readOnly) -> Property"""
        return _yarp.BufferedPortImageRgbFloat_acquireProperties(self, readOnly)

    def releaseProperties(self, prop):
        r"""releaseProperties(BufferedPortImageRgbFloat self, Property prop)"""
        return _yarp.BufferedPortImageRgbFloat_releaseProperties(self, prop)

    def includeNodeInName(self, flag):
        r"""includeNodeInName(BufferedPortImageRgbFloat self, bool flag)"""
        return _yarp.BufferedPortImageRgbFloat_includeNodeInName(self, flag)

    def setCallbackLock(self, *args):
        r"""
        setCallbackLock(BufferedPortImageRgbFloat self, yarp::os::Mutex * mutex) -> bool
        setCallbackLock(BufferedPortImageRgbFloat self, std::mutex * mutex) -> bool
        """
        return _yarp.BufferedPortImageRgbFloat_setCallbackLock(self, *args)

    def removeCallbackLock(self):
        r"""removeCallbackLock(BufferedPortImageRgbFloat self) -> bool"""
        return _yarp.BufferedPortImageRgbFloat_removeCallbackLock(self)

    def lockCallback(self):
        r"""lockCallback(BufferedPortImageRgbFloat self) -> bool"""
        return _yarp.BufferedPortImageRgbFloat_lockCallback(self)

    def tryLockCallback(self):
        r"""tryLockCallback(BufferedPortImageRgbFloat self) -> bool"""
        return _yarp.BufferedPortImageRgbFloat_tryLockCallback(self)

    def unlockCallback(self):
        r"""unlockCallback(BufferedPortImageRgbFloat self)"""
        return _yarp.BufferedPortImageRgbFloat_unlockCallback(self)

# Register BufferedPortImageRgbFloat in _yarp:
_yarp.BufferedPortImageRgbFloat_swigregister(BufferedPortImageRgbFloat)




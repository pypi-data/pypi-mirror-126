Metadata-Version: 2.1
Name: climatik
Version: 0.2.0
Summary: Create command line interface from function definitions.
Home-page: https://git.sr.ht/~fabrixxm/climatik
Author: Fabio Comuni
Author-email: fabrix.xm+pypi@gmail.com
License: GPLv3+
Platform: UNKNOWN
Classifier: Development Status :: 3 - Alpha
Classifier: Intended Audience :: Developers
Classifier: License :: OSI Approved :: GNU General Public License v3 or later (GPLv3+)
Classifier: Programming Language :: Python :: 3
Classifier: Programming Language :: Python :: 3.9
Description-Content-Type: text/markdown
License-File: COPYING

Create command line interface from function definitions.

Each function will be a subcommand of your application.

*Climatik* define a function decorator which parse function definition and build
a subcommand command line parser.


## Docs

### def command(fnc:Callable)

Build subcommand from function

Subcommand name will be the function name and arguments are parsed to build the command line.

Each positional argument will be a positional paramenter.

Each optional argument will be an optional flag.

Type hints are used to covert types from command line string.

An argument with `bool` type is converted to an optional flag parameter (with default sematic as "False")

To create an optional positional paramenter, use the `Positional` custom type as hint, which optionally can get 
a type too, eg `Positional[str]`

Function docstring is used to set command's help and description.


    @command
    def one(name, debug:bool, value="default", switchoff=True):
        "First subcommand"
        ...

    @command
    def two(name:Positional[str] = None, long_param = None):
        "Second subcommand"
        ...

gives:

    $ script -h
    usage: script [-h] {one,two} ...

    positional arguments:
    {one,two}
        one       First subcommand
        two       Second subcommand

    optional arguments:
    -h, --help  show this help message and exit

    $Â script one -h
    usage: script one [-h] [--debug] [--value VALUE] [--switchoff] name

    First subcommand

    positional arguments:
    name

    optional arguments:
    -h, --help     show this help message and exit
    --debug
    --value VALUE
    --switchoff

    $ script two -h
    usage: script two [-h] [--long-param LONG_PARAM] [name]

    Second subcommand

    positional arguments:
    name

    optional arguments:
    -h, --help            show this help message and exit
    --long-param LONG_PARAM

### def run(prog:str=None, usage:str=None, description:str=None, **kwargs)

Run your application.

Builds the command line parse, with given arguments, and execute the requested 
function. It's a shorthand for

    parser = build_parser(prog, usage, description, **kwargs)
    execute(parser)


### def execute(parser:argparse.ArgumentParser)

Execute command line from given parser


### def get_parser(*args, **kwargs) -> argparse.ArgumentParser:

Build the command line parser

Arguments are passed to `argparse.ArgumentParser` constructor



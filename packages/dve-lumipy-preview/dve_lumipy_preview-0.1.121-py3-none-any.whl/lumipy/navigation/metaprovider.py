import inspect
import warnings
from abc import ABCMeta
from typing import Type, Callable, List

from lumipy.client import Client
from lumipy.common.string_utils import indent_str
from lumipy.navigation.field_metadata import FieldMetadata
from lumipy.navigation.provider_metadata import ProviderMetadata
from lumipy.query.expression.column.source_column import SourceColumn
from lumipy.query.expression.sql_value_type import SqlValType
from lumipy.query.expression.table.base_source_table import BaseSourceTable


# noinspection PyArgumentList,PyMethodParameters,PyTypeChecker
class MetaProvider(ABCMeta):
    """Metaclass of all provider classes (generates inheritors of BaseSourceTable given provider metadata).
    Each provider source table class is an instance of this metaclass.
    This approach allows the __init__ method of these classes to be altered to show the parameters they take and to
    generate a docstring for them from a ProviderDefinition. This is so it shows up in help() and shift+tab tooltips in
    Jupyter.

    """

    def __new__(cls, provider_metadata: ProviderMetadata) -> Type[BaseSourceTable]:

        """Build a new instance of the metaclass (a provider table class that inherits from BaseSourceTable)

        Args:
            provider_metadata:
                A provider metadata object defining the features of the provider we are building a
                source table class for.
        Returns:
            BaseSourceTable: the provider source table class.
        """

        cls._class_name = provider_metadata.get_table_name().replace('.', '')

        params = provider_metadata.list_parameters()
        class_attributes = {
            '_table_name': provider_metadata.get_table_name(),
            '_provider_metadata': provider_metadata,
            '_params': {param.name: param for param in params},
            '__init__': cls._make_ctor(cls, provider_metadata=provider_metadata),
            '__doc__': f"Class representing the {provider_metadata.get_table_name()} data provider.\n"
                       f"{provider_metadata.get_description()}",
            '_client': provider_metadata.get_client()
        }
        for c in provider_metadata.list_fields():
            class_attributes[c.get_name()] = c

        return super().__new__(cls, cls._class_name, (BaseSourceTable,), class_attributes)

    def _make_ctor(cls, provider_metadata: ProviderMetadata) -> Callable:
        """Build a replacement __init__ method for the provider source table class.

        Args:
            provider_metadata:
                A provider description object defining the features of the provider we are building a
                source table class for.
        Returns:
            Function that acts as a replacement class constructor in the provider source table class
            being built by this metaclass.

        """
        # Build ctor that takes prov params and assigns inst attrs
        from lumipy.query.expression.table.table_parameter_assignment import ParameterAssignment

        ctor_params = provider_metadata.list_parameters()
        param_names = [p.name for p in ctor_params]

        # Define the constructor function. This will be modified to document the class
        # generated by this metaclass.
        def __init__(self, **ctor_kwargs):
            param_assignments = {}
            for k, v in ctor_kwargs.items():
                if k not in param_names:
                    msg = f"'{k}' is not a parameter of the {type(self).__name__} data provider class.\n"
                    if len(param_names) > 0:
                        msg += f"Valid parameters are {', '.join(param_names)}."
                    else:
                        msg += f"This provider class does not have any parameters: try doing 'provider()'."
                    raise ValueError(
                        msg
                    )
                p_description = self._params[k]
                param_assignments[k] = ParameterAssignment(p_description, v)

            lineage = list(param_assignments.values())
            lineage.append(provider_metadata)
            table_hash = hash(sum(hash(p) for p in lineage))

            columns = [
                SourceColumn(c, table_hash, with_brackets=True)
                for c in provider_metadata.list_columns()
            ]
            # Call constructor of the base class to actually build the instance of the provider source
            # table class.
            super(type(self), self).__init__(
                provider_metadata.get_table_name(),
                columns,
                provider_metadata.get_client(),
                'define provider table',
                param_assignments,
                *lineage
            )

        # Alter the constructor's signature to match input params. This will allow the user to use help() or
        # shift+tab in jupyter to inspect it.
        params = [inspect.Parameter(
            param,
            inspect.Parameter.POSITIONAL_OR_KEYWORD
        ) for param in ['self'] + param_names]
        __init__.__signature__ = inspect.Signature(params)

        # Generate docstring and add it to the ctor
        doc_top_line = f'{cls._class_name} source table:'
        doc_parts = ['__init__ Parameters:']
        for p in ctor_params:
            if isinstance(p.description, str) and len(p.description) > 0:
                description = p.description
            else:
                description = '[Parameter description not available.]'
            param_doc = f"{p.name}:\n  DataType: {p.data_type.name}\n  Description: {description}"
            doc_parts.append(indent_str(param_doc, 2))
        doc_body = indent_str('\n'.join(doc_parts), 2)
        __init__.__doc__ = f"{doc_top_line}\n{doc_body}"

        return __init__

    def __str__(cls) -> str:
        return cls._provider_metadata.__str__()

    def _mini_str(cls) -> str:
        return cls._provider_metadata.__str__(True)

    def __repr__(cls, mini_str=False) -> str:
        return cls._provider_metadata.__str__(mini_str=mini_str)

    def list_fields(cls) -> List[FieldMetadata]:
        return cls._provider_metadata.list_fields()

    def list_columns(cls) -> List[FieldMetadata]:
        return cls._provider_metadata.list_columns()

    def list_parameters(cls) -> List[FieldMetadata]:
        return cls._provider_metadata.list_parameters()

    def get_client(cls) -> Client:
        return cls._provider_metadata.get_client()

    def get_name(cls) -> str:
        return cls._provider_metadata.get_name()

    def get_table_name(cls) -> str:
        return cls._provider_metadata.get_table_name()

    def get_type(cls) -> SqlValType:
        return cls._provider_metadata.get_type()

    def get_description(cls) -> str:
        return cls._provider_metadata.get_description()

    def get_class(cls) -> Type[BaseSourceTable]:
        warnings.warn(
            "The atlas method get_class() is deprecated and will be removed in a later version. "
            "Use 'atlas.provider' instead of 'atlas.provider.get_class()' to get the provider class.",
        )
        return cls

    def get_metadata(cls) -> ProviderMetadata:
        return cls._provider_metadata

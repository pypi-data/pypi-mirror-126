Metadata-Version: 2.1
Name: rapidyaml
Version: 0.2.3
Summary: Rapid YAML - a library to parse and emit YAML, and do it fast
Home-page: https://github.com/biojppm/rapidyaml
Author: Joao Paulo Magalhaes
Author-email: dev@jpmag.me
License: MIT
Platform: UNKNOWN
Requires-Python: >=3.6
Description-Content-Type: text/markdown
License-File: LICENSE.txt

# Rapid YAML
[![MIT Licensed](https://img.shields.io/badge/License-MIT-green.svg)](https://github.com/biojppm/rapidyaml/blob/master/LICENSE.txt)
[![release](https://img.shields.io/github/v/release/biojppm/rapidyaml?color=g&include_prereleases&label=release%20&sort=semver)](https://github.com/biojppm/rapidyaml/releases)
[![PyPI](https://img.shields.io/pypi/v/rapidyaml?color=g)](https://pypi.org/project/rapidyaml/)
[![Docs](https://img.shields.io/badge/docs-docsforge-blue)](https://rapidyaml.docsforge.com/)
[![Gitter](https://badges.gitter.im/rapidyaml/community.svg)](https://gitter.im/rapidyaml/community)

[![test](https://github.com/biojppm/rapidyaml/workflows/test/badge.svg?branch=master)](https://github.com/biojppm/rapidyaml/actions)
[![Coveralls](https://coveralls.io/repos/github/biojppm/rapidyaml/badge.svg?branch=master)](https://coveralls.io/github/biojppm/rapidyaml)
[![Codecov](https://codecov.io/gh/biojppm/rapidyaml/branch/master/graph/badge.svg?branch=master)](https://codecov.io/gh/biojppm/rapidyaml)
[![Total alerts](https://img.shields.io/lgtm/alerts/g/biojppm/rapidyaml.svg?logo=lgtm&logoWidth=18)](https://lgtm.com/projects/g/biojppm/rapidyaml/alerts/)
[![Language grade: C/C++](https://img.shields.io/lgtm/grade/cpp/g/biojppm/rapidyaml.svg?logo=lgtm&logoWidth=18)](https://lgtm.com/projects/g/biojppm/rapidyaml/context:cpp)


Or ryml, for short. ryml is a library to parse and emit YAML, and do it fast.

ryml parses both read-only and in-situ source buffers; the resulting data
nodes hold only views to sub-ranges of the source buffer. No string copies or
duplications are done, and no virtual functions are used. The data tree is a
flat index-based structure stored in a single array. Serialization happens
only at your direct request, after parsing / before emitting. Internally the
data tree representation has no knowledge of types (but of course, every node
can have a YAML type tag). It is easy and fast to read, write and iterate
through the data tree.

ryml can use custom global and per-tree memory allocators, and is
exception-agnostic. Errors are reported via a custom error handler callback.
A default error handler implementation using `std::abort()` is provided, but
you can opt out, or provide your exception-throwing callback.

ryml has respect for your compilation times and therefore it is NOT
header-only. It uses standard cmake build files, so it is easy to compile and
install.

ryml has no dependencies, not even on the STL (although it does use the
libc). It provides optional headers that let you serialize/deserialize
STL strings and containers (or show you how to do it).

ryml is written in C++11, and compiles cleanly with:
* Visual Studio 2015 and later
* clang++ 3.9 and later
* g++ 5 and later
* Intel Compiler

ryml is [extensively unit-tested in Linux, Windows and
MacOS](https://github.com/biojppm/rapidyaml/actions). The
tests cover x64, x86, arm, aarch64, ppc64le and s390x architectures,
and include analysing ryml with:
  * valgrind
  * clang-tidy
  * clang sanitizers:
    * memory
    * address
    * undefined behavior
    * thread
  * [LGTM.com](https://lgtm.com/projects/g/biojppm/rapidyaml)

ryml is also [available in
Python](https://pypi.org/project/rapidyaml/), with more languages to
follow (see below).

See also [the changelog](./changelog) and [the roadmap](./ROADMAP.md).




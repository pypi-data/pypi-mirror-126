{"version":3,"file":"node_modules_polusai_jupyterlab-rjsf_lib_fields_jsonobject_index_js.79c7be949f317b358918.js","mappings":";;;;;;;;;;;;;;;;;;;AAA+B;AAC/B;AACA;AACgD;AACC;AACL;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,4CAA4C;AAChF;AACA;AACA,oCAAoC,sCAAsC;AAC1E;AACA;AACA;AACA;AACA,oBAAoB,+CAA+C,gEAA4B,MAAM;AACrG,oBAAoB,cAAc;AAClC,2BAA2B,4DAAwB;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,UAAU;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,gDAAmB,CAAC,2CAAc;AACtD,gBAAgB,gDAAmB;AACnC,gBAAgB,gDAAmB,QAAQ,gCAAgC;AAC3E,gBAAgB,gDAAmB,UAAU,+CAA+C;AAC5F,oBAAoB,gDAAmB,aAAa,OAAO,aAAa,yHAAyH;AACjM,oBAAoB,gDAAmB,aAAa,OAAO,aAAa,mIAAmI;AAC3M,gBAAgB,gDAAmB,UAAU,kBAAkB;AAC/D,oBAAoB,gDAAmB,CAAC,2DAAY,IAAI,0IAA0I;AAClM;AACA;AACA;AACA;AACA,iBAAiB,gEAAiB;AAClC;AACA;AACA;AACA;AACA","sources":["webpack://jupyterlab_wipp_plugin_creator/./node_modules/@polusai/jupyterlab-rjsf/lib/fields/jsonobject/index.js"],"sourcesContent":["import * as React from 'react';\n/* order might matter on these imports */\n/* first core... */\nimport { utils as rjsfUtils } from '@rjsf/core';\nimport { UnControlled } from 'react-codemirror2';\nimport { JSONExt } from '@lumino/coreutils';\n/**\n * This is a pretty nasty way to deal with the ObjectField being very hard\n * to reach at import time\n *\n * We use the upstream ObjectField at runtime to construct a private class.\n * This could likely be improved with a namespace or something.\n */\nexport function makeJSONObjectField(ObjectField) {\n    /**\n     * A raw JSON Object which can be stored/edited inside an RJSF\n     */\n    class JSONObjectField extends ObjectField {\n        constructor() {\n            super(...arguments);\n            this.onReset = () => {\n                this._editor.getDoc().setValue(JSON.stringify(this.props.formData, null, 2));\n            };\n            this.onSave = () => {\n                this.props.onChange(this.state.editorValue);\n            };\n            this.onChange = (editor, data, value) => {\n                try {\n                    const jsonValue = JSON.parse(value);\n                    this.setState({ editorValue: jsonValue, editorError: false });\n                }\n                catch (err) {\n                    this.setState({ editorValue: null, editorError: true });\n                }\n            };\n        }\n        render() {\n            const { uiSchema, formData, idSchema, name, registry = rjsfUtils.getDefaultRegistry(), } = this.props;\n            const { definitions } = registry;\n            const schema = rjsfUtils.retrieveSchema(this.props.schema, definitions, formData);\n            let title;\n            if (this.state.wasPropertyKeyModified) {\n                title = name;\n            }\n            else {\n                title = schema.title === undefined ? name : schema.title;\n            }\n            const isLight = !!document.querySelector('body[data-jp-theme-light=\"true\"]');\n            const description = uiSchema['ui:description'] || schema.description;\n            const { canSave } = this;\n            const options = {\n                mode: 'application/json',\n                theme: isLight ? 'default' : 'zenburn',\n                matchBrackets: true,\n                autoCloseBrackets: true,\n            };\n            return (React.createElement(React.Fragment, null,\n                React.createElement(\"legend\", null, title),\n                React.createElement(\"p\", { className: \"field-description\" }, description),\n                React.createElement(\"div\", { className: \"jp-SchemaForm-JSONObject-buttons\" },\n                    React.createElement(\"button\", { id: `${idSchema.$id}_revert`, className: \"jp-JSONEditor-revertButton\", title: \"Revert to Previous Notebook Metadata\", onClick: this.onReset }),\n                    React.createElement(\"button\", { id: `${idSchema.$id}_commit`, disabled: !canSave, className: \"jp-JSONEditor-commitButton\", title: \"Commit to Notebook Metadata\", onClick: this.onSave })),\n                React.createElement(\"div\", { id: idSchema.$id },\n                    React.createElement(UnControlled, { editorDidMount: (editor) => (this._editor = editor), value: JSON.stringify(formData, null, 2), options: options, onChange: this.onChange }))));\n        }\n        get canSave() {\n            return (!this.state.editorError &&\n                this.state.editorValue &&\n                !JSONExt.deepEqual(this.state.editorValue, this.props.formData));\n        }\n    }\n    return JSONObjectField;\n}\n//# sourceMappingURL=index.js.map"],"names":[],"sourceRoot":""}
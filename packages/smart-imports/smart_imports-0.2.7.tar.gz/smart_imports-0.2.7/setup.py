# -*- coding: utf-8 -*-
from setuptools import setup

packages = \
['smart_imports',
 'smart_imports.plugins',
 'smart_imports.tests',
 'smart_imports.tests.fixtures.python_3_10',
 'smart_imports.tests.fixtures.python_3_5',
 'smart_imports.tests.fixtures.python_3_6',
 'smart_imports.tests.fixtures.python_3_7',
 'smart_imports.tests.fixtures.python_3_8',
 'smart_imports.tests.fixtures.python_3_9']

package_data = \
{'': ['*'],
 'smart_imports': ['fixtures/python_3_10_packages.txt',
                   'fixtures/python_3_10_packages.txt',
                   'fixtures/python_3_10_packages.txt',
                   'fixtures/python_3_10_packages.txt',
                   'fixtures/python_3_10_packages.txt',
                   'fixtures/python_3_10_packages.txt',
                   'fixtures/python_3_5_packages.txt',
                   'fixtures/python_3_5_packages.txt',
                   'fixtures/python_3_5_packages.txt',
                   'fixtures/python_3_5_packages.txt',
                   'fixtures/python_3_5_packages.txt',
                   'fixtures/python_3_5_packages.txt',
                   'fixtures/python_3_6_packages.txt',
                   'fixtures/python_3_6_packages.txt',
                   'fixtures/python_3_6_packages.txt',
                   'fixtures/python_3_6_packages.txt',
                   'fixtures/python_3_6_packages.txt',
                   'fixtures/python_3_6_packages.txt',
                   'fixtures/python_3_7_packages.txt',
                   'fixtures/python_3_7_packages.txt',
                   'fixtures/python_3_7_packages.txt',
                   'fixtures/python_3_7_packages.txt',
                   'fixtures/python_3_7_packages.txt',
                   'fixtures/python_3_7_packages.txt',
                   'fixtures/python_3_8_packages.txt',
                   'fixtures/python_3_8_packages.txt',
                   'fixtures/python_3_8_packages.txt',
                   'fixtures/python_3_8_packages.txt',
                   'fixtures/python_3_8_packages.txt',
                   'fixtures/python_3_8_packages.txt',
                   'fixtures/python_3_9_packages.txt',
                   'fixtures/python_3_9_packages.txt',
                   'fixtures/python_3_9_packages.txt',
                   'fixtures/python_3_9_packages.txt',
                   'fixtures/python_3_9_packages.txt',
                   'fixtures/python_3_9_packages.txt']}

setup_kwargs = {
    'name': 'smart-imports',
    'version': '0.2.7',
    'description': 'Automatic importing for Python modules.',
    'long_description': '\n=========================\n Smart import for Python\n=========================\n\n|pypi| |python_versions|\n\n- `Changelog <https://github.com/Tiendil/smart-imports/blob/develop/CHANGELOG.rst>`_\n\nAutomatically discovers & imports entities, used in the current module.\n\nNo magic or monkey patching. Only standard Python functionality.\n\n+---------------------------------------------+---------------------------------------------+\n| Before                                      | After                                       |\n+=============================================+=============================================+\n|.. code:: python                             |.. code:: python                             |\n|                                             |                                             |\n|    import math                              |    import smart_imports                     |\n|    from my_project import calc              |    smart_imports.all()                      |\n|    # 100500 other imports                   |    # no any other imports                   |\n|                                             |                                             |\n|    def my_code(argument, function=calc):    |    def my_code(argument, function=calc):    |\n|        return math.log(function(argument))  |        return math.log(function(argument))  |\n|                                             |                                             |\n+---------------------------------------------+---------------------------------------------+\n\n`MyPy`_ supported.\n\nSummary\n=======\n\n* Get source code of the module, from which ``smart_imports.all()`` has called.\n* Parse it, find all not initialized variables.\n* Search imports, suitable for found variables.\n* Import them.\n\nLibrary process only modules, from which ``smart_imports`` called explicitly.\n\nMain idea\n=========\n\nWith time every complex project develops own naming convention. If we translate that convention into more formal rules, we will be able to make automatic imports of every entity, knowing only its name.\n\nFor example, we will not need to write ``import math`` to call ``math.pi``, since our system will understand that ``math`` is the module of the standard library.\n\nHow it works\n============\n\nCode from the header works in such way:\n\n- ``smart_imports.all()`` builds `AST <https://en.wikipedia.org/wiki/Abstract_syntax_tree>`_ of the module from which it has called.\n- Library analyses AST and searches for not initialized variables.\n- Name of every found variable processed thought chain of rules to determine the correct module (or its attribute) to import. If the rule finds the target module, chain breaks and the next rules will not be processed.\n- Library load found modules and add imported entities into the global namespace.\n\n``Smart Imports`` searches not initialized variables in every part of code (including new Python syntax).\n\nAutomatic importing turns on only for modules, that do explicit call of ``smart_imports.all()``.\n\nMoreover, you can use normal imports with ``Smart Imports`` at the same time. That helps to integrate ``Smart Imports`` step by step.\n\nYou can notice, that AST of module builts two times:\n\n- when CPython imports module;\n- when ``Smart Imports`` process call of ``smart_imports.all()``.\n\nWe can build AST once (for that we can add hook into the process of importing modules with help of `PEP-0302 <https://www.python.org/dev/peps/pep-0302/>`_), but it will make import event slower. I think that it is because at import time CPython builds AST in terms of its internal structures (probably implemented in C). Conversion from them to Python AST cost more than building new AST from scratch.\n\n``Smart Imports`` build AST only once for every module.\n\nDefault import rules\n====================\n\n``Smart Imports`` can be used without configuration. By default it uses such rules:\n\n#. By exact match looks for the module with the required name in the folder of the current module.\n#. Checks if the standard library has a module with the required name.\n\n   #. By exact match with top-level packages (for example, ``math`` ).\n   #. For sub-packages and modules checks complex names with dots replaced by underscores (for example, ``os.path`` will be imported for name ``os_path``).\n\n#. By exact match looks for installed packages with the required name (for example, ``requests`` ).\n\nPerformance\n===========\n\n``Smart Imports`` does not slow down runtime but increases startup time.\n\nBecause of building AST, startup time increased in 1.5-2 times. For small projects it is inconsequential. At the same time, the startup time of large projects depends mostly on architecture and dependencies between modules, than from the time of modules import.\n\nIn the future, part of ``Smart Imports`` can be rewritten in C — it should eliminate startup delays.\n\nTo speed up startup time, results of AST processing can be cached on the file system. That behavior can be turned on in the config. ``SmartImports`` invalidates cache when module source code changes.\n\nAlso, ``Smart Imports``\' work time highly depends on rules and their sequence. You can reduce these costs by modifying configs. For example, you can specify an explicit import path for a name with `Rule 4: custom names`_.\n\nConfiguration\n=============\n\nThe logic of default configuration was already described. It should be enough to work with the standard library.\n\nDefault config:\n\n.. code-block:: javascript\n\n    {\n        "cache_dir": null,\n        "rules": [{"type": "rule_local_modules"},\n                  {"type": "rule_stdlib"},\n                  {"type": "rule_predefined_names"},\n                  {"type": "rule_global_modules"}]\n    }\n\n\nIf necessary, a more complex config can be put on a file system.\n\n`Example of complex config <https://github.com/the-tale/the-tale/blob/develop/src/the_tale/the_tale/smart_imports.json>`_ (from my pet project).\n\nAt the time of call ``smart_import.all()`` library detects a location of config file by searching file ``smart_imports.json`` from the current folder up to root. If a file will be found, it will become config for the current module.\n\nYou can use multiple config files (place them in different folders).\n\nThere are few config parameters now:\n\n.. code-block:: javascript\n\n    {\n        // folder to store cached AST\n        // if not specified or null, cache will not be used\n        "cache_dir": null|"string",\n\n        // list of import rules (see further)\n        "rules": []\n    }\n\nImport rules\n============\n\nA sequence of rules in configs determines the order of their application. The first success rule stops processing and makes import.\n\n`Rule 1: predefined names`_ will be often used in the examples below. It required for the correct processing of default names like ``print``.\n\nRule 1: predefined names\n------------------------\n\nRule silences import search for predefined names like ``__file__`` and builtins like ``print``.\n\n.. code-block:: python\n\n    # config:\n    # {\n    #    "rules": [{"type": "rule_predefined_names"}]\n    # }\n\n    import smart_imports\n\n    smart_imports.all()\n\n    # Smart Imports will not search for module with name __file__\n    # event if variable is not initialized explicity in code\n    print(__file__)\n\n\nRule 2: local modules\n---------------------\n\nRule checks if a module with the required name exists in the folder of the current module. If the module found, it will be imported.\n\n.. code-block:: python\n\n    # config:\n    # {\n    #    "rules": [{"type": "rule_predefined_names"},\n    #              {"type": "rule_local_modules"}]\n    # }\n    #\n    # project on file sytem:\n    #\n    # my_package\n    # |-- __init__.py\n    # |-- a.py\n    # |-- b.py\n\n    # b.py\n    import smart_imports\n\n    smart_imports.all()\n\n    # module "a" will be found and imported\n    print(a)\n\n\nRule 3: global modules\n----------------------\n\nRule tries to import the module by name.\n\n.. code-block:: python\n\n    # config:\n    # {\n    #    "rules": [{"type": "rule_predefined_names"},\n    #              {"type": "rule_global_modules"}]\n    # }\n    #\n    # install external package\n    #\n    # pip install requests\n\n    import smart_imports\n\n    smart_imports.all()\n\n    # module "requests" will be found and imported\n    print(requests.get(\'http://example.com\'))\n\n\nRule 4: custom names\n--------------------\n\nRule links a name to the specified module and its attribute (optionally).\n\n.. code-block:: python\n\n    # config:\n    # {\n    #    "rules": [{"type": "rule_predefined_names"},\n    #              {"type": "rule_custom",\n    #               "variables": {"my_import_module": {"module": "os.path"},\n    #                             "my_import_attribute": {"module": "random", "attribute": "seed"}}}]\n    # }\n\n    import smart_imports\n\n    smart_imports.all()\n\n    # we use modules of the standard library in that example\n    # but any module can be used\n    print(my_import_module)\n    print(my_import_attribute)\n\n\nRule 5: standard library\n------------------------\n\nRule checks if the standard library has a module with the required name. For example ``math`` or ``os.path`` (which will be imported for the name ``os_path``).\n\nThat rule works faster than `Rule 3: global modules`_, since it searches module by predefined list. Lists of modules for every Python version was collected with help of `stdlib-list <https://pypi.org/project/stdlib-list/>`_.\n\n.. code-block:: python\n\n    # config:\n    # {\n    #    "rules": [{"type": "rule_predefined_names"},\n    #              {"type": "rule_stdlib"}]\n    # }\n\n    import smart_imports\n\n    smart_imports.all()\n\n    print(math.pi)\n\n\nRule 6: import by prefix\n------------------------\n\nRule imports module by name from the package, which associated with name prefix. It can be helpful when you have a package used in the whole project. For example, you can access modules from package ``utils`` with prefix ``utils_``.\n\n.. code-block:: python\n\n    # config:\n    # {\n    #    "rules": [{"type": "rule_predefined_names"},\n    #              {"type": "rule_prefix",\n    #               "prefixes": [{"prefix": "utils_", "module": "my_package.utils"}]}]\n    # }\n    #\n    # project on filesystem\n    #\n    # my_package\n    # |-- __init__.py\n    # |-- utils\n    # |-- |-- __init__.py\n    # |-- |-- a.py\n    # |-- |-- b.py\n    # |-- subpackage\n    # |-- |-- __init__.py\n    # |-- |-- c.py\n\n    # c.py\n\n    import smart_imports\n\n    smart_imports.all()\n\n    print(utils_a)\n    print(utils_b)\n\n\nRule 7: modules from parent package\n-----------------------------------\n\nIf you have sub-packages with the same name in different parts of your project (for example, ``tests`` or ``migrations``), you can allow for them to search modules by name in parent packages.\n\n.. code-block:: python\n\n    # config:\n    # {\n    #    "rules": [{"type": "rule_predefined_names"},\n    #              {"type": "rule_local_modules_from_parent",\n    #               "suffixes": [".tests"]}]\n    # }\n    #\n    # project on file system:\n    #\n    # my_package\n    # |-- __init__.py\n    # |-- a.py\n    # |-- tests\n    # |-- |-- __init__.py\n    # |-- |-- b.py\n\n    # b.py\n\n    import smart_imports\n\n    smart_imports.all()\n\n    print(a)\n\n\nRule 8: modules from namespace\n------------------------------\n\nThe rule allows for modules from a specified package to import by name modules from another package.\n\n.. code-block:: python\n\n    # config:\n    # {\n    #    "rules": [{"type": "rule_predefined_names"},\n    #              {"type": "rule_local_modules_from_namespace",\n    #               "map": {"my_package.subpackage_1": ["my_package.subpackage_2"]}}]\n    # }\n    #\n    # project on filesystem:\n    #\n    # my_package\n    # |-- __init__.py\n    # |-- subpackage_1\n    # |-- |-- __init__.py\n    # |-- |-- a.py\n    # |-- subpackage_2\n    # |-- |-- __init__.py\n    # |-- |-- b.py\n\n    # a.py\n\n    import smart_imports\n\n    smart_imports.all()\n\n    print(b)\n\nHow to add custom rule?\n-----------------------\n\n#. Subclass ``smart_imports.rules.BaseRule``.\n#. Implement required logic.\n#. Register rule with method ``smart_imports.rules.register``.\n#. Add rule to config.\n#. ???\n#. Profit.\n\nLook into the implementation of current rules, if you need an example.\n\nSimilar projects\n================\n\nThere are a couple of projects with a similar approach:\n\n- `autoimport <https://github.com/lyz-code/autoimport>`_ —\xa0automatically fixes wrong import statements.\n\nIf you think that some projects should be listed here, feel free to make a pull request.\n\n\nMyPY\n====\n\nPlugin for integration with MyPy implemented.\n\nMyPy config (mypy.ini) example:\n\n.. code-block:: ini\n\n   [mypy]\n   plugins = smart_imports.plugins.mypy\n\n\nPlans\n=====\n\nI love the idea of determining code properties by used names. So, I will try to develop it in the borders of ``Smart Imports`` and other projects.\n\nWhat I planning for ``Smart Imports``:\n\n- Continue support and patch it for new versions of Python.\n- Research usage of type annotations to import automatization.\n- Try to implement lazy imports.\n- Implement utilities for automatic config generation and code refactoring.\n- Rewrite part of code in C, to speedup AST construction.\n- Implement integrations with popular IDEs.\n\nI open to your suggestions. Feel free to contact me in any way.\n\n\n.. |pypi| image:: https://img.shields.io/pypi/v/smart_imports.svg?style=flat-square&label=latest%20stable%20version&reset_github_caches=10\n    :target: https://pypi.python.org/pypi/smart_imports\n    :alt: Latest version released on PyPi\n\n.. |python_versions| image:: https://img.shields.io/pypi/pyversions/smart_imports.svg?style=flat-square&reset_github_caches=10\n    :target: https://pypi.python.org/pypi/smart_imports\n    :alt: Supported Python versions\n',
    'author': 'Aliaksei Yaletski (Tiendil)',
    'author_email': 'a.eletsky@gmail.com',
    'maintainer': None,
    'maintainer_email': None,
    'url': 'https://github.com/Tiendil/smart-imports',
    'packages': packages,
    'package_data': package_data,
    'python_requires': '>=3.5',
}


setup(**setup_kwargs)
